# Web Server
*
## 1 Khái niệm cơ bản về Web Server
### 1.1  Định nghĩa Web Server 
- Web Server (Máy chủ web) là phần mềm và phần cứng sử dụng HTTP và các giao thức khác để phản hồi các yêu cầu của khách hàng được thực hiện qua World Wide Web.
- Nhiệm vụ chính của nó là hiển thị nội dung trang web, chẳng hạn như văn bản, hình ảnh, video và ứng dụng, cho người dùng bằng cách lưu trữ, xử lý và phân phối các trang web.
- Máy chủ web cũng được sử dụng trong lưu trữ web, tức là lưu trữ dữ liệu cho các trang web và ứng dụng dựa trên web.
- Máy chủ web động so với máy chủ web tĩnh: Máy chủ web có thể được sử dụng để phục vụ nội dung tĩnh hoặc động. 
	* Tĩnh đề cập đến nội dung được hiển thị nguyên trạng, trong khi nội dung động có thể được cập nhật và thay đổi. Máy chủ web tĩnh bao gồm máy tính và phần mềm HTTP. Nó được coi là tĩnh vì máy chủ gửi các tệp được lưu trữ đã viết sẵn nguyên trạng đến trình duyệt. Ngoài ra, mọi người dùng đều thấy cùng một nội dung vì máy chủ chỉ phân phối các tệp đã lưu trữ. Không có xử lý phía máy chủ, tương tác cơ sở dữ liệu hoặc tạo nội dung động, dành riêng cho người dùng theo thời gian thực.
	* Trình duyệt web động bao gồm máy chủ web và phần mềm khác, chẳng hạn như máy chủ ứng dụng và cơ sở dữ liệu. Nó được coi là động vì máy chủ ứng dụng có thể được sử dụng để cập nhật bất kỳ tệp được lưu trữ nào trước khi chúng được gửi đến trình duyệt. Máy chủ web có thể tạo nội dung bằng cách yêu cầu nội dung đó theo thời gian thực từ cơ sở dữ liệu cơ bản. Ngoài ra, nội dung này được phân phối dựa trên thông tin đầu vào cụ thể của người dùng hoặc các biến khác.
	* Điều này giúp có thể phân phối các tính năng tương tác trên trang web, chẳng hạn như biểu mẫu đăng nhập và giỏ hàng. Các tính năng này được tạo động và tức thời, có thể nâng cao trải nghiệm của người dùng. Tuy nhiên, tính linh hoạt tăng lên của quy trình này cũng làm cho việc thiết kế và triển khai trở nên phức tạp hơn.
### 1.2  Vai trò của Web Server trong mô hình client-server.
- Web server đóng vai trò là một máy chủ (server) chuyên biệt trong mô hình client-server, chịu trách nhiệm chính trong việc:
	* Lưu trữ các tệp tin của website: Web server là nơi lưu trữ tất cả các thành phần tạo nên một trang web, bao gồm các tệp HTML, CSS, JavaScript, hình ảnh, video và các tài liệu khác.
	* Tiếp nhận yêu cầu từ client (trình duyệt web): Khi người dùng truy cập một trang web thông qua trình duyệt (client), trình duyệt sẽ gửi một yêu cầu (request) đến web server chứa trang web đó. Yêu cầu này thường là một yêu cầu HTTP (Hypertext Transfer Protocol).
	* Xử lý yêu cầu: Web server nhận yêu cầu và xử lý nó. Quá trình xử lý có thể bao gồm việc tìm kiếm tệp tin được yêu cầu, xử lý các đoạn mã phía máy chủ (server-side scripting) nếu có, và chuẩn bị dữ liệu để gửi trả lại cho client.
	* Gửi phản hồi (response) đến client: Sau khi xử lý yêu cầu, web server gửi một phản hồi (response) trở lại trình duyệt. Phản hồi này thường bao gồm các tệp tin của trang web (ví dụ: mã HTML) và các thông tin khác để trình duyệt có thể hiển thị trang web cho người dùng. Giao thức HTTP được sử dụng cho việc giao tiếp này.
	* Đảm bảo khả năng truy cập: Web server hoạt động liên tục và được kết nối với mạng internet để đảm bảo rằng người dùng có thể truy cập vào các trang web mà nó lưu trữ bất kỳ lúc nào.
	* Quản lý kết nối đồng thời: Một web server mạnh mẽ có khả năng xử lý đồng thời nhiều yêu cầu từ nhiều client khác nhau một cách hiệu quả.
	* Cung cấp các dịch vụ khác: Ngoài việc phục vụ các tệp tĩnh, web server hiện đại còn có thể tích hợp với các application server và cơ sở dữ liệu để cung cấp các trang web và ứng dụng web động, phức tạp hơn.
### 1.3  Cách thức hoạt động (nhận request, xử lý, trả response).
- Cách thức hoạt động của web server (trong việc nhận request, xử lý và trả response) có thể được mô tả theo các bước sau:
1. Nhận Request (Receiving the Request):
	* Người dùng nhập URL: Quá trình bắt đầu khi người dùng nhập một địa chỉ web (URL - Uniform Resource Locator) vào thanh địa chỉ của trình duyệt web (client) hoặc nhấp vào một liên kết.
	* Trình duyệt phân tích URL: Trình duyệt phân tích URL để xác định giao thức (ví dụ: HTTP, HTTPS), tên miền (ví dụ: www.example.org), và đường dẫn tài nguyên cụ thể (ví dụ: /what-is-a-web-server-working-and-architecture/).
	* Trình duyệt tìm kiếm địa chỉ IP: Trình duyệt sử dụng Hệ thống Tên miền (DNS - Domain Name System) để dịch tên miền thành địa chỉ IP tương ứng của web server.
	* Trình duyệt thiết lập kết nối TCP/IP: Sau khi có địa chỉ IP, trình duyệt thiết lập một kết nối TCP/IP (Transmission Control Protocol/Internet Protocol) với web server trên cổng mặc định cho HTTP (thường là cổng 80) hoặc HTTPS (thường là cổng 443).
	* Trình duyệt gửi HTTP Request: Khi kết nối được thiết lập, trình duyệt gửi một yêu cầu HTTP (HTTP request) đến web server. Yêu cầu này bao gồm:
	* Phương thức HTTP: Xác định hành động mà client muốn thực hiện (ví dụ: GET để lấy dữ liệu, POST để gửi dữ liệu, PUT để cập nhật dữ liệu, DELETE để xóa dữ liệu).
	* Đường dẫn tài nguyên: Xác định tài nguyên cụ thể mà client yêu cầu (ví dụ: /index.html, /images/logo.png).
	* Phiên bản HTTP: Xác định phiên bản giao thức HTTP đang được sử dụng (ví dụ: HTTP/1.1, HTTP/2).
	* Tiêu đề (Headers): Cung cấp thông tin bổ sung về yêu cầu, chẳng hạn như loại trình duyệt, ngôn ngữ ưu tiên, cookie, v.v.
2. Xử lý Request (Processing the Request):
	* Web server nhận yêu cầu: Web server lắng nghe các yêu cầu đến trên các cổng được chỉ định. Khi nhận được một yêu cầu HTTP từ client, nó sẽ bắt đầu quá trình xử lý.
	* Web server phân tích yêu cầu: Web server phân tích yêu cầu HTTP để xác định tài nguyên được yêu cầu, phương thức HTTP và các tiêu đề khác.
	* Web server tìm kiếm tài nguyên: Web server tìm kiếm tài nguyên được yêu cầu trong hệ thống tệp tin của nó.
	* Xử lý phía máy chủ (nếu cần): Nếu yêu cầu liên quan đến một tài nguyên động (ví dụ: một trang PHP, Python, Node.js), web server có thể chuyển yêu cầu này đến một application server hoặc một trình thông dịch (interpreter) tương ứng để xử lý logic nghiệp vụ, truy vấn cơ sở dữ liệu, v.v. Application server sau đó sẽ tạo ra nội dung động.
	* Tạo HTTP Response: Sau khi tìm thấy tài nguyên (hoặc sau khi application server xử lý và trả về dữ liệu), web server tạo ra một phản hồi HTTP (HTTP response). Phản hồi này bao gồm:
	* Phiên bản HTTP: Phiên bản giao thức HTTP được sử dụng.
	* Mã trạng thái (Status Code): Một mã số ba chữ số cho biết kết quả của yêu cầu (ví dụ: 200 OK cho thành công, 404 Not Found cho không tìm thấy, 500 Internal Server Error cho lỗi máy chủ).
	* Thông báo trạng thái (Status Message): Một mô tả ngắn gọn về mã trạng thái (ví dụ: OK, Not Found, Internal Server Error).
	* Tiêu đề (Headers): Cung cấp thông tin bổ sung về phản hồi, chẳng hạn như loại nội dung (Content-Type), độ dài nội dung (Content-Length), thông tin về máy chủ, cookie, v.v.
	* Phần thân (Body): Chứa nội dung thực tế của tài nguyên được yêu cầu (ví dụ: mã HTML của trang web, hình ảnh, dữ liệu JSON). Đối với các yêu cầu thành công (ví dụ: GET), phần thân sẽ chứa dữ liệu được yêu cầu. Đối với một số phản hồi lỗi, phần thân có thể chứa thông báo lỗi.
3. Trả Response (Sending the Response):
	* Web server gửi HTTP Response: Web server gửi phản hồi HTTP trở lại trình duyệt (client) thông qua kết nối TCP/IP đã thiết lập.
	* Trình duyệt nhận Response: Trình duyệt nhận phản hồi HTTP từ web server.
	* Trình duyệt xử lý Response: Trình duyệt phân tích phản hồi, bao gồm mã trạng thái, tiêu đề và phần thân.
	* Trình duyệt hiển thị nội dung: Dựa trên nội dung trong phần thân (thường là mã HTML), trình duyệt sẽ hiển thị trang web cho người dùng. Nếu phản hồi bao gồm các tài nguyên khác (ví dụ: CSS, JavaScript, hình ảnh), trình duyệt sẽ gửi các yêu cầu riêng biệt cho các tài nguyên này và hiển thị trang web hoàn chỉnh.
	* Kết nối đóng (thường): Sau khi gửi và nhận hoàn tất phản hồi (đối với HTTP/1.1 trở về trước), kết nối TCP/IP thường sẽ bị đóng. HTTP/2 và các phiên bản mới hơn có thể duy trì kết nối để xử lý nhiều yêu cầu và phản hồi hiệu quả hơn.
## 2. Các loại Web Server phổ biến
### 2.1 Apache HTTP Server (đặc điểm, ưu nhược điểm).
- Apache HTTP Server là một máy chủ web mã nguồn mở và miễn phí được viết bởi Apache Software Foundation (ASF). Đây là một trong những máy chủ web được sử dụng rộng rãi nhất, phục vụ hàng triệu trang web trên nhiều nền tảng khác nhau như Linux, Windows và macOS, và là một phần không thể thiếu của ngăn xếp LAMP (Linux, Apache, MySQL, PHP), thường được sử dụng để lưu trữ và phát triển web.
- Apache sử dụng mô hình máy khách-máy chủ để xử lý các yêu cầu HTTP và HTTPS khi người dùng nhập địa chỉ trang web:
	* Người dùng nhập địa chỉ trang web vào trình duyệt web của họ.
	* Trình duyệt thực hiện yêu cầu HTTP đến máy chủ web.
	* Apache thực hiện yêu cầu và tìm nạp tài liệu được yêu cầu (HTML, CSS, hình ảnh, v.v.).
	* Apache trả về phản hồi cho trình duyệt web của người dùng.
	* Trình duyệt hiển thị trang web.
- Apache lắng nghe HTTP trên cổng 80 và HTTPS trên cổng 443.
- Các tính năng của máy chủ web Apache: Máy chủ web Apache cung cấp một số tính năng khiến nó trở thành lựa chọn tuyệt vời cho dịch vụ lưu trữ web và quản lý máy chủ.
	* Xử lý các tệp tĩnh
	* Các mô-đun động có thể tải
	* Lập chỉ mục tự động
	* .htaccess
	* Khả năng tương thích IPv6
	* Hỗ trợ hỗ trợ HTTP/2
	* Kết nối FTP
	* Nén và giải nén Gzip
	* Load Balancing 
	* Hỗ trợ các ngôn ngữ tập lệnh Perl, PHP, Lua
	* Bandwidth throttling
	* Theo dõi phiên
	* Rewrite URL
	* Định vị địa lý dựa trên địa chỉ IP
- Ưu điểm 
    * Miễn phí và mã nguồn mở: Apache là phần mềm mã nguồn mở
    * Phổ biến và ổn định: Web server này được sử dụng rộng rãi trên toàn thế giới và đã tồn tại trong nhiều năm.
    * Đa nền tảng: Apache có thể chạy trên nhiều hệ điều hành, bao gồm Linux, Windows, macOS và nhiều hệ điều hành khác.
    * Mở rộng và linh hoạt: Web server này hỗ trợ nhiều module mà bạn có thể bật hoặc tắt để tùy chỉnh chức năng của máy chủ web.
    * Bảo mật: Apache cung cấp nhiều tùy chọn bảo mật và có cộng đồng đông đảo hỗ trợ cho việc cập nhật bảo mật và vá lỗi một cách nhanh chóng.
    * Hỗ trợ cho nhiều ngôn ngữ lập trình: Web server này hỗ trợ nhiều ngôn ngữ lập trình, bao gồm PHP, Python, Ruby và nhiều ngôn ngữ khác, giúp bạn xây dựng ứng dụng web đa dạng.
    * Cộng đồng lớn: Apache có một cộng đồng người dùng và phát triển lớn. Điều này có nghĩa là bạn có thể tìm thấy nhiều tài liệu hướng dẫn, tài liệu tham khảo và hỗ trợ từ cộng đồng khi gặp vấn đề.
- Nhược điểm 
	* Tiêu tốn nhiều tài nguyên: Web server này có thể tiêu tốn nhiều tài nguyên hệ thống, đặc biệt là khi phải xử lý đồng thời nhiều yêu cầu. Điều này có thể dẫn đến tình trạng sử dụng bộ nhớ và CPU cao, đặc biệt trong các trường hợp tải đột ngột.
	* Khả năng mở rộng hạn chế: Web server này không luôn hoạt động tốt khi phải xử lý hàng ngàn yêu cầu đồng thời. Trong các trường hợp cần mở rộng quy mô, cấu hình và tinh chỉnh cần được thực hiện kỹ lưỡng.
	* Không hỗ trợ HTTP/2 mặc định: Trong phiên bản cơ bản, Web server này không hỗ trợ giao thức HTTP/2 mà thay vào đó sử dụng HTTP/1.1. Mặc dù bạn có thể cấu hình để sử dụng HTTP/2, nhưng điều này đòi hỏi thêm công việc cài đặt và cấu hình.
	* Cấu hình phức tạp: Cấu hình Apache có thể phức tạp, đặc biệt đối với người mới bắt đầu. Việc cài đặt và tinh chỉnh máy chủ Apache có thể đòi hỏi kiến thức kỹ thuật sâu và thời gian.
	* Sự cố và lỗi phát triển chậm: Một số lỗi và vấn đề bảo mật có thể phát triển và được vá chậm hơn so với các máy chủ web khác. Điều này đòi hỏi cẩn trọng khi cập nhật và duyệt các bản vá bảo mật.
	* Hiệu năng bị ảnh hưởng bởi mô-đun thứ ba: Web server này sử dụng nhiều mô-đun bên ngoài để cung cấp các tính năng bổ sung. Sự kết hợp của nhiều mô-đun này có thể ảnh hưởng đến hiệu năng và tính ổn định của máy chủ.
	* Yêu cầu kiến thức kỹ thuật: Để cấu hình và quản lý máy chủ Apache hiệu quả, bạn cần có kiến thức kỹ thuật về nền tảng hệ điều hành và mạng, cũng như về cấu hình máy chủ web.
### 2.2 Nginx (kiến trúc event-driven, hiệu suất cao).
- nginx ("engine x") là một máy chủ web HTTP, proxy đảo ngược, bộ đệm nội dung, bộ cân bằng tải, máy chủ proxy TCP/UDP và máy chủ proxy thư điện tử. 
- Được viết ban đầu bởi Igor Sysoev và phân phối theo giấy phép BSD 2 điều khoản.
- Nổi tiếng về tính linh hoạt và hiệu suất cao với mức sử dụng tài nguyên thấp, nginx là:
	* Máy chủ web phổ biến nhất trên thế giới
	* Một trong những image Docker phổ biến nhất
	* Là nền tảng cung cấp sức mạnh cho nhiều Ingress Controller cho Kubernetes.
- NGINX dẫn đầu về hiệu suất web và tất cả là nhờ cách phần mềm được thiết kế. Trong khi nhiều máy chủ web và máy chủ ứng dụng sử dụng kiến ​​trúc dựa trên luồng hoặc quy trình đơn giản, NGINX nổi bật với kiến ​​trúc điều khiển sự kiện tinh vi cho phép mở rộng quy mô lên hàng trăm nghìn kết nối đồng thời trên phần cứng hiện đại.
- Kiến trúc Nginx: 
* NGINX sử dụng một mô hình tiến trình có thể dự đoán và được điều chỉnh phù hợp với các tài nguyên phần cứng hiện có:
	* Master process - Hoạt động như bộ điều khiển trung tâm và chịu trách nhiệm khởi động, dừng và khởi chạy các Worker processes.
	* Worker processes - Các quy trình này chạy logic NGINX cốt lõi và chịu trách nhiệm xử lý kết nối, chuyển tiếp yêu cầu, cân bằng tải, v.v.
	* Cache loader - Quy trình này chịu trách nhiệm tải siêu dữ liệu được lưu trong bộ nhớ đệm vào bộ nhớ khi Nginx khởi động.
	* Cache manager - Định kỳ kiểm tra thư mục bộ đệm và giải phóng dung lượng bằng cách xóa các mục đã hết hạn.
	* Shared memory - Giao tiếp giữa các quy trình diễn ra thông qua bộ nhớ dùng chung. Nó cũng được sử dụng để lưu vào bộ đệm và quản lý trạng thái dùng chung như trạng thái cân bằng tải.
- ![images](./images/nginx-archite.png)
- NGINX nổi bật với kiến ​​trúc event-driven cho phép mở rộng tới hàng trăm nghìn kết nối đồng thời trên phần cứng hiện đại.
- Worker Process tuân theo mô hình event-driven, sử dụng cơ chế như epoll (trên Linux) để xử lý nhiều kết nối đồng thời trên một luồng (thread) duy nhất.
	* A. Khởi tạo và chờ sự kiện
		* Khởi tạo: Sau khi được Master Process tạo ra, Worker Process đọc thông tin cấu hình từ tệp cấu hình Nginx và thiết lập vòng lặp sự kiện (event loop) để theo dõi các kết nối mới, các yêu cầu I/O, hoặc các tác vụ cần xử lý.
		* Chờ sự kiện: Worker Process đăng ký các sự kiện cần theo dõi (như kết nối mới, dữ liệu đến, hoặc ghi dữ liệu xong) với hệ thống thông qua cơ chế epoll.
	* B. Xử lý kết nối
		* Nhận sự kiện từ epoll: Khi có sự kiện (như một yêu cầu mới từ client), epoll thông báo cho Worker Process và Worker Process xử lý sự kiện đó ngay lập tức.
		* Không chặn kết nối: Worker Process không chặn khi chờ dữ liệu hoặc tài nguyên. Nếu dữ liệu chưa sẵn sàng (ví dụ: chưa đọc xong body yêu cầu), Worker Process tạm ngừng và tiếp tục xử lý các kết nối khác trong hàng đợi.
		* Xử lý song song: Dù mỗi Worker Process chỉ chạy một luồng nhưng nó có thể xử lý hàng nghìn kết nối đồng thời bằng cách xen kẽ giữa các sự kiện trong vòng lặp.
	* C. Xử lý yêu cầu
		* Phân tích yêu cầu: Phân tích cú pháp HTTP request (headers, method, URL, v.v.), kiểm tra tính hợp lệ và thực hiện các bước được chỉ định trong cấu hình.
		* Thực hiện nhiệm vụ: Phục vụ nội dung tĩnh, proxy request đến backend server, hoặc xử lý SSL/TLS.
	* D. Gửi phản hồi
		* Chuẩn bị phản hồi: Tạo HTTP response với status code, headers, và body.
		* Gửi phản hồi: Ghi dữ liệu qua socket hoặc gửi từng phần nếu dữ liệu lớn (chunked response).
	* E. Kết thúc hoặc giữ kết nối
		* Sau khi xử lý xong, Worker Process sẽ đóng kết nối nếu không có yêu cầu tiếp theo hoặc giữ kết nối mở nếu HTTP keep-alive được bật.
- Đặc điểm của Nginx
	* Kiến trúc tinh vi: Asynchronous, event-driven, xử lý hiệu quả nhiều kết nối đồng thời, phản hồi nhanh.
	* Phân phối nội dung tĩnh hiệu quả: Tốc độ cao, quản lý đồng thời nhiều kết nối, trải nghiệm người dùng nhanh hơn.
	* Sử dụng tài nguyên tối ưu: Tiêu thụ tài nguyên tối thiểu, lý tưởng cho lưu lượng truy cập cao.
	* Phân phối yêu cầu thông minh: Reverse proxy, tối ưu hóa thời gian phản hồi, cân bằng tải, chống quá tải máy chủ.
	* Hiệu suất và khả năng mở rộng vượt trội: Xử lý kết nối và yêu cầu độc đáo, phục vụ nhanh nội dung tĩnh, quản lý tốt lưu lượng truy cập tăng đột biến.- Ưu điểm của Nginx
- Ưu điểm:
	* Hiệu suất cao: Tốc độ vượt trội, phân phối nhanh nội dung tĩnh, cải thiện trải nghiệm người dùng và giảm thời gian tải trang.
	* Sử dụng tài nguyên thấp: Kiến trúc bất đồng bộ, xử lý nhiều kết nối với mức tiêu thụ bộ nhớ tối thiểu, lựa chọn kinh tế cho nhiều mô hình lưu trữ.
	* Khả năng mở rộng: Thích ứng linh hoạt với lưu lượng truy cập tăng, đảm bảo hiệu suất ổn định khi nhu cầu cao. 
	* Cân bằng tải: Phân phối hiệu quả yêu cầu đến giữa các máy chủ, chống quá tải và tối ưu hóa sử dụng tài nguyên, tạo môi trường web ổn định và phản hồi nhanh.
- Nhược điểm: Mặc dù NGINX có nhiều ưu điểm nổi bật, việc cân nhắc các nhược điểm tiềm ẩn cũng rất quan trọng:
	* Cấu hình phức tạp: Một số người dùng nhận thấy cấu hình của NGINX phức tạp hơn so với các máy chủ web khác. Việc cấu hình cho các yêu cầu cụ thể có thể gây khó khăn cho những người chưa quen với thiết lập của nó.
	* Hạn chế xử lý nội dung động gốc: Mặc dù vượt trội trong việc phục vụ nội dung tĩnh, NGINX có thể yêu cầu các cấu hình bổ sung để xử lý nội dung động tối ưu. Thiết lập bổ sung này có thể được coi là một nhược điểm đối với những người dùng tìm kiếm một giải pháp đơn giản hơn.
### 2.3 Microsoft IIS (dành cho Windows Server).
- Internet Information Services, hay còn gọi là IIS, là một máy chủ web của Microsoft chạy trên hệ điều hành Windows và được sử dụng để trao đổi nội dung web tĩnh và động với người dùng internet. IIS có thể được dùng để lưu trữ, triển khai và quản lý các ứng dụng web sử dụng các công nghệ như ASP.NET và PHP.
- IIS sử dụng nhiều giao thức khác nhau để giao tiếp và trao đổi dữ liệu với các máy khách hoặc máy tính từ xa, chẳng hạn như HTTP, SMTP và FTP. Là một sản phẩm cốt lõi của Windows, IIS được tích hợp sẵn trong Windows Server và chạy trên hệ điều hành Windows.
- Cách IIS hoạt động:  Một máy chủ web IIS hoạt động như một máy chủ web linh hoạt, dạng mô-đun, xử lý các yêu cầu từ máy khách (thường là HTTP và HTTPS) và gửi lại các phản hồi thích hợp. Dưới đây là một quy trình đơn giản hóa về cách nó hoạt động:
	* Xử lý yêu cầu: Máy chủ IIS lắng nghe trên các cổng được chỉ định (80 cho HTTP và 443 cho HTTPS) và chuyển các yêu cầu đến từ máy khách đến đúng website hoặc ứng dụng.
	* Application pools (vùng ứng dụng): Mỗi yêu cầu được quản lý bởi một tiến trình worker bên trong một application pool. Các application pool này cô lập các ứng dụng web khác nhau để tăng cường bảo mật và hiệu suất.
	* Modules (mô-đun): IIS sử dụng các mô-đun cho các tác vụ cụ thể như xác thực, viết lại URL và nén. Các mô-đun này có thể được bật hoặc tắt tùy thuộc vào cấu hình máy chủ của bạn.
	* Phản hồi: Sau khi xử lý, máy chủ IIS gửi nội dung được yêu cầu (ví dụ: HTML, tệp tin hoặc thông báo lỗi) trở lại trình duyệt của máy khách.
-![images](./images/how-iis-works.png)
- Các tính năng chính của IIS:
	* Hỗ trợ gốc .NET/ASP.NET: Tối ưu cho ứng dụng Microsoft.
	* Tích hợp Visual Studio: Phát triển web hiệu quả.
	* Application Pool: Cô lập ứng dụng, tăng bảo mật và ổn định.
	* Khả năng mở rộng: Xử lý lưu lượng lớn với cân bằng tải.
	* Bảo mật: Nhiều phương pháp xác thực, mã hóa SSL, lọc yêu cầu, hạn chế IP.
	* Viết lại URL: Tối ưu SEO và quản lý URL.
	* Nén: Giảm băng thông, tăng tốc tải trang.
	* Quản lý tập trung: Dễ dàng quản lý nhiều máy chủ IIS.
	* Bộ nhớ đệm động: Cải thiện tốc độ phản hồi.
	* Hỗ trợ đa dạng công nghệ: Tương thích PHP và nhiều ngôn ngữ khác.
- Ưu điểm 
	* Tích hợp sâu với Windows, mang lại hiệu suất và tương thích tốt.
	* Giao diện IIS Manager trực quan, giúp quản lý dễ dàng.
	* Hỗ trợ nhiều giao thức và tính năng bảo mật, quản lý quan trọng.
	* Kiến trúc module mở rộng, linh hoạt tùy biến theo nhu cầu.
	* Hiệu suất ổn định, đáng tin cậy cho các ứng dụng .NET.
	* Cộng đồng hỗ trợ lớn và tài liệu phong phú, dễ tìm kiếm giúp đỡ.
- Nhược điểm 
	* Tối ưu nhất cho Windows Server, có chi phí bản quyền.
	* Có thể phức tạp cho người mới làm quen với web server.
	* Là mục tiêu tấn công tiềm năng, cần cập nhật bảo mật thường xuyên.
	* Kém linh hoạt hơn một số web server mã nguồn mở trong tùy chỉnh sâu.
	* Yêu cầu tài nguyên hệ thống đáng kể khi tải lớn hoặc ứng dụng phức tạp.
### 2.4 Lighttpd, Caddy, LiteSpeed (các lựa chọn khác).
#### 2.4.1 Lighttpd
- Lighttpd là một phần mềm máy chủ web mã nguồn mở. Nó được thiết kế đặc biệt cho các môi trường có tài nguyên hạn chế vì nó tiêu thụ CPU và RAM rất ít. Nó cũng phù hợp cho cả hệ điều hành Windows và Linux (OS)
- Lighttpd là một máy chủ web an toàn, nhanh chóng, tuân thủ các tiêu chuẩn và rất linh hoạt, được tối ưu hóa cho các môi trường hiệu suất cao. Nó có mức tiêu thụ bộ nhớ rất thấp so với các máy chủ web khác và chú trọng đến việc giảm tải cho CPU. Bộ tính năng nâng cao của nó (FastCGI, CGI, xác thực, nén đầu ra, viết lại URL và nhiều hơn nữa) khiến lighttpd trở thành phần mềm máy chủ web hoàn hảo cho mọi máy chủ đang gặp vấn đề về tải trọng.
- Được phát hành lần đầu năm 2003 bởi Jan Kneschke, một nhà phát triển phần mềm người Đức. Kneschke ban đầu viết phần mềm này để chứng minh rằng một máy chủ có thể xử lý 10.000 kết nối đồng thời, hay còn được gọi là vấn đề c10k.
- Lighttpd hỗ trợ FastCGI, CGI và SCGI. Nhờ đó, bạn có thể sử dụng phần mềm máy chủ này với các ứng dụng được viết bằng bất kỳ ngôn ngữ lập trình nào, bao gồm: PHP, Python, Perl, Ruby, Lua.
- Ưu điểm 
	* Sử dụng tối thiểu CPU, RAM và các tài nguyên khác.
	* Hỗ trợ tất cả các ngôn ngữ lập trình.
	* Là mã nguồn mở và miễn phí sử dụng.
- Nhược điểm 
	* Không phổ biến bằng các tùy chọn phần mềm khác, vì vậy bạn sẽ tìm thấy ít hỗ trợ từ cộng đồng và tài liệu hơn.
	* Thiếu các tính năng nâng cao và các mô-đun tùy chỉnh so với các phần mềm máy chủ khác.
	* Lighttpd có những lợi thế về hiệu suất hạn chế đối với các trang web lớn hơn.
#### 2.4.2 Caddy 
- Caddy là một máy chủ web hiện đại, mã nguồn mở, được thiết kế để đơn giản, hiệu quả và dễ dàng di chuyển. Nó nổi tiếng với khả năng hỗ trợ HTTPS tự động, cấu hình dễ dàng thông qua Caddyfile và khả năng mở rộng thông qua các plugin. Caddy đóng vai trò là một nền tảng để phục vụ các ứng dụng web, API và các dịch vụ khác, và nó được xây dựng tập trung vào việc đơn giản hóa quản lý máy chủ web.
- Caddy về cơ bản là một hệ thống quản lý cấu hình có thể chạy nhiều ứng dụng khác nhau như một máy chủ HTTP, trình quản lý chứng chỉ TLS, các tiện ích PKI và hơn thế nữa. Nó có thể được mở rộng bằng các plugin được gọi là các mô-đun cấu hình.
- Caddy sở hữu một reverse proxy HTTP mạnh mẽ và linh hoạt, API cấu hình trực tuyến và một máy chủ tệp tĩnh mạnh mẽ, sẵn sàng cho môi trường production, đồng thời phục vụ tất cả các trang web qua HTTPS theo mặc định với chứng chỉ TLS tự động.
- Caddy nổi bật với:
	* HTTPS tự động: Tự động quản lý chứng chỉ TLS miễn phí.
	* HTTP/3: Hỗ trợ giao thức web mới nhất cho tốc độ cao.
	* Cấu hình đơn giản: Sử dụng Caddyfile dễ đọc và viết.
	* Mở rộng linh hoạt: Kiến trúc module cho phép thêm tính năng.
	* API mạnh mẽ: Cung cấp khả năng điều khiển server động.
	* Đa nền tảng: Chạy trên nhiều hệ điều hành khác nhau.
	* Nhẹ và độc lập: Một file thực thi duy nhất, không cần phụ thuộc ngoài.
	* Quản lý tài nguyên tự động: Tối ưu hóa hiệu suất server.
	* Hỗ trợ Virtual Hosts: Dễ dàng quản lý nhiều website trên một server.
	* Cân bằng tải: Phân phối lưu lượng truy cập đến nhiều backend.
	* Reverse Proxy: Chuyển tiếp yêu cầu đến các server khác.
	* Phục vụ file tĩnh hiệu quả: Tối ưu cho việc cung cấp nội dung tĩnh.
	* Hiển thị Markdown: Tự động render file Markdown thành trang web.
	* Hỗ trợ WebSockets: Cho phép ứng dụng real-time.
	* Ghi log chi tiết: Theo dõi hoạt động của server.
	* Xuất metrics: Giám sát hiệu suất server dễ dàng.
	* Hỗ trợ gRPC: Cho giao tiếp hiệu suất cao giữa các dịch vụ.
- Ưu điểm:
	* Dễ sử dụng: Cấu hình đơn giản với Caddyfile, tự động quản lý HTTPS.
	* Linh hoạt: Kiến trúc module cho phép mở rộng tính năng.
	* Hiệu suất cao: Hỗ trợ HTTP/3 và quản lý tài nguyên hiệu quả.
	* Tự động HTTPS: Tích hợp sẵn Let's Encrypt, dễ dàng có chứng chỉ TLS miễn phí.
	* Đa năng: Hỗ trợ nhiều giao thức, có thể hoạt động như reverse proxy, load balancer.
	* Nhẹ và độc lập: Một file chạy duy nhất, không cần phụ thuộc ngoài.
	* API mạnh mẽ: Cho phép điều khiển và cấu hình server động.
	* Chạy đa nền tảng: Hoạt động tốt trên Windows, macOS, Linux.
- Nhược điểm:
	* Thiếu tài liệu: Có thể gặp khó khăn khi tìm kiếm thông tin chi tiết hoặc các ví dụ nâng cao.
	* Bộ tính năng hạn chế: So với các web server lâu đời và phổ biến như Nginx hay Apache, số lượng module và tính năng tích hợp sẵn có thể ít hơn.
	* Cộng đồng nhỏ hơn: Cộng đồng người dùng và nhà phát triển có thể nhỏ hơn, dẫn đến ít tài nguyên và hỗ trợ từ cộng đồng hơn.
#### 2.4.3 LiteSpeed
- LiteSpeed Web Server (LSWS) là một máy chủ web hiệu suất cao, an toàn, dễ sử dụng và có thể được dùng để thay thế trực tiếp cho máy chủ web Apache. Nó có thể xử lý hàng ngàn kết nối đồng thời với mức tiêu thụ bộ nhớ nhỏ và dễ dàng ngăn chặn các cuộc tấn công.
- LiteSpeed Web Server nổi bật với:
	* Hiệu suất cao: Nhờ kiến trúc hướng sự kiện (event-driven), I/O bất đồng bộ và LSAPI tối ưu.
	* Cache mạnh mẽ (LSCache): Tăng tốc đáng kể cho các ứng dụng động như WordPress.
	* Bảo mật toàn diện (LSWAF): Tường lửa ứng dụng web tích hợp, chống DDoS và brute-force.
	* Hỗ trợ giao thức mới nhất: HTTP/3 và HTTP/2 cho tốc độ truyền tải nhanh hơn.
	* Dễ quản lý: Giao diện WebAdmin trực quan và cài đặt một chạm cho nhiều ứng dụng.
	* Khả năng mở rộng: Phục vụ tốt cho cả lưu lượng truy cập nhỏ và lớn.
	* Tương thích Apache: Hỗ trợ rewrite rules (.htaccess).
- Ưu điểm LiteSpeed :
	* Nhanh hơn Apache.
	* Chịu tải tốt hơn.
	* Cache tích hợp (LSCache) mạnh.
	* Bảo mật tốt hơn.
	* Tiết kiệm tài nguyên.
	* Hỗ trợ HTTP/3.
	* PHP nhanh hơn (LSAPI).
	* Dễ dùng với control panel.
- Nhược điểm LiteSpeed :
	* Tốn phí (cần license).
	* Cộng đồng nhỏ hơn.
	* Tương thích module Apache có thể hạn chế.	
### 2.5 So sánh mã nguồn mở và thương mại
| Tính năng                     | Web Server Mã Nguồn Mở (Ví dụ: Apache, Nginx, Lighttpd, Caddy)                                              | Web Server Thương Mại (Ví dụ: Microsoft IIS, LiteSpeed Enterprise)                         |
| ----------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| Chi phí                   | Thường miễn phí sử dụng, có thể có chi phí cho module/hỗ trợ nâng cao                                       | Yêu cầu chi phí bản quyền cho phiên bản đầy đủ hoặc tính năng nâng cao                     |
| Cộng đồng & Hỗ trợ        | Cộng đồng lớn, nhiều diễn đàn, tài liệu, đóng góp từ người dùng; hỗ trợ không chính thức, dựa vào cộng đồng | Cộng đồng có thể nhỏ hơn; hỗ trợ thương mại chuyên nghiệp từ nhà cung cấp                  |
| Tính linh hoạt & Tùy biến | Mã nguồn mở, cho phép tùy chỉnh sâu vào lõi; nhiều module/extension từ cộng đồng                            | Ít linh hoạt hơn trong tùy chỉnh lõi; tính năng thường giới hạn trong phạm vi nhà cung cấp |
| Hỗ trợ nền tảng           | Thường đa nền tảng (Linux, Windows, macOS, BSD)                                                             | Có thể tối ưu hóa hoặc ưu tiên một số nền tảng nhất định                                   |
| Dễ sử dụng & Quản lý      | Cấu hình có thể phức tạp (file cấu hình), đòi hỏi kiến thức kỹ thuật                                        | Thường có giao diện đồ họa (GUI) trực quan, dễ quản lý hơn                                 |
| Hiệu suất                 | Hiệu suất tốt, cần tối ưu hóa cấu hình và lựa chọn module; kiến trúc event-driven cho hiệu suất cao         | Hiệu suất thường được tối ưu hóa sẵn, đặc biệt với các tính năng độc quyền                 |
| Bảo mật                   | Dựa vào cộng đồng phát hiện và vá lỗi; cần cấu hình bảo mật cẩn thận                                        | Cập nhật bảo mật thường xuyên từ nhà cung cấp; tích hợp các tính năng bảo mật              |
| Khả năng mở rộng          | Rất tốt thông qua module/plugin từ cộng đồng và khả năng tự phát triển                                      | Khả năng mở rộng phụ thuộc vào kiến trúc và module/plugin do nhà cung cấp cung cấp         |
| Tích hợp hệ sinh thái     | Tích hợp rộng rãi với nhiều phần mềm và công nghệ nhờ cộng đồng lớn                                         | Tích hợp sâu với hệ sinh thái của nhà cung cấp                                             |
| Tính ổn định & Độ tin cậy | Đã được kiểm chứng qua thời gian, rất ổn định                                                               | Thường rất ổn định và được hỗ trợ chuyên nghiệp                                            |

## 3. Giao thức và Công nghệ liên quan
### 3.1 Giao thức 
#### 3.1.1 HTTP/HTTPS (cơ chế request/response, status codes).
- HTTP (Hypertext Transfer Protocol) là một giao thức (quy tắc truyền tin) để trao đổi thông tin giữa máy chủ Web và trình duyệt Web. 
- HTTPS là HTTP có thêm mã hóa và xác thực. Sự khác biệt duy nhất giữa hai giao thức này là HTTPS sử dụng TLS (SSL) để mã hóa các yêu cầu và phản hồi HTTP thông thường, cũng như ký điện tử vào các yêu cầu và phản hồi đó. Do đó, HTTPS an toàn hơn nhiều so với HTTP.
-![images](./images/http-1.png)
- Cơ chế request/response
	* Request 
	-  là một thông điệp được gửi bởi một máy khách (client) đến một máy chủ (server), yêu cầu một tài nguyên cụ thể. Nó bao gồm một dòng yêu cầu (request line), các tiêu đề (headers) và tùy chọn là một phần thân (body). Một HTTP client gửi một HTTP request đến server dưới dạng một thông điệp yêu cầu.
	- ![images](./images/cau-truc-HTTP-Request.jpg)
	- Các thành phần của một yêu cầu HTTP gồm:
		* Dòng yêu cầu (Request-line): <Phương thức> <URI yêu cầu> <Phiên bản HTTP>
		* Các trường tiêu đề (header) (General|Request|Entity): Theo sau là dấu CRLF .
		* Một dòng trống: (Tức là một dòng không có gì đứng trước CRLF) báo hiệu kết thúc các trường tiêu đề.
		* Phần thân thông điệp (message-body): Tùy chọn
	- Request-Line bao gồm 3 thông tin đó là:
		* Method: là phương thức mà HTTP Request này sử dụng, chỉ định hành động sẽ được thực hiện trên tài nguyên được xác định bởi URI yêu cầu đã cho. Phương thức này phân biệt chữ hoa chữ thường và luôn phải được viết bằng chữ hoa. Bảng sau liệt kê tất cả các phương thức được hỗ trợ trong HTTP/1.1:
			| Phương thức | Mô tả                                                                                                                                                                                                           |
			| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
			| GET         | Phương thức GET được sử dụng để truy xuất thông tin từ máy chủ đã cho bằng cách sử dụng một URI đã cho. Các yêu cầu sử dụng GET chỉ nên truy xuất dữ liệu và không nên có bất kỳ tác động nào khác đến dữ liệu. |
			| HEAD        | Tương tự như GET, nhưng nó chỉ truyền dòng trạng thái và phần tiêu đề.                                                                                                                                          |
			| POST        | Một yêu cầu POST được sử dụng để gửi dữ liệu đến máy chủ, ví dụ: thông tin khách hàng, tải tệp lên, v.v. bằng cách sử dụng các biểu mẫu HTML.                                                                   |
			| PUT         | Thay thế tất cả các biểu diễn hiện tại của tài nguyên đích bằng nội dung đã tải lên.                                                                                                                            |
			| DELETE      | Xóa tất cả các biểu diễn hiện tại của tài nguyên đích được chỉ định bởi URI.                                                                                                                                    |
			| CONNECT     | Thiết lập một đường hầm đến máy chủ được xác định bởi một URI đã cho.                                                                                                                                           |
			| OPTIONS     | Mô tả các tùy chọn giao tiếp cho tài nguyên đích.                                                                                                                                                               |
			| TRACE       | Thực hiện một kiểm tra vòng lặp thông báo dọc theo đường dẫn đến tài nguyên đích.                                                                                                                               |                                                                                                                                                                                       |
		* URI(Uniform Resource Identifier): là địa chỉ định danh của tài nguyên yêu cầu sẽ được áp dụng. 
			| Method            | Description                                                                                                                                                                                                                                                  |
			| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
			| Asterisk (*) form | Được sử dụng khi HTTP request không áp dụng cho một tài nguyên cụ thể mà cho server nói chung. Chỉ dùng với các phương thức như `OPTIONS`.  <br> Ví dụ: `OPTIONS * HTTP/1.1`                                                                                 |
			| Absolute form     | Dùng khi HTTP request được gửi đến một proxy. Proxy sẽ chuyển tiếp request hoặc phản hồi từ cache.  <br> Ví dụ: `GET https://www.example.com/tailwind_css/index.htm HTTP/1.1`                                                                                |
			| Origin form       | Dạng phổ biến nhất, dùng khi client gửi request trực tiếp đến origin server.  <br> Ví dụ:  <br> `GET /tailwind_css/index.htm HTTP/1.1` <br> `Host: www.example.com` <br> Lưu ý: Đường dẫn tuyệt đối không được để trống; nếu không có thì phải dùng `/`. |
			| Authority form    | Chỉ dùng với phương thức `CONNECT`, thường trong kết nối qua proxy đến máy chủ khác.  <br> Ví dụ: `CONNECT www.example.com:443 HTTP/1.1`                                                                                                                     |

		* HTTP version: là phiên bản HTTP đang sử dụng.
	- Tiếp theo là các trường request-header, cho phép client gửi thêm các thông tin bổ sung về thông điệp HTTP request và về chính client. Một số trường thông dụng như:
		* Accept: loại nội dung có thể nhận được từ thông điệp response. Ví dụ: text/plain, text/html…
		* Accept-Encoding: các kiểu nén được chấp nhận. Ví dụ: gzip, deflate, xz, exi…
		* Connection: tùy chọn điều khiển cho kết nối hiện thời. Ví dụ: keep-alive, Upgrade…
		* Cookie: thông tin HTTP Cookie từ server.
		* User-Agent: thông tin về user agent của người dùng.
	- Ví dụ 1 HTTP Request : HTTP Request nhằm lấy trang hello.htm từ máy chủ web đang chạy trên example.com:
		```
		GET /hello.htm HTTP/1.1
		User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
		Host: www.example.com
		Accept-Language: en-us
		Accept-Encoding: gzip, deflate
		Connection: Keep-Alive
		```
			* GET: Đây là phương thức HTTP, chỉ định hành động mà máy khách muốn thực hiện (trong trường hợp này là lấy dữ liệu).
			* /hello.htm: Đây là URI yêu cầu, xác định tài nguyên cụ thể mà máy khách muốn truy cập trên máy chủ.
			* HTTP/1.1: Đây là phiên bản giao thức HTTP mà máy khách đang sử dụng.
			* User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT): Đây là một tiêu đề yêu cầu, cung cấp thông tin về trình duyệt (tác nhân người dùng) đang gửi yêu cầu.
			* Host: www.example.com: Đây là một tiêu đề yêu cầu quan trọng, chỉ định tên miền của máy chủ mà máy khách đang muốn kết nối. Điều này đặc biệt quan trọng khi một máy chủ duy nhất phục vụ nhiều trang web.
			* Accept-Language: en-us: Đây là một tiêu đề yêu cầu, cho biết ngôn ngữ mà máy khách ưu tiên (trong trường hợp này là tiếng Anh của Mỹ).
			* Accept-Encoding: gzip, deflate: Đây là một tiêu đề yêu cầu, cho biết các phương pháp nén mà máy khách có thể xử lý. Máy chủ có thể sử dụng một trong các phương pháp này để nén phản hồi, giúp giảm kích thước dữ liệu truyền đi.
			* Connection: Keep-Alive: Đây là một tiêu đề yêu cầu, gợi ý cho máy chủ duy trì kết nối TCP sau khi gửi phản hồi đầu tiên, cho phép các yêu cầu tiếp theo có thể được gửi qua cùng một kết nối, giảm độ trễ.
	* Response 
	- là phản hồi mà máy chủ đã xử lý dữ liệu được gửi từ máy khách và trả lại cho máy khách. Khi bạn gửi yêu cầu đến máy chủ, quá trình xử lý theo phương thức được thực hiện trên máy chủ và kết quả xử lý sẽ được trả về.
	- ![images](./images/HTTP_ResponseMessageExample.png)
	- Các thành phần của 1 HTTP Response: 
		* Dòng trạng thái (Status-line): `<Phiên bản HTTP> <Mã trạng thái> <Mô tả trạng thái>`
		* Không hoặc nhiều trường tiêu đề (header) (General|Response|Entity)
		* Một dòng trống: (Tức là một dòng không có gì đứng trước CRLF) báo hiệu kết thúc các trường tiêu đề.
		* Phần thân thông điệp (message-body): Tùy chọn. 
	- Status-Line: Một dòng trạng thái bao gồm phiên bản giao thức, theo sau là một mã trạng thái số và cụm từ mô tả trạng thái tương ứng. Các thành phần được phân tách bằng ký tự khoảng trắng.
		* Phiên bản HTTP: Máy chủ hỗ trợ phiên bản HTTP 1.1 sẽ trả về thông tin phiên bản sau:`HTTP-Version = HTTP/1.1`
		* Mã trạng thái (Status Code):  Mã trạng thái là một số nguyên có 3 chữ số, trong đó chữ số đầu tiên của Mã trạng thái xác định lớp phản hồi và hai chữ số cuối không có vai trò phân loại. Có 5 giá trị cho chữ số đầu tiên:
			| Mã trạng thái | Mô tả                                                                         |
			| ------------- | ----------------------------------------------------------------------------- |
			| 1xx           | Thông tin: Yêu cầu đã được nhận và quá trình đang tiếp tục.                   |
			| 2xx           | Thành công: Hành động đã được nhận, hiểu và chấp nhận thành công.             |
			| 3xx           | Chuyển hướng: Cần thực hiện hành động tiếp theo để hoàn thành yêu cầu.        |
			| 4xx           | Lỗi máy khách: Yêu cầu chứa cú pháp không chính xác hoặc không thể thực hiện. |
			| 5xx           | Lỗi máy chủ: Máy chủ không thể thực hiện một yêu cầu có vẻ hợp lệ.            |
	- Response Header Fields Các trường tiêu đề phản hồi: Các trường tiêu đề phản hồi cho phép máy chủ truyền thêm thông tin về phản hồi mà không thể đặt trong Dòng trạng thái. Các trường tiêu đề này cung cấp thông tin về máy chủ và về quyền truy cập tiếp theo vào tài nguyên được xác định bởi URI yêu cầu.
		* Accept-Ranges
		* Age
		* ETag
		* Location
		* Proxy-Authenticate
		* Retry-After
		* Server
		* Vary
		* WWW-Authenticate
	- Ví dụ 1 HTTP Respone: HTTP Respone cho yêu cầu lấy trang hello.htm từ máy chủ web đang chạy trên example.com:
		```
		HTTP/1.1 200 OK
		Date: Mon, 27 Jul 2009 12:28:53 GMT
		Server: Apache/2.2.14 (Win32)
		Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
		Content-Length: 88
		Content-Type: text/html
		Connection: Closed
		```
			* HTTP/1.1: Phiên bản giao thức HTTP mà máy chủ đang sử dụng.
			* 200 OK: Mã trạng thái HTTP cho biết yêu cầu đã thành công. 200 là mã trạng thái thành công và OK là cụm từ mô tả trạng thái tương ứng.
			* Date: Mon, 27 Jul 2009 12:28:53 GMT: Tiêu đề phản hồi Date chỉ ra ngày và giờ (theo giờ GMT) mà phản hồi được tạo ra.
			* Server: Apache/2.2.14 (Win32): Tiêu đề phản hồi Server cung cấp thông tin về phần mềm máy chủ web đang được sử dụng (trong trường hợp này là Apache phiên bản 2.2.14 trên Windows).
			* Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT: Tiêu đề phản hồi Last-Modified chỉ ra ngày và giờ sửa đổi cuối cùng của tài nguyên được yêu cầu.
			* Content-Length: 88: Tiêu đề phản hồi Content-Length chỉ định kích thước (tính bằng byte) của phần thân thông điệp (trong trường hợp này là 88 byte).
			* Content-Type: text/html: Tiêu đề phản hồi Content-Type chỉ định kiểu MIME của dữ liệu trong phần thân thông điệp (trong trường hợp này là văn bản HTML).
			* Connection: Closed: Tiêu đề phản hồi Connection cho biết kết nối TCP sẽ bị đóng sau khi truyền xong phản hồi này.
- Bảng các Status Code 

* 1xx - Informational

| Mã  | Tên                 | Mô tả                                                                        |
| --- | ------------------- | ---------------------------------------------------------------------------- |
| 100 | Continue            | Máy chủ đã nhận được phần đầu yêu cầu, client nên tiếp tục gửi phần còn lại. |
| 101 | Switching Protocols | Máy chủ đồng ý chuyển giao thức như yêu cầu.                                 |
| 102 | Processing          | Máy chủ đã nhận yêu cầu nhưng chưa hoàn thành xử lý.                         |
| 103 | Early Hints         | Cung cấp thông tin trước khi phản hồi chính được gửi.                        |

---

* 2xx - Success

| Mã  | Tên                           | Mô tả                                             |
| --- | ----------------------------- | ------------------------------------------------- |
| 200 | OK                            | Yêu cầu thành công và phản hồi theo yêu cầu.      |
| 201 | Created                       | Yêu cầu thành công và tài nguyên mới đã được tạo. |
| 202 | Accepted                      | Yêu cầu đã được chấp nhận nhưng chưa được xử lý.  |
| 203 | Non-Authoritative Information | Phản hồi không đến từ nguồn gốc.                  |
| 204 | No Content                    | Thành công, không có nội dung trả về.             |
| 205 | Reset Content                 | Yêu cầu client reset view.                        |
| 206 | Partial Content               | Trả về một phần tài nguyên.                       |
| 207 | Multi-Status                  | Trạng thái đa phần (WebDAV).                      |
| 208 | Already Reported              | Đã được báo cáo trước đó.                         |
| 226 | IM Used                       | Thành công sau khi áp dụng các bản sửa đổi.       |
---

* 3xx - Redirection

| Mã  | Tên                | Mô tả                                           |
| --- | ------------------ | ----------------------------------------------- |
| 300 | Multiple Choices   | Nhiều phản hồi khả dĩ.                          |
| 301 | Moved Permanently  | Tài nguyên chuyển vĩnh viễn.                    |
| 302 | Found              | Tạm thời chuyển hướng.                          |
| 303 | See Other          | Chuyển hướng bằng GET.                          |
| 304 | Not Modified       | Không có thay đổi.                              |
| 305 | Use Proxy          | Dùng proxy (deprecated).                        |
| 306 | Switch Proxy       | Không sử dụng nữa.                              |
| 307 | Temporary Redirect | Tạm thời chuyển hướng, giữ nguyên phương thức.  |
| 308 | Permanent Redirect | Chuyển hướng vĩnh viễn, giữ nguyên phương thức. |
---

* 4xx - Client Error

| Mã  | Tên                             | Mô tả                               |
| --- | ------------------------------- | ----------------------------------- |
| 400 | Bad Request                     | Yêu cầu sai cú pháp.                |
| 401 | Unauthorized                    | Cần xác thực.                       |
| 402 | Payment Required                | Dành cho thanh toán (chưa sử dụng). |
| 403 | Forbidden                       | Không có quyền truy cập.            |
| 404 | Not Found                       | Không tìm thấy tài nguyên.          |
| 405 | Method Not Allowed              | Phương thức không được hỗ trợ.      |
| 406 | Not Acceptable                  | Không có định dạng nào phù hợp.     |
| 407 | Proxy Authentication Required   | Cần xác thực proxy.                 |
| 408 | Request Timeout                 | Hết thời gian yêu cầu.              |
| 409 | Conflict                        | Xung đột trạng thái tài nguyên.     |
| 410 | Gone                            | Tài nguyên đã bị xóa.               |
| 411 | Length Required                 | Thiếu trường Content-Length.        |
| 412 | Precondition Failed             | Điều kiện không thỏa mãn.           |
| 413 | Payload Too Large               | Yêu cầu quá lớn.                    |
| 414 | URI Too Long                    | URI quá dài.                        |
| 415 | Unsupported Media Type          | Loại phương tiện không được hỗ trợ. |
| 416 | Range Not Satisfiable           | Phạm vi không thỏa mãn.             |
| 417 | Expectation Failed              | Không đáp ứng được Expect.          |
| 418 | I'm a teapot                    | Mã đùa từ RFC 2324.                 |
| 421 | Misdirected Request             | Gửi sai máy chủ.                    |
| 422 | Unprocessable Entity            | Không xử lý được (WebDAV).          |
| 423 | Locked                          | Tài nguyên bị khóa.                 |
| 424 | Failed Dependency               | Phụ thuộc bị lỗi.                   |
| 425 | Too Early                       | Yêu cầu quá sớm.                    |
| 426 | Upgrade Required                | Cần nâng cấp giao thức.             |
| 428 | Precondition Required           | Yêu cầu cần điều kiện.              |
| 429 | Too Many Requests               | Quá nhiều yêu cầu.                  |
| 431 | Request Header Fields Too Large | Header quá lớn.                     |
| 451 | Unavailable For Legal Reasons   | Bị chặn vì lý do pháp lý.           |
---

* 5xx - Server Error

| Mã  | Tên                             | Mô tả                            |
| --- | ------------------------------- | -------------------------------- |
| 500 | Internal Server Error           | Lỗi không xác định từ máy chủ.   |
| 501 | Not Implemented                 | Chưa được hỗ trợ.                |
| 502 | Bad Gateway                     | Gateway lỗi.                     |
| 503 | Service Unavailable             | Dịch vụ tạm thời không khả dụng. |
| 504 | Gateway Timeout                 | Gateway hết thời gian.           |
| 505 | HTTP Version Not Supported      | Phiên bản HTTP không hỗ trợ.     |
| 506 | Variant Also Negotiates         | Lỗi do server cấu hình sai.      |
| 507 | Insufficient Storage            | Không đủ dung lượng lưu trữ.     |
| 508 | Loop Detected                   | Phát hiện vòng lặp (WebDAV).     |
| 510 | Not Extended                    | Cần mở rộng thêm yêu cầu.        |
| 511 | Network Authentication Required | Yêu cầu xác thực mạng.           |

#### 3.1.2 SSL/TLS (bảo mật, chứng chỉ số).
- SSL（Secure Sockets Layer）/TLS（Transport Layer Security）là kỹ thuật mã hóa truyền tin trên internet. Sử dụng SSL/TLS , bằng việc mã hóa data truyền tin giữa máy tính và server thì có thể phòng tránh bên thứ ba nghe trộm hoặc giả mạo data.
- SSL/TLS sử dụng các chứng chỉ để thiết lập một liên kết được mã hóa giữa máy chủ và máy khách. Điều này cho phép các thông tin nhạy cảm như chi tiết thẻ tín dụng được truyền một cách an toàn qua internet.
- Chứng chỉ Transport Layer Security (TLS) - thường được biết đến là SSL hoặc chứng chỉ số - là nền tảng của một internet an toàn. Chứng chỉ TLS/SSL bảo vệ các kết nối internet bằng cách mã hóa dữ liệu được gửi giữa trình duyệt của bạn, trang web bạn đang truy cập và máy chủ của trang web. Chúng đảm bảo rằng dữ liệu được truyền riêng tư, không bị sửa đổi, mất mát hoặc đánh cắp.
- Chứng chỉ chứa một khóa công khai để xác thực danh tính của trang web và cho phép truyền dữ liệu đã mã hóa thông qua mật mã bất đối xứng, hay còn gọi là mật mã khóa công khai. Khóa riêng tư tương ứng được giữ bí mật trên máy chủ.
- Cơ chế hoạt động: Chứng chỉ SSL/TLS xác thực danh tính và kích hoạt các kết nối được mã hóa thông qua quá trình SSL/TLS handshake (bắt tay SSL/TLS):
	* Máy khách yêu cầu truy cập vào một tài nguyên được bảo vệ, chẳng hạn như trang đăng nhập.
	* Máy chủ phản hồi bằng cách gửi chứng chỉ SSL của nó, bao gồm cả khóa công khai.
	* Máy khách xác minh rằng chứng chỉ hợp lệ và đáng tin cậy. Điều này đảm bảo máy chủ là xác thực.
	* Máy khách tạo ra một khóa phiên đối xứng và mã hóa nó bằng khóa công khai của máy chủ. Điều này truyền khóa phiên một cách an toàn đến máy chủ.
	* Máy chủ giải mã khóa phiên bằng khóa riêng tư của nó.
	* Cả hai bên sử dụng khóa phiên đối xứng để mã hóa và giải mã tất cả dữ liệu được truyền.
	- Quá trình bắt tay này cho phép hai bên thương lượng một kênh được mã hóa mà không cần chia sẻ thông tin nhạy cảm qua các kênh không an toàn. Phiên được mã hóa bảo vệ dữ liệu trong quá trình truyền giữa máy khách và máy chủ.
- ![images](./images/ssl-tls-client-authentication.jpg)
- Các loại chứng chỉ SSL/TLS :
	- Theo mức độ xác thực:
		* EV (Extended Validation): Mức xác thực cao nhất, kiểm tra nghiêm ngặt tổ chức, hiển thị thông tin công ty trên trình duyệt, tin cậy cao cho giao dịch nhạy cảm.
		* OV (Organization Validated): Mức xác thực trung bình, cần chứng minh quyền sở hữu domain và thông tin công ty, phù hợp cho doanh nghiệp xây dựng lòng tin.
		* DV (Domain Validated): Mức xác thực thấp nhất, chỉ cần xác minh quyền sở hữu domain qua email/điện thoại, chi phí thấp, phù hợp cho website thông tin.
	- Theo loại domain hỗ trợ:
		* Single Domain: Chỉ bảo vệ một domain hoặc subdomain duy nhất.
		* Wildcard: Bảo vệ một domain và tất cả các subdomain của nó.
		* Multi-Domain: Bảo vệ nhiều domain khác nhau thuộc cùng một chủ sở hữu.
		
#### 3.1.3 WebSocket, HTTP/2, QUIC (giao thức hiện đại).
- WebSocket 
	- là một giao thức truyền thông máy tính (computer communication protocol), cung cấp các kênh liên lạc dạng full-duplex (song công) qua một kết nối TCP.
	- hỗ trợ giao tiếp hai chiều giữa client và server bằng cách sử dụng một TCP socket để tạo một kết nối hiệu quả và ít tốn kém.
	- WebSocket mới trong HTML5 là một kỹ thuật Ajax ngược. Sockets cho phép các kênh giao tiếp song song hai chiều và hiện được hỗ trợ bởi nhiều trình duyệt (Firefox, Google Chrome và Safari). Các kết nối được mở thông qua các yêu cầu HTTP (HTTP request) được gọi là các ràng buộc Sockets với các tiêu đề đặc biệt. 
	- Kết nối được duy trì để bạn có thể đọc và ghi dữ liệu bằng JavaScript như thể bạn đang sử dụng các socket TCP thuần túy. Dữ liệu được gửi qua giao thức HTTP (thường được sử dụng trong các kỹ thuật Ajax) chứa rất nhiều dữ liệu không cần thiết trong tiêu đề. 
	- ![images](./images/websocket-la-gi-2.png)
	- WebSocket hoạt động qua ba bước chính:
		1. Thiết lập kết nối WebSocket
			* Khởi tạo yêu cầu: Máy khách (client) gửi một yêu cầu HTTP đến máy chủ, trong đó có tiêu đề Upgrade để yêu cầu chuyển đổi từ giao thức HTTP sang WebSocket.
			* Phản hồi từ máy chủ: Nếu máy chủ hỗ trợ WebSocket, nó sẽ phản hồi với một thông báo xác nhận việc nâng cấp kết nối, cho phép thiết lập một kết nối WebSocket.
		2. Truyền dữ liệu qua WebSockets
			* Giao tiếp hai chiều: Sau khi kết nối được thiết lập, cả máy khách và máy chủ có thể gửi và nhận dữ liệu bất kỳ lúc nào mà không cần thực hiện yêu cầu HTTP mới.
			* Dữ liệu dạng khung: Dữ liệu được truyền qua WebSocket được đóng gói trong các frames, có thể chứa dữ liệu văn bản hoặc nhị phân.
		3. Đóng kết nối WebSocket: Kết nối WebSocket được duy trì cho đến khi một trong hai bên quyết định đóng nó. Khi kết nối bị đóng, quá trình truyền dữ liệu kết thúc.
	- Ưu điểm
		- WebSockets cung cấp khả năng giao tiếp hai chiều mạnh mẽ, có độ trễ thấp và dễ xử lý lỗi. Không cần phải có nhiều kết nối như phương pháp Comet long-polling và cũng không có những nhược điểm như Comet streaming.
		- API cũng rất dễ sử dụng trực tiếp mà không cần bất kỳ các tầng bổ sung nào, so với Comet, thường đòi hỏi một thư viện tốt để xử lý kết nối lại, thời gian chờ timeout, các Ajax request (yêu cầu Ajax), các tin báo nhận và các dạng truyền tải tùy chọn khác nhau (Ajax long-polling và jsonp polling).
	- Nhược điểm
		- Nó là một đặc tả mới của HTML5, nên nó vẫn chưa được tất cả các trình duyệt hỗ trợ.
		- Không có phạm vi yêu cầu nào. Do WebSocket là một TCP socket chứ không phải là HTTP request, nên không dễ sử dụng các dịch vụ có phạm vi-yêu cầu, như SessionInViewFilter của Hibernate. Hibernate là một framework kinh điển cung cấp một bộ lọc xung quanh một HTTP request. Khi bắt đầu một request, nó sẽ thiết lập một contest (chứa các transaction và liên kết JDBC) được ràng buộc với luồng request. Khi request đó kết thúc, bộ lọc hủy bỏ contest này.
- HTTP/2 
	- HTTP/2 là phiên bản chính thức tiếp theo của giao thức HTTP, nhằm cải thiện tốc độ tải trang và hiệu suất khi duyệt web.
	- ![images](./images/HTTP-2.jpg)
	- Các đặc điểm của HTTP/2
		- Header compression: HTTP/2 nén các thông tin ở phần đầu của dữ liệu và làm giảm kích thước của chúng, giúp trang web tải nhanh hơn và quá trình trao đổi thông tin giữa máy chủ web và người dùng diễn ra nhanh hơn.
		- ![images](./images/http-7.webp) 
		- Multiplexing : Nó giảm thời gian chờ bằng cách cho phép gửi và nhận nhiều yêu cầu cùng một lúc.
		- ![images](./images/http-4.webp) 
		- Stream prioritization: HTTP/2 có một đặc điểm giúp máy chủ phân chia tài nguyên mạng dựa trên nhu cầu của người dùng. Quá trình này cải thiện trải nghiệm người dùng bằng cách hiển thị những phần quan trọng nhất của trang web nhanh nhất có thể.
		- ![images](./images/http-5.webp) 
		- Binary framing layer: Giao thức HTTP/2 sử dụng dữ liệu dạng số (0 và 1) thay vì các lệnh dạng chữ. Một giao thức dùng dữ liệu dạng số thường hiệu quả hơn và ít gây ra lỗi hơn. Nó giúp giảm thời gian chờ và bảo vệ tốt hơn trước các nguy cơ bảo mật so với cách dùng dữ liệu dạng chữ.
		- ![images](./images/http-6.jpeg) 
		- Server push: Giao thức HTTP/2 cho phép máy chủ tự động gửi các tài nguyên đến người dùng mà không cần người dùng phải yêu cầu trước. Điều này giúp tăng hiệu quả và giảm thời gian tải trang.
		- ![images](./images/http-3.png) 
			* Ví dụ: Ngay khi Client request index.html ngay lập tức, Server sẽ trả về index.html và cả style.css nữa, điều này có thể thực hiện do cơ chế single connection, single origin được nhắc tới ở trên. Và trình duyệt có thể render trang web ngay lập tức thay vì chờ đợi request thứ 2 cho style.css dược phản hồi.
		- Increased security: HTTP/2 được hỗ trợ thông qua các kết nối đã được mã hóa.
	- Ưu điểm: 
		* Tăng tốc độ: Truyền tải song song (multiplexing), nén header, server push giúp tải trang nhanh hơn đáng kể.
		* Bảo mật hơn: Thường đi kèm HTTPS, tăng cường mã hóa.
		* Hiệu quả hơn: Giảm nhu cầu các kỹ thuật tối ưu hóa phức tạp như image sprites, domain sharding.
	- Nhược điểm :
		* Phức tạp hơn: Triển khai và gỡ lỗi khó hơn.
		* Tốn tài nguyên hơn: Máy chủ có thể cần nhiều CPU, RAM hơn.
		* Vấn đề tương thích: Trình duyệt cũ có thể không hỗ trợ.
- QUIC 
	- QUIC (Quick UDP Internet Connections) là một giao thức truyền tải mạng được phát triển bởi Google nhằm cải thiện hiệu suất của các ứng dụng sử dụng kết nối Internet, đặc biệt là các ứng dụng web và truyền phát video. QUIC được thiết kế để thay thế giao thức TCP, cung cấp các lợi ích về tốc độ và hiệu suất mà TCP không thể đáp ứng đầy đủ trong môi trường Internet hiện đại.
	- Các đặc điểm chính của QUIC
		* Sử dụng UDP: QUIC hoạt động trên giao thức UDP (User Datagram Protocol), thay vì TCP (Transmission Control Protocol), giúp giảm độ trễ của các kết nối mạng.
		* Giảm độ trễ kết nối: Với QUIC, quá trình thiết lập kết nối diễn ra nhanh hơn, thường chỉ yêu cầu một bước trao đổi dữ liệu duy nhất, thay vì nhiều bước như TCP + TLS.
			- ![images](./images/quic_zerortt.png) 
		* Tích hợp bảo mật: QUIC tích hợp các tính năng của TLS 1.3 (Transport Layer Security) để mã hóa dữ liệu trong suốt quá trình truyền, đảm bảo bảo mật mà không cần thêm một bước thiết lập mã hóa riêng biệt.
		* Khả năng khôi phục nhanh chóng: Khi xảy ra mất gói dữ liệu, QUIC chỉ cần yêu cầu truyền lại các gói bị mất thay vì phải thiết lập lại toàn bộ kết nối như TCP.
		* Tối ưu hóa cho đa luồng: QUIC hỗ trợ truyền dữ liệu đồng thời trên nhiều luồng (streams) mà không gây cản trở nhau khi xảy ra lỗi, cải thiện hiệu suất cho các trang web và ứng dụng phức tạp.
	- QUIC và HTTP/3 : 
		* QUIC là một phần của HTTP/3, phiên bản giao thức HTTP mới nhất. HTTP/3 thay thế giao thức TCP của phiên bản trước đó, HTTP/2, bằng QUIC. Sự kết hợp giữa QUIC và HTTP/3 mang lại nhiều lợi ích cho việc truyền tải dữ liệu trên internet.
		* Sự thay thế của HTTP/3: HTTP/3 thay thế giao thức TCP bằng QUIC để tận dụng những ưu điểm của giao thức mới này như tăng tốc độ và tính bảo mật.
		* Ưu điểm khi sử dụng HTTP/3 với QUIC: Khi sử dụng HTTP/3 với QUIC, việc truyền tải dữ liệu trở nên nhanh chóng và hiệu quả hơn bao giờ hết. Sự kết hợp này giúp tối ưu hóa việc tải nội dung của trang web và giảm thiểu thời gian tải trang.
	- Bên cạnh đó QUIC tồn tạn những hạn chế như: 
		* Sự chấp nhận hạn chế: QUIC vẫn còn tương đối mới và không phải tất cả các hệ thống hoặc tường lửa đều hỗ trợ đầy đủ.
		* Dự phòng TCP: Một số triển khai có thể yêu cầu dự phòng về TCP nếu QUIC không được hỗ trợ, làm tăng thêm sự phức tạp.
		* Không kiểm tra gói tin: Việc mã hóa trong QUIC gây khó khăn cho quản trị viên mạng trong việc kiểm tra hoặc giám sát lưu lượng truy cập, có khả năng ảnh hưởng đến bảo mật và nỗ lực khắc phục sự cố.
		* Sử dụng CPU cao hơn: QUIC có thể yêu cầu nhiều tài nguyên CPU hơn so với TCP do cơ chế mã hóa và kiểm soát tắc nghẽn của nó.
		* Phụ thuộc vào UDP: QUIC dựa trên UDP, một giao thức không kết nối, và có thể dễ bị tấn công DDoS dựa trên UDP.
		* Khả năng tương thích hạn chế: QUIC không tương thích với tất cả các thiết bị mạng và tường lửa, có khả năng yêu cầu người dùng định cấu hình thiết bị của họ.
#### 3.1.4 CGI, FastCGI, WSGI (giao tiếp giữa server và ứng dụng).
- CGI 
	- CGI là viết tắt của Common Gateway Interface, tạm dịch là giao diện cổng chung. CGI cung cấp một phần mềm trung gian giữa các máy chủ với cơ sở dữ liệu và nguồn thông tin bên ngoài. Trong đó máy chủ HTTP và 1 CGI script sẽ chịu trách nhiệm phản hồi yêu cầu từ người dùng.
		* Máy chủ đảm nhận quản lý các kết nối, việc thực hiện truyền dữ liệu đi và các vấn đề liên quan đến yêu cầu từ người dùng.
		* CGI script chịu trách nhiệm xử lý các vấn đề của ứng dụng như truy cập vào dữ liệu và xử lý các tài liệu.
	- Các tính năng của CGI
		* CGI là một tiêu chuẩn được phát triển với định hướng rõ ràng và có rất nhiều sự hỗ trợ.
		* CGI là một công nghệ được kết nối với ngôn ngữ HTML.
		* CGI script thường được viết bằng các ngôn ngữ như C, Perl nhưng cũng có thể là một shell script đơn giản.
		* Nếu tạo một bộ nhớ đệm có tốc độ nhanh, CGI là một trong những phương pháp tối ưu nhất.
		* Cho đến thời điểm hiện tại, CGI vẫn đang rất tương thích với các trình duyệt hiện đại, dù đã phát triển từ những năm 1990.	
	- CGI là một giao thức trao đổi giữa máy chủ web và các ứng dụng cổng (gateway application) như PHP, Python,…
		- ![images](./images/cgi.jpg) 
		- Trong thực tế CGI sẽ hoạt động như sau:
			* Máy trạm gửi yêu cầu đến máy chủ web, máy chủ web nhận yêu cầu và chuyển tiếp cho ứng dụng cổng. CGI sẽ thực thi một câu lệnh tương ứng phù hợp với ứng dụng đó.
			* Các thông tin chi tiết về yêu cầu được ứng dụng truyền qua bằng các biến môi trường, trong khi đó dữ liệu bằng các phương pháp POST hoặc PUT sẽ được truyền qua các cổng nhập tiêu chuẩn. Tức là CGI xử lý dữ liệu của nó song song với dữ liệu chính.
			* Ứng dụng sẽ viết nội dung cần trả lời để máy chủ trả thông tin về cho người yêu cầu.
		- Quá trình này khá đơn giản và hiệu quả. Tuy nhiên, hình thức này dần bộc lộ một số hạn chế như:
			* Một yêu cầu sẽ tạo ra một tiến trình làm việc độc lập. Bộ nhớ và các thông tin không được lưu lại sau mỗi phiên, sẽ được tạo lại sao mỗi phiên.
			* Một tiến trình mới sẽ tiêu tốn rất nhiều tài nguyên của hệ thống. Nếu trong một thời điểm một loạt yêu cầu được sinh ra sẽ làm máy chủ quá tải ngay lập tức.
			* Trong trường hợp máy chủ một nơi, ứng dụng nằm trên một máy tính khác sẽ tạo ra nhiều khó khăn.
	- Ưu điểm
		* Code sẵn có để áp dụng vào phần mềm của bạn mà không phải code lại từ đầu.
		* CGI mạnh mẽ tương thích hầu hết với các ngôn ngữ và bất cứ nền tảng nào, miễn chúng có những đặc điểm kỹ thuật phù hợp.
		* Các tác vụ nâng cao vốn khó trong Java giờ có thể thực hiện dễ dàng hơn với CGI.
	- Nhược điểm
		* CGI rất tốn thời gian để xử lý.
		* Không lưu lại cache sau mỗi lần tải lại trang.
		* Mỗi lần tải lại sẽ tốn thêm thời gian do phải tải lại các chương trình vào bộ nhớ.
- FastCGI
	- là một giao thức nhị phân để kết nối các chương trình tương tác với một máy chủ web. Nó là một biến thể của CGI ra đời trước đó. Mục tiêu chính của FastCGI là giảm phát sinh liên quan đến việc kết nối giữa máy chủ web và các chương trình CGI, cho phép máy chủ xử lý nhiều yêu cầu trang web hơn trong một đơn vị thời gian.
	- Những ưu điểm của FastCGI bao gồm:
		* Hiệu suất: Các tiến trình FastCGI hoạt động liên tục - chúng được tái sử dụng để xử lý nhiều yêu cầu. Điều này giải quyết vấn đề hiệu suất của CGI là phải tạo tiến trình mới cho mỗi yêu cầu.
		* Đơn giản, dễ dàng chuyển đổi từ CGI: Thư viện ứng dụng FastCGI (được mô tả ở trang 9) giúp đơn giản hóa việc chuyển đổi các ứng dụng CGI hiện có. Các ứng dụng được xây dựng bằng thư viện ứng dụng cũng có thể chạy như các chương trình CGI, để tương thích ngược với các máy chủ Web cũ.
		* Độc lập ngôn ngữ: Giống như CGI, các ứng dụng FastCGI có thể được viết bằng bất kỳ ngôn ngữ nào, không chỉ các ngôn ngữ được hỗ trợ bởi API của nhà cung cấp.
		* Cô lập tiến trình: Một ứng dụng FastCGI bị lỗi không thể làm sập hoặc làm hỏng máy chủ chính hoặc các ứng dụng khác. Một ứng dụng FastCGI độc hại không thể đánh cắp bất kỳ bí mật nào (chẳng hạn như khóa phiên cho mã hóa) từ máy chủ Web.
		* Không độc quyền: FastCGI được hỗ trợ trong tất cả các sản phẩm máy chủ của Open Market, và sự hỗ trợ đang được phát triển cho các máy chủ Web khác, bao gồm các máy chủ Apache và NCSA miễn phí, cũng như các máy chủ thương mại từ Microsoft và Netscape.
		* Độc lập kiến trúc: Giao diện FastCGI không bị ràng buộc với một kiến trúc máy chủ cụ thể. Bất kỳ máy chủ Web nào cũng có thể triển khai giao diện FastCGI. Ngoài ra, FastCGI không áp đặt bất kỳ kiến trúc nào lên ứng dụng: các ứng dụng có thể là đơn luồng hoặc đa luồng, bất kể kiến trúc luồng của máy chủ Web.
		* Hỗ trợ điện toán phân tán: FastCGI cung cấp khả năng chạy các ứng dụng từ xa, điều này hữu ích cho việc phân tán tải và quản lý các trang Web bên ngoài.
	- Chức năng FastCGI cung cấp rất giống với chức năng mà CGI cung cấp. 
		- Quá trình xử lý yêu cầu CGI cơ bản diễn ra như sau:
			* Với mỗi yêu cầu, máy chủ tạo một tiến trình mới và tiến trình đó tự khởi tạo.
			* Máy chủ Web truyền thông tin yêu cầu (chẳng hạn như máy chủ từ xa, tên người dùng, tiêu đề HTTP, v.v.) cho chương trình CGI trong các biến môi trường.
			* Máy chủ Web gửi bất kỳ dữ liệu đầu vào nào của máy khách (chẳng hạn như các giá trị trường do người dùng nhập từ biểu mẫu HTML) đến đầu vào chuẩn của chương trình CGI.
			* Chương trình CGI ghi bất kỳ đầu ra nào cần trả về cho máy khách vào đầu ra chuẩn. Thông tin lỗi được ghi vào lỗi chuẩn sẽ được máy chủ Web ghi lại.
			* Khi tiến trình CGI kết thúc, yêu cầu hoàn tất.
		- FastCGI về mặt khái niệm rất giống với CGI, với hai điểm khác biệt chính:
			* Các tiến trình FastCGI hoạt động liên tục: sau khi hoàn thành một yêu cầu, chúng chờ một yêu cầu mới thay vì thoát.
			* Thay vì sử dụng các biến môi trường và pipes của hệ điều hành, FastCGI ghép nhiều thông tin môi trường, đầu vào chuẩn, đầu ra và lỗi qua một kết nối song công toàn phần duy nhất. Điều này cho phép các chương trình FastCGI chạy trên các máy từ xa, sử dụng kết nối TCP giữa máy chủ Web và ứng dụng FastCGI.
		- Quá trình xử lý yêu cầu trong một ứng dụng FastCGI đơn luồng diễn ra như sau:
			* Máy chủ Web tạo các tiến trình ứng dụng FastCGI để xử lý các yêu cầu. Các tiến trình có thể được tạo khi khởi động hoặc tạo theo yêu cầu
			* Chương trình FastCGI tự khởi tạo và chờ một kết nối mới từ máy chủ Web.
			* Khi có yêu cầu từ máy khách, máy chủ Web mở một kết nối đến tiến trình FastCGI. Máy chủ gửi thông tin biến môi trường CGI và đầu vào chuẩn qua kết nối này.
			* Tiến trình FastCGI gửi thông tin đầu ra chuẩn và lỗi trở lại máy chủ qua cùng một kết nối.
			* Khi tiến trình FastCGI đóng kết nối, yêu cầu hoàn tất. Sau đó, tiến trình FastCGI chờ một kết nối khác từ máy chủ Web.
	- Bên cạnh đó FastCGI tồn tại những nhược điểm như :
		* Tăng độ phức tạp trong cấu hình FastCGI có thể phức tạp hơn trong việc cấu hình và quản lý so với CGI, đặc biệt khi thiết lập các nhóm tiến trình và xử lý kết nối.
		* Tiềm ẩn vấn đề về bộ nhớ Mặc dù FastCGI giảm việc tiêu thụ tài nguyên so với CGI, nó vẫn có thể tiêu thụ một lượng bộ nhớ đáng kể nếu không được cấu hình đúng cách hoặc nếu yêu cầu bộ nhớ của ứng dụng cao.
		* Phức tạp trong gỡ lỗi Việc gỡ lỗi các ứng dụng FastCGI có thể khó khăn hơn so với việc gỡ lỗi các ứng dụng CGI do các tiến trình hoạt động liên tục và cần phải hiểu sự tương tác giữa máy chủ web và ứng dụng FastCGI.
- WSGI 
	- WSGI (Web Server Gateway Interface) là một tiêu chuẩn trong Python dùng để định nghĩa giao tiếp giữa máy chủ web và các ứng dụng web.
	- WSGI là một đặc tả kỹ thuật định nghĩa một giao diện tiêu chuẩn giữa các máy chủ web và các ứng dụng hoặc framework web Python (WSGI là một tiêu chuẩn Python được mô tả chi tiết trong [PEP 3333](https://peps.python.org/pep-3333/)). Nó đóng vai trò như một cầu nối, cho phép giao tiếp giữa một máy chủ web (như Nginx hoặc Apache) và các ứng dụng Python, giúp các nhà phát triển xây dựng các ứng dụng web có khả năng mở rộng và hiệu quả.
	- WSGI đóng vai trò then chốt bởi vì nó tiêu chuẩn hóa cách các ứng dụng web giao tiếp với máy chủ, cho phép các nhà phát triển chuyển đổi giữa các máy chủ web và framework khác nhau mà không cần thay đổi mã ứng dụng. Sự linh hoạt này đặc biệt quan trọng trong môi trường sản xuất, nơi các máy chủ khác nhau có thể được sử dụng để xử lý yêu cầu, cân bằng tải và triển khai ứng dụng.
	- Cách WSGI hoạt động:  Hãy hình dung bạn có một ứng dụng web được phát triển bằng Django hoặc Flask và nó được triển khai trên một máy chủ web (ví dụ: Apache, Nginx). Máy chủ web này nhận các yêu cầu từ nhiều người dùng khác nhau. Ngoài việc phục vụ các tệp tĩnh và thực hiện caching, máy chủ web còn có thể được sử dụng như một bộ cân bằng tải để xử lý nhiều ứng dụng khi cần mở rộng.Vấn đề đặt ra là: Làm thế nào máy chủ web có thể tương tác với ứng dụng Python? Để giải quyết vấn đề này, cần có một trung gian để thực hiện giao tiếp giữa máy chủ web và ứng dụng Python. Tiêu chuẩn cho việc giao tiếp này chính là WSGI (Web Server Gateway Interface).
		- Quy trình hoạt động của WSGI:
			- ![images](./images/wsgi.webp) 
			* Máy chủ web nhận yêu cầu: Khi một người dùng gửi yêu cầu đến ứng dụng web, máy chủ web sẽ là nơi đầu tiên tiếp nhận yêu cầu này.
			* Máy chủ web chuyển yêu cầu đến WSGI Container: Thay vì trực tiếp giao tiếp với ứng dụng Python, máy chủ web sẽ gửi yêu cầu (hoặc giao tiếp) với một WSGI container.
			* WSGI Container làm trung gian: WSGI container là một chương trình (ví dụ: Gunicorn, uWSGI) được cài đặt trên máy chủ. Nó đóng vai trò là cầu nối giữa máy chủ web và ứng dụng Python. WSGI container tuân theo tiêu chuẩn PEP 3333, đảm bảo khả năng tương thích.
			* WSGI Container gọi ứng dụng Python: Ứng dụng Python cung cấp một đối tượng "callable" (có thể gọi được), chứa các chức năng để xử lý yêu cầu. WSGI container sẽ gọi đối tượng này, truyền các thông tin cần thiết về yêu cầu (như các biến môi trường).
			* Ứng dụng Python xử lý yêu cầu: Ứng dụng Python nhận thông tin từ WSGI container, thực hiện các xử lý logic cần thiết để đáp ứng yêu cầu.
			* Ứng dụng Python trả về phản hồi cho WSGI Container: Sau khi xử lý, ứng dụng Python trả về một đối tượng chứa dữ liệu phản hồi (ví dụ: nội dung HTML, dữ liệu JSON).
			* WSGI Container chuyển phản hồi đến máy chủ web: WSGI container nhận phản hồi từ ứng dụng Python và định dạng nó theo cách mà máy chủ web có thể hiểu được. Sau đó, nó chuyển phản hồi này trở lại máy chủ web.
			* Máy chủ web gửi phản hồi cho người dùng: Cuối cùng, máy chủ web nhận được phản hồi từ WSGI container và gửi nó trở lại trình duyệt web của người dùng.
	- Ưu điểm
		* WSGI cung cấp tiêu chuẩn thống nhất để giao tiếp giữa máy chủ web và ứng dụng Python
		* Có thể dễ dàng chuyển đổi giữa các máy chủ web mà không cần thay đổi logic ứng dụng
		* Tích hợp middleware để thêm nhiều tính năng mở rộng như logging, caching, xác thực,…mà không cần thay đổi ứng dụng
		* Có tính tương thích rộng với các framework Python như Flask, Django,…
		* Không phụ thuộc vào bất cứ Framework nào
		* Mang lại hiệu suất cao khi kết hợp với các WSGI Server như Gunicorn hoặc uWSGI
		* Cộng đồng hỗ trợ rộng lớn.
	- Hạn chế
		* WSGI không hỗ trợ các yêu cầu bất đồng bộ
		* Cần cấu hình phức tạp để triển khai ứng dụng WSGI với hiệu suất cao
		* Không phù hợp với các ứng dụng yêu cầu xử lý I/O cao
		* Phụ thuộc vào middleware để mở rộng các tính năng
		* Lỗi thời trong các hệ thống hiện đại sử dụng các giao thức như HTTP/2
### 3.2 Các công nghệ liên quan 
#### 3.2.1 Các mô hình xử lý yêu cầu: 
- Prefork và Worker trong Apache 
	- Trong quá trình xử lý Multitasking thường có hai kỹ thuật chính đó là dựa vào process và thread, hay còn gọi là multiprocessing và multithreading.
		* Multiprocessing : tạo ra nhiều process và cùng xử lý một cách riêng lẽ.
		* Multithreading : tạo ra nhiều thread trong một process để xử lý, dùng chung bộ nhớ với các thread khác.
	- Multi-Processing Modules (MPMs) là module cho phép apache xử lý theo kiểu multitasking, mà mỗi tasking ở đây có thể hiểu là những requests mà apache phải xử lý. 
	- Có hai loại MPM (Multi-Processing Modules) chính mà Apache sử dụng là: 
		* Prefork MPM 
		* Worker MPM 
	- Prefork MPM 
		* Là một trong những MPM lâu đời và ổn định của Apache.
		* Hoạt động bằng cách tạo một tiến trình riêng biệt cho mỗi kết nối.
		* Khởi tạo một số lượng tiến trình ban đầu và tạo thêm khi có yêu cầu mới.
		* Ưu tiên sự ổn định vì lỗi ở một tiến trình không ảnh hưởng đến các tiến trình khác.
		* Mục đích chính là cung cấp bảo mật và ổn định bằng cách xử lý mỗi kết nối trong một môi trường cách ly.
		* Có thể tốn kém hơn về tiêu thụ tài nguyên (CPU, bộ nhớ) so với các MPM khác.
		* Vẫn là một lựa chọn hợp lệ, đặc biệt trong các hệ thống cũ hoặc khi bảo mật là ưu tiên hàng đầu.
			- ![images](./images/mpm_prefork1.webp)
		* Ưu điểm 
			- Bảo mật cao: Tiến trình độc lập, lỗi không lan.
			- Ổn định: Sập tiến trình không ảnh hưởng server.
			- Dễ cấu hình: Thiết lập đơn giản.
			- Tương thích rộng: Hỗ trợ nhiều OS và phần cứng cũ.
			- Dễ gỡ lỗi: Theo dõi lỗi dễ dàng do tiến trình riêng biệt.
		* Nhược điểm lớn nhất chính là việc tạo ra quá nhiều các process sẽ chiếm dụng lượng RAM lớn.
	- Worker MPM 
		* Là một module của Apache sử dụng mô hình đa tiến trình và đa luồng.
		* Có khả năng xử lý nhiều kết nối đồng thời hơn trong khi tiêu thụ ít tài nguyên hơn so với Prefork MPM. Đây là một lợi thế lớn cho các trang web và ứng dụng có lưu lượng truy cập cao.
		* Sử dụng tài nguyên hệ thống hiệu quả hơn bằng cách cho phép mỗi bộ xử lý chạy nhiều luồng.
		* Mục đích chính là cải thiện hiệu suất bằng cách tối ưu hóa tài nguyên máy chủ.
		* Mỗi luồng có thể xử lý một yêu cầu độc lập, cho phép máy chủ phục vụ nhiều người dùng đồng thời hơn.
		* Mô hình này giúp tăng hiệu quả tổng thể của máy chủ, đặc biệt là giảm mức sử dụng bộ nhớ.
		* Là một giải pháp lý tưởng cho các ứng dụng web phục vụ nội dung động và sử dụng kết nối cơ sở dữ liệu.
			- ![images](./images/mpm_worker1.webp)
		* Ưu điểm 
			- Nhiều kết nối đồng thời: Xử lý nhiều người dùng hơn.
			- Ít tài nguyên: Tiết kiệm RAM.
			- Hiệu suất cao: Phản hồi nhanh hơn.
			- Tối ưu nội dung động: Phù hợp web phức tạp.
			- Khởi động/dừng nhanh: Tiết kiệm thời gian.
		* Nhược điểm 
			- Nếu một thread có vấn đề hoặc là bị crash thì các thread khác trong process cũng có thể bị crash và process sẽ bị crash theo.
			- Các thread có thể sử dụng chung vùng nhớ cho nên có thể gây ảnh hưởng lẫn nhau
	- So sánh Prefork/Worker 
		| Tiêu chí                        | MPM Prefork                                                       | MPM Worker                                                            |
		| ------------------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------- |
		| Kiểu xử lý                  | Đa tiến trình (mỗi tiến trình xử lý một kết nối)                  | Đa tiến trình và đa luồng (mỗi tiến trình có nhiều luồng xử lý)       |
		| Sử dụng tài nguyên          | Tiêu thụ bộ nhớ cao do mỗi tiến trình độc lập                     | Tiết kiệm bộ nhớ hơn nhờ chia sẻ bộ nhớ giữa các luồng                |
		| Tính ổn định                | Cao, lỗi trong một tiến trình không ảnh hưởng đến tiến trình khác | Thấp hơn, lỗi trong một luồng có thể ảnh hưởng đến tiến trình         |
		| Tương thích mô-đun          | Hỗ trợ tốt cho mô-đun không an toàn với đa luồng như `mod_php`    | Yêu cầu mô-đun phải an toàn với đa luồng                              |
		| Hiệu suất với lưu lượng cao | Kém hơn, vì phải tạo nhiều tiến trình mới cho mỗi kết nối         | Tốt hơn, có thể xử lý nhiều kết nối đồng thời với ít tài nguyên hơn   |
		| Khả năng mở rộng            | Hạn chế, do số lượng tiến trình cố định                           | Cao hơn, có thể tạo thêm luồng khi cần thiết                          |
		| Trường hợp sử dụng          | Trang web có lưu lượng thấp, yêu cầu tính ổn định cao             | Trang web có lưu lượng cao, yêu cầu hiệu suất và khả năng mở rộng tốt |

- Event-driven 
	- Kiến trúc hướng sự kiện (Event-driven architecture - EDA) là một mô hình kiến trúc phần mềm trong đó các thành phần hoặc dịch vụ của hệ thống giao tiếp với nhau chủ yếu thông qua việc sản xuất và tiêu thụ các sự kiện.
	- Các "sự kiện" (event) này có thể là các hành động người dùng, cập nhật dữ liệu, hoặc các thông báo từ các hệ thống khác. EDA giúp tạo ra các hệ thống linh hoạt, mở rộng và dễ tích hợp.
	- EDA dựa trên nguy- Kiến trúc hướng sự kiện bao gồm các nhà sản xuất sự kiện tạo ra luồng sự kiện, các đơn vị tiêu thụ sự kiện lắng nghe các sự kiện này và các kênh sự kiện chuyển sự kiện từ nhà sản xuất đến đơn vị tiêu thụ.ên lý phát hiện và phản hồi các event. Một event có thể là bất cứ điều gì xảy ra trong hệ thống, chẳng hạn như người dùng nhấp chuột, một gói tin đến từ mạng, hoặc một thay đổi trạng thái trong cơ sở dữ liệu. 
	- Các thành phần chính của EDA bao gồm:
		- Event Producers: Các thành phần phát sinh event: Đây là các đối tượng hoặc thành phần trong hệ thống phát sinh ra các event. Ví dụ, một nút bấm trong giao diện người dùng có thể phát sinh event khi người dùng nhấn vào nó.
		- Event Consumers: Các thành phần lắng nghe và xử lý event: Đây là các đối tượng hoặc thành phần lắng nghe các event và thực hiện hành động tương ứng khi event xảy ra. Ví dụ, khi một nút bấm được nhấn, listener có thể thực hiện một hàm xử lý để cập nhật giao diện người dùng.
		- Event Channels: Các kênh truyền event giữa producers và consumers.Đây là trung gian truyền tải event từ producers đến consumers. Nó có thể là một cơ chế đơn giản như một hàm callback hoặc phức tạp hơn như một hệ thống hàng đợi thông điệp.
	- Kiến trúc hướng sự kiện bao gồm các Event Producers tạo ra luồng sự kiện, các Event Consumers lắng nghe các sự kiện này và các Event Channels chuyển sự kiện từ Event Producers đến Event Consumers.
	- EDA có thể sử dụng hai mô hình chính: mô hình publish/subscribe và mô hình event stream.
		* Pub/sub: Một event được đăng ký bởi nhiều Event Consumers. Khi một event được publish, nó gửi event đến từng Event Consumers. Sau khi một event được nhận, nó không thể được publish lại và những Event Consumers mới sẽ không thấy event đó.
			- ![images](./images/pub.sub.webp)
		* Event Stream: Các event được ghi vào log. Các event được sắp xếp theo thứ tự nhất định. Clients không đăng ký vào Event Channels, thay vào đó, một client có thể đọc từ bất kỳ phần nào của channels. Client có trách nhiệm thay đổi vị trí đọc event trong channels. Điều đó có nghĩa là một client có thể tham gia bất cứ lúc nào và có thể phát lại các event.
			- ![images](./images/evtr.webp)
	- Các hình thức xử lí event: Có thể phân ra thành 3 nhóm chính như dưới đây:
		- Xử lí event rời rạc (Discrete event processing): Ví dụ như khi post một bài đăng lên mạng xã hội. Một trong số đặc trưng của việc xử lí event rời rạc đó là sự hiện diện của một event không hề liên quan đến các events khác và hoàn toàn có thể được xử lí độc lập.
		- Event stream processing: Xử lí các event theo luồng, có tính đến thứ tự của các events, khi mà event hiện tại có liên quan đến event trong quá khứ. Một ví dụ tiêu biểu đó là các events thay đổi lên business entity. Các events này sẽ được xử lí theo một thứ tự nhất định, sau đó sẽ lưu business entity data vào trong database. Consumer cũng cần tránh tình trạng đồng thời thay đổi lên cùng một record của database khiến cho dữ liệu không được nhất quán.
		- Complex event processing: Complex event processing (CEP) định danh và đưa ra các event pattern phức tạp dựa trên một chuỗi các event đơn giản. Ta lấy ví dụ về CEP cho việc theo dõi nhiệt độ và khói từ các cảm biến để phát hiện xem có xảy ra hoả hoạn hay không. Dữ liệu về nhiệt độ ở một thời điểm có thể không mang quá nhiều ý nghĩa nhưng với một "cụm nhiệt độ" cũng với tỉ lệ thay đổi nhiệt độ thì ta hoàn toàn có thể phán đoán được rằng liệu có đang xảy ra hoả hoạn hay không.
	-  Phân loại dựa trên cấu trúc liên kết (topology) giữa các component trong hệ thống với nhau, bao gồm 2 mô hình phổ biến:
		- Broker topology: Các thành phần phát ra các sự kiện cho toàn bộ hệ thống (broadcast). Các thành phần khác (Consumer) sẽ tự quyết định hành động dựa trên sự kiện đó hoặc bỏ qua. Không có sự điều phối hoặc quản lý tập trung.
			* Cấu trúc này có độ độc lập rất cao, giúp mang lại khả năng mở rộng, khả năng phản hồi và khả năng chịu lỗi của các thành phần.
			* Không có thành phần nào "sở hữu" hay nhận biết trạng thái của một giao dịch nghiệp vụ nhiều bước, và các hành động được thực hiện không đồng bộ. Do đó, các giao dịch phân tán có rủi ro vì không có cách nào tích hợp để khởi động lại hoặc phát lại.
		- Mediator topology:  Có một trình điều phối sự kiện (event mediator) trung tâm. Trình điều phối này quản lý và kiểm soát luồng sự kiện. Các thành phần chỉ phát ra "lệnh" (commands) đến các kênh được chỉ định (thường là hàng đợi tin nhắn). Trình điều phối sẽ nhận các lệnh này và quyết định xử lý hoặc chuyển tiếp chúng. Trình điều phối duy trì trạng thái, xử lý lỗi và khả năng khởi động lại.
			* Cấu trúc này mang lại khả năng kiểm soát tốt hơn, xử lý lỗi phân tán tốt hơn và tiềm năng đạt được tính nhất quán dữ liệu tốt hơn.
			* Cấu trúc này làm tăng sự phụ thuộc giữa các thành phần, và trình điều phối sự kiện có thể trở thành một nút thắt cổ chai hoặc một vấn đề về độ tin cậy.
	- Lợi ích của EDA
		- Độc lập cao: Producer và Consumer không phụ thuộc lẫn nhau.
		- Dễ mở rộng: Dễ dàng thêm Consumer mới mà không ảnh hưởng hệ thống.
		- Phản hồi nhanh: Xử lý sự kiện tức thì.
		- Linh hoạt & phân tán: Thích nghi tốt với tải thay đổi.
		- Dễ dàng scale: chúng ta có thể dễ dàng phân các events vào các substream khác nhau và xử lí chúng một cách song song cũng như thêm các consumers để có thể kịp thời xử lí số lượng lớn các events.
	- Nhược điểm 
		- Phức tạp trong xử lý luồng sự kiện: Xử lý các luồng sự kiện có thể phức tạp và đòi hỏi kỹ năng cao về quản lý trạng thái, xử lý song song và đồng bộ hóa. Việc đảm bảo tính nhất quán và đúng đắn trong các xử lý sự kiện cũng là một thách thức.
		- Khả năng mở rộng của hệ thống message broker: Việc sử dụng một hệ thống message broker để truyền tải sự kiện có thể tạo ra điểm bottleneck và làm giảm hiệu suất hệ thống nếu hệ thống message broker không được thiết kế để mở rộng tốt.
		- Đảm bảo tính nhất quán dữ liệu: Trong một hệ thống EDA, việc đảm bảo tính nhất quán của dữ liệu giữa các microservices có thể là một vấn đề khó khăn. Điều này đặc biệt đúng khi xảy ra các vấn đề về đồng bộ hóa dữ liệu giữa các bản sao hoặc khi có lỗi xảy ra trong quá trình xử lý sự kiện.
		- Độ trễ (Latency): Xử lý sự kiện trong một hệ thống EDA có thể gây ra độ trễ so với các phương pháp truyền thống, đặc biệt khi sự kiện phải được truyền qua một hệ thống message broker.
- Nginx Approach — Event-Driven
	- Không giống các máy chủ truyền thống tạo một tiến trình hoặc luồng riêng cho mỗi yêu cầu, Nginx hoạt động theo cơ chế khác. Mỗi tiến trình worker (tiến trình làm việc) của Nginx sẽ lắng nghe các sự kiện được tạo ra từ những yêu cầu mới đến.
	- Khi một worker chấp nhận yêu cầu kết nối và bắt đầu xử lý, điểm mấu chốt là: thay vì chặn (blocking) hoặc chờ đợi phản hồi trong quá trình thao tác Mạng (network) và Đĩa (disk) (còn gọi là I/O), worker đó sẽ ngay lập tức chấp nhận một yêu cầu kết nối khác từ hàng chờ, hoặc tiếp tục xử lý các yêu cầu mà quá trình I/O của chúng đã hoàn tất và đang chờ bước thực thi tiếp theo.
	- ![images](./images/nginx-evdr.webp)

#### 3.2.2 Module/Plugin
- Các module mở rộng Apache: Chức năng của Server Apache hầu hết được mở rộng nhờ các module. List các [Apache Module](https://httpd.apache.org/docs/2.4/mod/). Một vài module thông dụng của Apache: 
	- mod_rewrite
		- là một module mở rộng của Server Apache HTTP, nếu có nạp và sử dụng module này nó cho phép bạn viết lại Url. Chức năng chính của nó là ánh xạ một địa chỉ URL đến một vị trí file cụ thể của Server, tuy nhiên bạn có thể làm nhiều hơn thế như chuyển hướng, chặn truy cập ... rewrite_module phân tích yêu cầu gửi đến bằng cách sử dụng biểu thức chính quy
		- hoạt động trên toàn bộ đường dẫn URL bao gồm các data được nhập trên URL. Các rewrite rule có thể được định nghĩa trong các file httpd.conf trên hệ thống, file .htaccess trên source. Các rewrite rule có thể dẫn đến truy vấn theo chuỗi, khởi chạy chương trình nội bộ, gửi request ra bên ngoài hệ thống, hoặc gọi các proxy nội bộ.
		- Module này gồm các chỉ thị để bạn sử dụng như RewriteBase, RewriteCond, RewriteRule ... để sử dụng nó trong httpd.conf hoặc trong file .htaccess
		* Nếu chọn viết trong .htaccess, thì các Rewrite có hiệu lực trên thư mục đặt file đó. Khi Apache truy cập đến bất kỳ thư mục con nào thì nó cũng tìm xem trong thư mục đó có file .htaccess không để nạp vào. Viết cách này khá linh hoạt, nhưng đôi khi làm chậm một chút, nếu có thể ở cấu hình VirtualHost tắt hẳn .htaccess bằng chỉ thị AllowOverride None để chỉ viết trong cấu hình Apache httpd.conf
		* Các quy tắc ReWrite viết trong httpd.conf ở các Directory của VirtualHost, kết quả thì cũng tương tự viết trong .htaccess, nó nhanh hơn vì các luật ReWrite Apache không phải tìm vào nạp mỗi khi truy cập, viết xong phải khởi động lại Apache để có hiệu lực
			| Chỉ thị       | Cú pháp                                      | Mô tả                                                                                                                 |
			| ------------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
			| RewriteEngine | `RewriteEngine On` hoặc `Off`                | Bật hoặc tắt chức năng rewrite. Mặc định không bật cho tất cả thư mục, phải khai báo trong từng thư mục muốn sử dụng. |
			|               |                                              | Mỗi thư mục sử dụng Rewrite cần khai báo `RewriteEngine On` ở đầu file `.htaccess`.                                   |
			| RewriteBase   | `RewriteBase URL-path`                       | Thiết lập URL cơ sở (base path) cho các luật rewrite trong thư mục hiện tại.                                          |
			| RewriteRule   | `RewriteRule Pattern Substitution [flags]`   | Định nghĩa luật thay đổi URL. `Pattern` là biểu thức chính quy, `Substitution` là URL thay thế nếu khớp.              |
			|               |                                              | Ví dụ:                                                                                                            |
			|               |                                              | `RewriteRule ^welcome\.html$ /html/index.html [L]`                                                                    |
			|               |                                              | Nếu truy cập `/welcome.html`, Apache sẽ truy cập thực tế `/html/index.html` trên hệ thống.                            |
			|               |                                              | `^welcome\.html$`: Mẫu URL cần khớp (dùng biểu thức chính quy).                                                       |
			|               |                                              | `/html/index.html`: Đường dẫn thay thế nếu khớp.                                                                      |
			|               |                                              | `[L]`: Cờ (flag) báo dừng sau khi áp dụng rule này.                                                                   |
			| RewriteCond   | `RewriteCond TestString CondPattern [flags]` | Áp điều kiện cho `RewriteRule` ngay bên dưới nó. Nếu điều kiện đúng thì `RewriteRule` mới được áp dụng.               |
			|               |                                              | Dùng để kiểm tra URL, phương thức HTTP, biến môi trường, user agent, v.v.                                             |
			|               |                                              | [flags]: Cờ thiết lập cho RewriteCond                                                                             |
			|               |                                              | - `[OR]`: Toán tử “hoặc” để kết nối nhiều điều kiện (mặc định là AND)                                                 |
			|               |                                              | - `[NC]`: Không phân biệt chữ hoa – thường                                                                            |
			|               |                                              | CondPattern: Mẫu là biểu thức chính quy để kiểm tra sự phù hợp với TestString                                     |
			|               |                                              | - `-s`: Kiểm tra TestString là file tồn tại trên đĩa                                                                  |
			|               |                                              | - `-d`: Kiểm tra là thư mục                                                                                           |
			|               |                                              | - `-l`: Kiểm tra là symbolic link                                                                                     |
			|               |                                              | TestString: Chuỗi chứa giá trị cần kiểm tra                                                                       |
			|               |                                              | - Viết dưới dạng `%{TÊN_BIẾN}` như `%{QUERY_STRING}`, `%{REMOTE_ADDR}`, `%{REQUEST_METHOD}`, ...                      |
			|               |                                              | - Biến môi trường: `%{ENV:ten_bien}`                                                                                  |
			|               |                                              | - Header HTTP: `%{HTTP:Header_Name}`                                                                                  |

		- Một số rule rewrite cơ bản
			* Chuyển hướng URL: Sử dụng khi xóa (đổi địa chỉ) một URL trên website, nhưng muốn khi người dùng truy cập vào sẽ tự chuyển sang một trang khác, Chuyển sang một domain mới
				```
				RewriteEngine On
				#Chuyển hướng 1 URL cụ thể
				RewriteEngine  on
				RewriteRule    "^/url-cu\.html$"  "url-moi.html"  [R=301]
				#Chuyển hướng thư mục news sang domain (server mới)
				RewriteRule   "^/docs/(.+)"  "http://new.example.com/docs/$1"  [R,L]
				```
			* Chuyển hướng các yêu cầu không tồn tại về trang chủ
				```
				RewriteCond %{REQUEST_FILENAME} !-f
				RewriteCond %{REQUEST_FILENAME} !-d
				RewriteRule . / [R=301]
				```	
					* RewriteCond %{REQUEST_FILENAME} !-f: Chỉ áp dụng quy tắc nếu yêu cầu không phải là một file tồn tại trên server.
					* RewriteCond %{REQUEST_FILENAME} !-d: Và tiếp tục chỉ áp dụng nếu yêu cầu không phải là một thư mục tồn tại trên server.
					* RewriteRule . / [R=301]: Chuyển hướng vĩnh viễn (301) bất kỳ yêu cầu nào thỏa mãn hai điều kiện trên về trang chủ của website.
- mod_ssl
	- là một module của Apache HTTP Server cung cấp khả năng mã hóa SSL/TLS, cho phép máy chủ Apache hỗ trợ giao thức HTTPS. Module này sử dụng thư viện OpenSSL để thực hiện mã hóa và giải mã dữ liệu, đảm bảo tính bảo mật cho thông tin truyền tải giữa máy chủ và người dùng.
	- Các chỉ thị quan trọng trong mod_ssl
		- SSLENGINE: Bật/Tắt sử dụng module
		- SSLCertificateFile: Định nghĩa đường dẫn đến chứng chỉ SSL.
		- SSLCertificateKeyFile: Định nghĩa đường dẫn đến khóa riêng.
		- SSLCertificateChainFile: Định nghĩa đường dẫn đến chứng chỉ trung gian.
		- SSLCipherSuite: Xác định bộ mã hóa được phép sử dụng.
		- SSLProtocol: Chỉ định các phiên bản giao thức SSL/TLS được hỗ trợ.
		- SSLPassPhraseDialog: Cấu hình cách Apache yêu cầu mật khẩu khi đọc khóa riêng được mã hóa.
	- Module này enable bằng lệnh `sudo a2enmod ssl`
	- Sử dụng Module này để cấu hình SSL/TLS cho apache2 với chứng chỉ được cấp từ các CA như Let's Encrypt
	- Có thể tự sinh chứng chỉ SSL tự ký bằng OpenSSL và sử dụng module này để cấu hình cho Apache (Test)
		* Sinh chứng chỉ 
		```
		sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/apache-selfsigned.key -out /etc/ssl/certs/apache-selfsigned.crt
		```
		* Chỉnh sửa file cấu hình apache 
		```
		sudo nano /etc/apache2/sites-available/default-ssl.conf
		```
		* Thêm các cấu hình SSL 
		```
		SSLEngine on 
		SSLCertificateFile /etc/ssl/certs/apache-selfsigned.crt 
		SSLCertificateKeyFile /etc/ssl/private/apache-selfsigned.key
		```
- mod_security 
	- là module bảo mật của apache2 nó hoạt động bằng cách kiểm tra các yêu cầu được gửi đến máy chủ web theo thời gian thực dựa trên một bộ quy tắc được xác định trước, ngăn chặn các cuộc tấn công ứng dụng web điển hình như XSS và SQL Injection.
	- ban đầu là một mô-đun của Apache và sau đó phát triển thành một tường lửa ứng dụng web hoàn chỉnh.
	- Module này có thể được cài bằng lệnh `sudo apt install libapache2-mod-security2`
	- Enable Module này trong file cấu hình của apache `SecRuleEngine On` 
-  Các module mở rộng Nginx: NGINX được xây dựng từ nhiều mô-đun nhỏ, mỗi mô-đun đảm nhiệm một chức năng riêng. Điều này giúp NGINX nhỏ gọn, nhanh và dễ tùy chỉnh. Một vài module trong nginx: 
	- ngx_http_core_module
		- ngx_http_core_module trong Nginx là mô-đun nền tảng để xử lý HTTP. Nó cung cấp chức năng cốt lõi để xử lý các yêu cầu, bao gồm cấu hình cài đặt máy chủ, định nghĩa các trang lỗi và quản lý dữ liệu yêu cầu và phản hồi. Mô-đun này là cơ bản để Nginx hoạt động như một máy chủ HTTP.
		- Chức năng chính
			* Quản lý Virtual Hosts: Cấu hình nhiều `server` block với các chỉ thị như `listen` và `server_name`.
			* Điều hướng yêu cầu: Xử lý các URI qua `location` và hỗ trợ khớp chính xác, wildcard, và regex.
			* Phục vụ nội dung tĩnh: Dùng `root` và `alias` để chỉ định thư mục chứa tệp tĩnh.
			* Quản lý lỗi và bảo mật: Tùy chỉnh trang lỗi với `error_page`, kiểm soát truy cập và xác thực với `auth_basic`.
			* Cấu hình hiệu suất: Tối ưu hóa hiệu suất với các chỉ thị như `keepalive_timeout`, `sendfile`, và `tcp_nopush`.
			* MIME types và bộ đệm: Xác định loại MIME với `types`, tối ưu bộ đệm với `open_file_cache`.
		- Một vài chỉ thị cấu hình của module 
			* `server { ... }` : Thiết lập cấu hình cho một máy chủ ảo. 
				- Ví dụ 
					```
					server {
					listen      80;
					server_name example.org www.example.org;
					}
					```
			* `listen address:port;`: Đặt địa chỉ và cổng cho IP, hoặc đường dẫn cho một socket UNIX-domain mà máy chủ sẽ chấp nhận các yêu cầu trên đó. Có thể chỉ định cả địa chỉ và cổng, hoặc chỉ địa chỉ hoặc chỉ cổng. Một địa chỉ cũng có thể là một hostname, ví dụ:
				- Ví dụ 
					```
					listen 127.0.0.1:8000;
					listen 127.0.0.1;
					listen 8000;
					listen *:8000;
					listen localhost:8000;
					```
			* `client_max_body_size`: Đặt kích thước tối đa cho phần thân yêu cầu từ client được phép. Nếu kích thước trong một yêu cầu vượt quá giá trị đã cấu hình, lỗi 413 (Request Entity Too Large) sẽ được trả về cho client. 
				- Ví dụ
					```
					client_max_body_size 1m;
					```	
			* `error_page`: Xác định URI (đường dẫn) sẽ hiển thị cho các lỗi được chỉ định. Giá trị URI có thể chứa các biến.
				- Ví dụ 
					```
					error_page 404             /404.html;
					error_page 500 502 503 504 /50x.html;
					error_page 404 =301 http://example.com/notfound.html;
					```
	- ngx_http_access_module
		- là module cho phép giới hạn quyền truy cập đối với các địa chỉ client nhất định. Quyền truy cập cũng có thể được giới hạn theo mật khẩu, kết quả của một subrequest, hoặc theo JWT. Việc giới hạn quyền truy cập đồng thời theo địa chỉ và mật khẩu được kiểm soát bởi chỉ thị satisfy.
		- Module gồm 2 directives cơ bản là `allow`, `deny` để thực hiện cấu hình.
		- Ví dụ: Cấ hình quyền truy cập chỉ được phép cho các mạng IPv4 10.1.1.0/16 và 192.168.1.0/24 (loại trừ địa chỉ 192.168.1.1), và cho mạng IPv6 2001:0db8::/32
			```
			location / {
			deny 192.168.1.1;
			allow 192.168.1.0/24;
			allow 10.1.1.0/16;
			allow 2001:0db8::/32;
			deny all;
			}
			```
	- ngx_http_rewrite_module 
		- Cung cấp các công cụ để thay đổi URL, định tuyến lại yêu cầu (redirect), và điều kiện xử lý dựa trên các biểu thức chính quy (regex).
		- Gồm các chỉ thị break, if, return, rewrite, rewrite_log và set được xử lý theo thứ tự:
			- Các chỉ thị của mô-đun này được chỉ định ở cấp độ máy chủ (server level) được thực thi tuần tự;
			- Lặp đi lặp lại:
				- Một vị trí (location) được tìm kiếm dựa trên URI của yêu cầu;
				- Các chỉ thị của mô-đun này được chỉ định bên trong vị trí tìm thấy sẽ được thực thi tuần tự;
				- Vòng lặp được lặp lại nếu URI của yêu cầu đã được viết lại, nhưng không quá 10 lần.
		- Ví dụ: Sử dụng rewrite để thay đổi đường dẫn và phần mở rộng của tệp, sau đó trả về lỗi 403 cho các yêu cầu không phù hợp
			```
			server {
				...
				rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
				rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra last;
				return 403;
				...
			}
			```
	- ngx_http_ssl_module 	
		- Cung cấp sự hỗ trợ cần thiết cho HTTPS. Module này yêu cầu thư viện OpenSSL 
		- Gồm nhiều chỉ thị khác nhau nổi bật cần chú ý:  ssl_certificate, ssl_certificate_key, ssl_protocols phục vụ cấu hình SSL/TLS cơ bản 
		- Ví dụ: Cấu hình Nginx để phục vụ nội dung qua HTTPS, bật mã hóa SSL.
			```
			ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
			ssl_ciphers AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
			ssl_certificate /usr/local/nginx/conf/cert.pem;
			ssl_certificate_key /usr/local/nginx/conf/cert.key;
			```
	- ngx_http_proxy_module
		- Cho phép chuyển tiếp các yêu cầu đến một máy chủ khác.
		- Gồm nhiều chỉ thị khác nhau 
			* proxy_pass: Chỉ định URL backend để chuyển tiếp yêu cầu. `proxy_pass http://backend_server;`
			* proxy_set_header: Thiết lập lại các header HTTP khi chuyển tiếp yêu cầu. `proxy_set_header Host $host;`
			* proxy_redirect: Điều chỉnh URL trong header Location và Refresh. `proxy_redirect http://backend/ http://$host/;`
			* proxy_http_version: Xác định phiên bản HTTP khi giao tiếp với backend. `proxy_http_version 1.1;`
			* proxy_cache: Kích hoạt bộ nhớ cache cho các phản hồi từ backend. `proxy_cache my_cache;`
		- Ví dụ cầu hình : Chuyển tiếp các yêu cầu từ client đến một máy chủ backend đang chạy trên localhost:8000. Thiết lập lại các header:
			* Host: Chứa tên miền gốc của yêu cầu.
			* X-Real-IP: Chứa địa chỉ IP thật của client gửi yêu cầu.
			```
			location / {
				proxy_pass http://localhost:8000;
				proxy_set_header Host $host;
				proxy_set_header X-Real-IP $remote_addr;
			}
			```
	- Chi tiết về các module của Nginx tại [Nginx Modules Reference](https://www.f5.com/pdf/reference-guide/nginx-modules-reference.pdf)
## 4. Cấu hình và Triển khai Web Server
### 4.1  Cấu hình virtual host (host nhiều website trên một server).
- Virtual Hosts (còn được gọi là Virtual Hosting) là một kỹ thuật trong việc quản lý các trang web trên một máy chủ web duy nhất. Điều này cho phép bạn chạy nhiều trang web khác nhau trên cùng một máy chủ vật lý, mỗi trang web với tên miền riêng, nhưng chúng chia sẻ cùng một địa chỉ IP.
- Phân biệt các loại Virtual Hosts:
	- Name-Based Virtual Host: Đây là phương pháp phổ biến nhất, cho phép nhiều website sử dụng chung một địa chỉ IP. Máy chủ web sẽ dựa vào thông tin trong HTTP Header từ yêu cầu của client để xác định chính xác website cần truy cập. 
	- IP-Based Virtual Host: Đây là phương pháp cơ bản và dễ hiểu nhất trong ba phương pháp quản lý hosting. Mỗi website được gán một địa chỉ IP riêng, giúp máy chủ dễ dàng ánh xạ đúng website tương ứng khi nhận được yêu cầu từ người dùng.
	- Port-Based Virtual Host: Đây là một giải pháp linh hoạt hơn IP-Based, cho phép nhiều website cùng sử dụng một địa chỉ IP hoặc tên miền nhưng được phân biệt thông qua các số Port khác nhau. Mỗi cổng (Port) đại diện cho một website cụ thể. 
- Cách hoạt động cơ bản: Khi một trình duyệt yêu cầu một trang web (ví dụ: www.trangwebcuaban.com), nó sẽ:
	- Phân giải tên miền www.trangwebcuaban.com thành một địa chỉ IP.
	- Gửi yêu cầu HTTP đến địa chỉ IP đó, đồng thời bao gồm tiêu đề Host: www.trangwebcuaban.com.
	- Máy chủ web (Apache, Nginx, v.v.) nhận yêu cầu.
	- Máy chủ kiểm tra tiêu đề Host để xác định trang web nào đang được yêu cầu.
	- Dựa trên cấu hình Virtual Host đã được định nghĩa, máy chủ sẽ phục vụ nội dung từ thư mục gốc (document root) tương ứng với tên miền đó.
- Ưu điểm 
	* Tiết kiệm chi phí: Chia sẻ tài nguyên máy chủ giúp giảm chi phí so với máy chủ riêng.
	* Phù hợp cho cá nhân/SMEs: Lý tưởng cho doanh nghiệp nhỏ hoặc cá nhân không cần đầu tư lớn.
	* Giảm tải traffic: Nếu cấu hình tốt, giúp phân bổ lưu lượng hợp lý, tránh nghẽn tài nguyên.
	* Tận dụng tài nguyên: Tối ưu hiệu quả sử dụng máy chủ, tránh lãng phí.
	* Dễ quản lý: Hỗ trợ các công cụ như cPanel, DirectAdmin để quản lý website thuận tiện.
	* Linh hoạt: Lưu trữ nhiều website, mỗi site có thể dùng tên miền riêng.
	* Khả năng mở rộng: Dễ dàng thêm/xóa website mà không cần thay đổi phần cứng.
	* Quản lý độc lập: Mỗi website có thể có cấu hình riêng, không ảnh hưởng lẫn nhau.
- Nhược điểm 
	* Hiệu năng hạn chế: Tài nguyên chia sẻ nên dễ bị giảm hiệu suất khi một website dùng quá nhiều tài nguyên.
	* Ảnh hưởng lẫn nhau: Nếu một site bị tấn công (như DDoS), các site khác trên cùng server cũng có thể bị ảnh hưởng.
	* Bảo mật thấp hơn: Nhiều website chung môi trường → nguy cơ lây lan khi một site bị xâm nhập.
	* Không phù hợp với ứng dụng nặng: Các hệ thống cần nhiều RAM, CPU hoặc cấu hình đặc biệt thường không hoạt động hiệu quả trên Virtual Hosts.
	* Giới hạn quyền kiểm soát: Không có quyền root, hạn chế khả năng tinh chỉnh hệ thống sâu.
	* Quản lý phức tạp khi mở rộng: Càng nhiều website, việc cập nhật và kiểm tra cấu hình càng rủi ro, dễ sai sót.
	* Ràng buộc tài nguyên: Không tối ưu cho các website có nhu cầu cao về tài nguyên hoặc yêu cầu môi trường độc lập.
- Cấu hình virtual host trên các WebServer phổ biến: Apache2, Nginx, IIS 
- Apache2 : 
	- Các virtual host được quản lý bằng file cấu hình tại `/etc/apache2/sites-available/` mỗi file tương ứng với 1 VirtualHost
	- Apache Virtual Host mặc định sẽ là 000-default.conf và default-ssl.conf tương ứng cho http/https. Cấu hình VirtualHost mới cần dựa vào 2 file này. 
	- Ví dụ: Thực hiện tạo 2 VirtualHost cho 2 domain: domain1.com và domain2.com 
		- Copy file cấu hình mẫu 
		```
		cd /etc/apache2/sites-available/
		cp 000-default.conf domain1.conf
		cp 000-default.conf domain2.conf
		```
		- Thực hiện mở file sửa cấu hình 
		```
		nano /etc/apache2/sites-available/domain1.conf
		nano /etc/apache2/sites-available/domain2.conf
		```
		- Cần chú ý tới các thuộc tính cần chỉnh sửa:
			- ServerName: Tại thuộc tính này bạn chỉ cần sửa lại tên thành Domain mà bạn mong muốn, như ví dụ chúng ta đang thực hiện ở trên là domain1.com
			- ServerAdmin: Ở thuộc tính này bạn nên lựa chọn địa chỉ Email chính của mình để có thể quản lý cho Domain mới tạo này.
			- DocumentRoot: Đây là địa chỉ lưu trữ thư mục trang Web của domain ví dụ  /var/www/domain1.com/public_html.
		- Sau khi đã chỉnh sửa thực hiện enable các site đã cấu hình
		```
		sudo a2ensite domain1.conf
		sudo a2ensite domain2.conf
		```
		- Restart Apache2 để áp dụng cấu hình 
		```
		sudo systemctl restart apache2
		```
- Nginx 
	- Các VirtualHost được quản lý bởi các file Block có đường dẫn `/etc/nginx/sites-available/` mỗi file tương ứng với 1 VirtualHost
	- Mặc định có 1 block file là defautl. Để cấu hình các block mới cần dựa vào file này
	- Ví dụ: Tạo 2 file Block cho 2 domain domain1.com và domain2.com 
		- Copy file cấu hình mẫu 
		```
		sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/domain1.com
		sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/doamin2.com
		```
		- Thực hiện mở file sửa cấu hình 
		```
		nano /etc/nginx/sites-available/domain1.com
		nano /etc/nginx/sites-available/domain2.com
		```
		- Chú ý các thuộc tính cần chỉnh sửa:
			- server_name: Chỉnh sửa về cho đúng tên miền cần cấu hình. 
			- Trong Location block phần root xác định đường dẫn tới thư mục chứa website và tệp mặc định của web 
		- Sau khi đã chỉnh sửa xong tạo liên kết từ tệp cấu hình trong sites-available đến sites-enabled để kích hoạt Virtual Hostings:
		```
		sudo ln -s /etc/nginx/sites-available/domain1.com /etc/nginx/sites-enabled/
		sudo ln -s /etc/nginx/sites-available/domain2.com /etc/nginx/sites-enabled/
		```
		- Restart Nginx để áp dụng cấu hình 
		```
		systemctl restart nginx 
		```
- IIS 
	- Trên IIS, việc quản lý Virtual Host (hay còn gọi là Website) được thực hiện thông qua giao diện đồ họa của IIS Manager, không giống như Nginx hay Apache dùng các file cấu hình trực tiếp.
	- IIS Manager là công cụ chính để quản lý các Virtual Host (Websites).
	- Ví dụ: Tạo 2 VirtualHost cho 2 domain domain1.com và domain2.com 
		- Thêm website mới trong 
			- Mở IIS Manager: Tìm kiếm "IIS Manager" trong Start Menu.
			- Trong khung Connections bên trái, mở rộng tên máy chủ của bạn.
			- Nhấp chuột phải vào mục "Sites" và chọn "Add Website...".
			- Đối với domain1.com:
				```
				Site name: domain1.com (tên hiển thị trong IIS Manager)
				Physical path: Duyệt đến C:\inetpub\wwwroot\domain1.com
				Binding:
				Type: http
				IP address: Chọn địa chỉ IP của máy chủ (thường là All Unassigned nếu chỉ có một IP).
				Port: 80
				Host name: domain1.com (tên miền chính)
				Nhấp "OK".
				```
			- Đối với domain2.com:	Lặp lại các bước trên.
				```
				Site name: domain2.com
				Physical path: Duyệt đến C:\inetpub\wwwroot\domain2.com
				Binding:
				Type: http
				IP address: Chọn địa chỉ IP của máy chủ.
				Port: 80
				Host name: domain2.com
				Nhấp "OK".
				```
		- IIS tự động áp dụng cấu hình ngay sau khi bạn nhấp "OK" trong IIS Manager; bạn không cần phải "restart" toàn bộ dịch vụ IIS như Nginx.
### 4.2   Thiết lập reverse proxy, load balancing (ví dụ: Nginx làm proxy cho Apache).
#### 4.2.1. Reverse proxy
- Reverse Proxy thể hiện đúng như tên gọi của nó về nguyên tắc hoạt động. Đây là một Server trung gian giữa các khách hàng và một hoặc nhiều máy chủ nội bộ. Khi nhận được yêu cầu từ khách hàng, Reverse Proxy sẽ xác định máy chủ nào trong mạng sẽ nhận yêu cầu đó.
- ![images](./images/r-proxy.png)
- Các lợi ích chính của reverse proxy:
	* Cân bằng tải: Phân phối đều lưu lượng truy cập giữa nhiều máy chủ để tránh quá tải và đảm bảo tính khả dụng.
	* Bảo vệ khỏi tấn công: Giấu địa chỉ IP của máy chủ gốc, làm khó kẻ tấn công thực hiện các cuộc tấn công trực tiếp (như DDoS).
	* Cân bằng tải toàn cầu (GSLB): Điều hướng người dùng đến máy chủ gần nhất về mặt địa lý để giảm thời gian tải.
	* Bộ nhớ đệm (Caching): Lưu trữ tạm thời nội dung để phục vụ các yêu cầu lặp lại nhanh hơn.
	* Mã hóa SSL: Xử lý việc mã hóa/giải mã SSL/TLS, giảm tải cho máy chủ gốc.
- Nginx là một HTTP Server và Reverse Proxy Server. Nó cũng được sử dụng như một TCP/UDP Server.
- Nginx được sử dụng rất phổ biến cho máy chủ HTTP, nó thường được sử dụng để làm Reverse Proxy. Tức là một máy chủ có khả năng điều hướng và che giấu các dịch vụ khác ở bên trong máy chủ.
- Ví dụ cấu hình Nginx làm proxy cho apache2 
	- Sử dụng Nginx làm Reverse proxy chuyển tiếp tới backend apache chạy trên port 8080
	- Chỉnh sửa cấu hình nginx 
	```
	sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/apache2-rv
	nano /etc/nginx/sites-available/apache2-rv
	```
	- Trong file cấu hình chỉnh sửa `server_name` về đúng domain cần cấu hình, trong block location thiết lập các option proxy, file cấu hình mẫu cho domain demo1.com
	```
	server {
		listen 80;
		server_name domain1.com www.domain1.com;

		# Serve static files directly with NGINX
		location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
			root /var/www/html;
		}

		# Forward other requests to Apache 
		location / {
			proxy_pass http://127.0.0.1:8080;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
		}

		error_page 500 502 503 504 /50x.html;
		location = /50x.html {
			root /var/www/html;
		}
	}
	```	
	- Trong đó:
		- proxy_pass http://127.0.0.1:8080;: Chuyển yêu cầu đến Apache đang chạy trên localhost (127.0.0.1) cổng 8080.
		- proxy_set_header Host $host;: Gửi lại tên miền gốc đến Apache.
		- proxy_set_header X-Real-IP $remote_addr;: Chuyển IP thực của người dùng đến Apache.
		- proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;: Gửi danh sách các proxy mà yêu cầu đã đi qua.
		- proxy_set_header X-Forwarded-Proto $scheme;: Gửi giao thức ban đầu (http/https) đến Apache.
	- Sau khi đã chỉnh sửa xong tạo liên kết từ tệp cấu hình trong sites-available đến sites-enabled để kích hoạt Virtual Hostings:
	```
	sudo ln -s /etc/nginx/sites-available/apache2-rv /etc/nginx/sites-enabled/
	```
	- Restart Nginx để áp dụng cấu hình 
	```
	systemctl restart nginx 
	```
#### 4.2.2. Load balancing
- Load Balancing (Cân bằng tải) là một thành phần quan trọng của cơ sở hạ tầng mạng, thường được sử dụng để cải thiện hiệu suất và độ tin cậy của các website, ứng dụng, cơ sở dữ liệu và các dịch vụ khác bằng phương pháp phân phối khối lượng công việc cho nhiều máy chủ cùng xử lí.
- ![images](./images/lb.webp)
- Để thể điều phối được request cho server thích hợp, load balancing sử dụng một trong những thuật toán sau:
	- Round Robin: Khi sử dụng thuật toán này, các request sẽ được phân phối tuần tự cho 1 nhóm server.
	- Weighted Round Robin: Dựa trên thuật toán Round Robin, người quản trị mạng sẽ dựa vào khả năng xử lí request của từng server và đánh thứ độ ưu tiên cho các server, request sẽ được gửi tới server theo độ ưu tiên của chúng.
	- Least Connections: Request sẽ được gửi tới server có ít kết nối nhất với client để xử lí.
	- Weighted Least Connections: Request sẽ được gửi tới server có tốc độ phản hồi response cao nhất và ít kết nối nhất.
	- IP Hash: Địa chỉ IP của client sẽ được sử dụng để nhận biết server nào sẽ nhận được request từ người dùng.
- Ví dụ sử dụng Nginx load balancing cho các backend sv1.example.com sv2.example.com sv3.example.com 
	- Chỉnh sửa file cấu hình Nginx 
	```
	sudo nano /etc/nginx/nginx.conf
	```
	- Trong file này cần chú ý cấu hình các block `upstream` và `server`. Ví dụ về cấu hình 
	```
	http {
		upstream myapp1 {
			server sv1.example.com;
			server sv2.example.com;
			server sv3.example.com;
		}

		server {
			listen 80;

			location / {
				proxy_pass http://myapp1;
			}
		}
	}
	```
		- upstream myapp1: Định nghĩa một nhóm các máy chủ backend có thể xử lý các yêu cầu. Trong trường hợp này, đó là sv1.example.com, sv2.example.com, và sv3.example.com.
		- server { listen 80; ... }: Nginx lắng nghe các yêu cầu đến từ client trên cổng 80.
		- location / { proxy_pass http://myapp1; }: Tất cả các yêu cầu đến Nginx sẽ được chuyển tiếp (proxy) đến nhóm máy chủ myapp1. Nginx sẽ tự động chọn một máy chủ từ nhóm đó để xử lý yêu cầu, phân phối tải trọng giữa chúng.
	- Khởi động lại dịch vụ
	```
	systemctl restart nginx
	```
	- Mặc định Nginx sử dụng thuật toán `Round Robin` để sử dụng với các thuật toán khác thực hiện cấu hình trong block `upstream` ví dụ 
	```
	    upstream myapp1 {
        least_conn;
        server sv1.example.com;
        server sv2.example.com;
        server sv3.example.com;
    }
	```
	- Cấu hình weight chỉnh sửa trong block `upstream` ví dụ:
	```
	    upstream myapp1 {
        server sv1.example.com weight=3;
        server sv2.example.com;
        server sv3.example.com;
    }
	```
### 4.3   Cấu hình caching (giảm tải server).
- Cache là một bộ nhớ đệm dùng để lưu trữ tạm thời dữ liệu. Khi một trang web được tải lên, nó sẽ lưu trữ các dữ liệu đó vào cache để khi người dùng truy cập lại trang web đó, trang web sẽ được tải nhanh hơn.
- Caching là một phương pháp cho phép lưu trữ các thông tin về trang web trong bộ nhớ tạm thời để tránh phải lấy dữ liệu từ máy chủ quá nhiều lần, giảm tải cho máy chủ và tăng tốc độ tải trang web.
- Nginx là một trong những máy chủ web phổ biến nhất, với khả năng cấu hình cache hiệu quả 
- Ví dụ cấu hình với Nginx 
	- Để cấu hình caching cần tạo thư mục cache trên máy chủ và đảm bảo nginx có quyền ghi vào thư mục này 
	- Chỉnh sửa cấu hình trong `/etc/nginx/nginx.conf` sử dụng cache 
		```
		proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m inactive=60m;
		proxy_cache_key "$scheme$request_method$host$request_uri";
		proxy_cache_valid 200 60m;
		```
		- Trong đó:
			- /path/to/cache là đường dẫn đến thư mục cache mà bạn đã tạo ở bước trước đó.
			- my_cache là tên của khu vực cache mà bạn muốn sử dụng. Bạn có thể đặt bất kỳ tên nào tùy ý.
			- levels=1:2 xác định cấu trúc của thư mục cache. Ở đây, chúng ta đang sử dụng một cấu trúc 2 cấp, với cấp đầu tiên là tên khối và cấp thứ hai là các tập tin cache của khối đó.
			- inactive=60m xác định thời gian tối đa mà một bản sao của một tài nguyên được giữ trong cache trước khi bị xóa.
			- proxy_cache_valid xác định thời gian tối đa mà một bản sao của một tài nguyên được giữ trong cache trước khi nó được coi là không còn hợp lệ và bị xóa khỏi cache.
	- Cấu hình chỉ định cho Nginx sử dụng cache cho các truy vấn
		```
		proxy_cache my_cache;
		proxy_cache_bypass $http_pragma;
		proxy_cache_revalidate on;
		```
		- Trong đó:
			- my_cache là tên của khu vực cache mà bạn đã định nghĩa ở bước trước đó.
			- $http_pragma sẽ bỏ qua cache và tải trực tiếp từ máy chủ khi nó bị đặt thành “no-cache”.
	- Khởi động lại dịch vụ
	```
	systemctl restart nginx
	```
### 4.4   Tối ưu tốc độ (nén dữ liệu, CDN, HTTP/2).
#### 4.4.1. Nén dữ liệu 
- HTTP Compression là một kĩ thuật có thể tích hợp vào web servers và web clients để cải thiện tốc độ truyền và sử dụng băng thông bằng cách nén các file ở server nhằm giảm dung lượng file, giúp quá trình gửi xuống client trở lên nhanh hơn.
- Cách thức hoạt động: Quá trình nén HTTP hoạt động dựa trên cơ chế thỏa thuận giữa trình duyệt (client) và máy chủ (server):
	- Trình duyệt gửi yêu cầu Accept-Encoding: Khi trình duyệt gửi yêu cầu HTTP, nó bao gồm một tiêu đề Accept-Encoding để thông báo cho máy chủ biết những thuật toán nén mà nó hỗ trợ (ví dụ: Accept-Encoding: gzip, deflate, br).
	- Máy chủ nén và gửi phản hồi Content-Encoding: Nếu máy chủ hỗ trợ một trong các thuật toán nén đó và có thể nén tài nguyên, nó sẽ nén dữ liệu và gửi phản hồi kèm theo tiêu đề Content-Encoding (ví dụ: Content-Encoding: gzip) để thông báo cho trình duyệt biết tài nguyên đã được nén bằng thuật toán nào.
	- Trình duyệt giải nén: Trình duyệt nhận phản hồi, giải nén dữ liệu và hiển thị nội dung cho người dùng.
- Các thuật toán nén phổ biến: Có ba thuật toán nén chính thường được sử dụng với HTTP:
	- Gzip (GNU zip):
		- Là thuật toán nén phổ biến nhất và được hỗ trợ rộng rãi nhất.
		- Thường được sử dụng để nén các tệp văn bản như HTML, CSS, JavaScript và các tệp JSON.
		- Hiệu quả trong việc giảm kích thước tệp, giúp giảm đáng kể thời gian tải trang.
	- Deflate:
		- Trong thực tế, Deflate thường được triển khai dưới dạng một luồng dữ liệu zlib được nén bằng thuật toán DEFLATE.
		- Hiệu quả nén thường tương đương hoặc kém hơn một chút so với Gzip.
	- Brotli (br):
		- Một thuật toán nén tương đối mới được phát triển bởi Google.
		- Thường cung cấp tỷ lệ nén tốt hơn đáng kể so với Gzip và Deflate, đặc biệt với các tệp văn bản.
		- Cần hỗ trợ từ cả máy chủ và trình duyệt (hầu hết các trình duyệt hiện đại đều đã hỗ trợ Brotli).
- Nén dữ liệu giúp:
	- Tăng tốc độ tải trang: Dữ liệu nhỏ hơn được truyền nhanh hơn, giúp website hiển thị nhanh chóng.
	- Tiết kiệm băng thông: Giảm lượng dữ liệu phải truyền tải qua mạng, có lợi cho cả người dùng (giảm tiêu thụ dữ liệu) và nhà cung cấp dịch vụ (giảm chi phí băng thông).
	- Cải thiện trải nghiệm người dùng: Người dùng ít phải chờ đợi hơn, dẫn đến sự hài lòng cao hơn.
	- Tăng điểm số SEO: Các công cụ tìm kiếm ưu tiên các trang web có tốc độ tải nhanh.
- Ví dụ 
	- Cấu hình nén gzip trên Nginx chỉnh sửa file cấu hình enable gzip `/etc/nginx/nginx.conf`
		```
		gzip on;
		gzip_types text/plain text/html /text/css text/javascript application/xml application/javascript;    
		gzip_min_length 500;
		```
		- gzip on;: Bật tính năng nén Gzip.
		- gzip_types text/plain text/html /text/css text/javascript application/xml application/javascript;: Chỉ định các loại tệp mà Nginx sẽ nén (thường là tệp văn bản như HTML, CSS, JavaScript). Lưu ý: /text/css có thể là lỗi đánh máy, thường là text/css.
		- gzip_min_length 500;: Chỉ nén các tệp có kích thước từ 500 byte trở lên để tối ưu hiệu suất.
	- Cấu hình bật nén Gzip trong apache2, bạn cần thêm cấu hình sau vào tệp .htaccess hoặc tệp cấu hình máy chủ của mình:
		```
		<IfModule mod_deflate.c>
			# Enable Gzip compression for specific file types
			AddOutputFilterByType DEFLATE text/html text/plain text/xml text/css text/javascript application/javascript
		</IfModule>
		```
			- <IfModule mod_deflate.c>: Đảm bảo rằng cấu hình chỉ hoạt động nếu module mod_deflate được bật.
			- AddOutputFilterByType DEFLATE ...: Chỉ thị chính yêu cầu Apache nén (DEFLATE) các tệp có định dạng như HTML, văn bản thuần túy, XML, CSS và JavaScript trước khi gửi tới trình duyệt.
	- Trong IIS, nén được bật thông qua IIS Manager:
		- Mở IIS Manager.
		- Chọn máy chủ hoặc website, sau đó điều hướng đến Compression (Nén).
		- Bật Static (Tĩnh) và Dynamic Content Compression (Nén nội dung động) bằng cách đánh dấu vào các ô tương ứng.
		
### 4.4.2 CDN
- Content Delivery Network là mạng lưới máy chủ lưu trữ bản sao của các nội dung tĩnh bên trong website và phân phối đến các máy chủ PoP (Points of Presence).
- Thông qua CDN, bản sao nội dung trên server gần nhất sẽ được trả về cho người dùng khi họ truy cập website.
- ![images](./images/cdn.webp)
- Một mạng phân phối nội dung (CDN) hoạt động dựa trên ba loại máy chủ chính:
	- Máy chủ gốc (Origin servers): Chứa phiên bản gốc của nội dung, là nguồn dữ liệu chính. Mọi thay đổi đều được thực hiện tại đây.
	- Máy chủ biên (Edge servers): Đặt ở nhiều vị trí địa lý (PoPs), lưu trữ bản sao nội dung từ máy chủ gốc. Chúng phục vụ nội dung cho người dùng gần nhất, và yêu cầu cập nhật từ máy chủ gốc khi cần.
	- Máy chủ DNS (DNS servers): Theo dõi và cung cấp địa chỉ IP cho cả máy chủ gốc và máy chủ biên, giúp client được chuyển hướng đến máy chủ biên gần nhất để tải nội dung nhanh hơn.
- CDN thực hiện hai chức năng chính để tối ưu hóa trải nghiệm người dùng: 
	- Giảm độ trễ: CDN giảm khoảng cách vật lý mà nội dung cần di chuyển, phục vụ dữ liệu từ máy chủ gần người dùng nhất để tải trang nhanh hơn.
	- Cân bằng tải: CDN phân phối lưu lượng truy cập giữa nhiều máy chủ, tránh tình trạng quá tải và đảm bảo nội dung luôn sẵn sàng, ổn định ngay cả khi có lượng truy cập cao.
- Các loại CDN
	- CDN Công cộng (Public CDNs): Mạng lưới máy chủ toàn cầu, cung cấp nội dung tĩnh (ảnh, video) cho mọi người dùng trực tuyến. Ví dụ: Cloudflare, Akamai.
	- CDN Riêng tư (Private CDNs): CDN do một công ty/tổ chức sử dụng riêng, phân phối nội dung cho người dùng hoặc khách hàng nội bộ. Ví dụ: Google Cloud CDN (dùng nội bộ), Netflix Open Connect.
	- CDN Ngang hàng (P2P CDNs): Sử dụng công nghệ peer-to-peer để phân phối nội dung trực tiếp giữa các người dùng, giảm phụ thuộc vào máy chủ trung tâm. Ví dụ: BitTorrent.
	- CDN Kết hợp (Hybrid CDNs): Kết hợp giữa CDN công cộng và riêng tư, tối ưu phân phối dựa trên chi phí, hiệu suất, bảo mật. Ví dụ: Microsoft Azure CDN.
	- CDN Đẩy (Push CDNs): Nội dung được tải lên trước các máy chủ CDN. Phù hợp cho tệp lớn, ít cập nhật. Ví dụ: KeyCDN.
	- CDN Kéo (Pull CDNs): Nội dung được yêu cầu (kéo) từ máy chủ CDN khi cần. Hiệu quả cho nội dung cập nhật thường xuyên, động. Ví dụ: Amazon CloudFront, Cloudflare.
- Quy trình từng bước hoạt động của CDN 
- ![images](./images/cdn-1.webp)
	- Người dùng gửi yêu cầu: Một người dùng gửi yêu cầu truy cập nội dung (ví dụ: một hình ảnh) từ một trang web.
	- CDN định vị và định tuyến: CDN xác định vị trí của người dùng và chuyển hướng yêu cầu đến máy chủ biên (edge server) gần nhất.
	- Kiểm tra bộ nhớ đệm (cache):
		- Nếu nội dung đã được lưu trong bộ nhớ đệm tại máy chủ biên, nó sẽ được gửi trực tiếp đến người dùng.
		- Nếu nội dung chưa có trong bộ nhớ đệm, máy chủ biên sẽ truy xuất nội dung đó từ máy chủ gốc (origin server), lưu vào bộ nhớ đệm cục bộ, rồi gửi đến người dùng.
	- Lưu trữ để sử dụng sau: Nội dung đã được lưu vào bộ nhớ đệm tại máy chủ biên sẽ được giữ lại cho các yêu cầu tiếp theo, tối ưu hóa hiệu suất và giảm độ trễ.
- Lợi ích của CDN
	- Giảm thời gian tải trang: Phục vụ nội dung từ máy chủ gần người dùng nhất, giúp tải trang nhanh hơn.
	- Giảm chi phí băng thông: Lưu trữ và phân phối nội dung, giảm tải cho máy chủ gốc và tiết kiệm chi phí.
	- Tăng khả năng cung cấp nội dung: Xử lý lượng truy cập lớn và đảm bảo dịch vụ không gián đoạn ngay cả khi có lỗi máy chủ.
	- Cải thiện bảo mật website: Phân tán lưu lượng tấn công DDoS, bảo vệ máy chủ gốc.
- Thách thức khi dùng CDN
	- Triển khai phức tạp: Khó khăn trong việc xác định nguồn nội dung và phân phối tới nhiều hệ thống lưu trữ, dễ gặp lỗi cấu hình ban đầu.
	- Chênh lệch nội dung khu vực: Đôi khi nội dung không đồng nhất giữa các máy chủ CDN ở các khu vực khác nhau.
	- Quản lý phiên bản và bộ đệm (cache): Việc cập nhật nội dung tĩnh và triển khai phiên bản mới có thể rắc rối.
	- Kiểm thử: Đảm bảo CDN hoạt động đúng như mong đợi đòi hỏi quá trình kiểm thử kỹ lưỡng.
	- Bảo mật: Bảo vệ nội dung khỏi truy cập trái phép hoặc giả mạo khi dùng CDN vẫn là một thách thức.
	- Khả năng phục hồi: Duy trì tính sẵn sàng và ổn định cao khi có sự cố mạng hoặc hạ tầng.
- Các nhà cung cấp CDN:
	- Cloudflare: Phổ biến, có cả gói miễn phí và trả phí, nổi tiếng về bảo mật và hiệu suất.
	- Akamai: Một trong những nhà cung cấp CDN lớn và lâu đời nhất, phục vụ các doanh nghiệp lớn.
	- Amazon CloudFront: Dịch vụ CDN của AWS, tích hợp tốt với các dịch vụ AWS khác.
	- Google Cloud CDN: Tương tự CloudFront, dịch vụ CDN của Google Cloud.
### 4.4.3 HTTP/2 
- HTTP/2 là phiên bản lớn thứ hai của HTTP – giao thức mạng cấp ứng dụng quy định cách nội dung được truyền tải qua internet.
- Ra mắt vào năm 2015, HTTP/2 thay thế HTTP/1.1 với mục tiêu chính là tăng tốc độ phân phối nội dung.
- Tính năng chính giúp HTTP/2 tăng tốc là Stream Multiplexing: tạo một kết nối duy nhất cho mọi loại dữ liệu và truyền dữ liệu song song.
- Ngoài ra, HTTP/2 còn tăng tốc hơn nữa nhờ:
	- Nén tiêu đề (Header Compression).
	- Ưu tiên luồng (Stream Prioritization).
	- Sử dụng tính năng Server Push.
- Khác với HTTP/1.1, HTTP/2 là giao thức nhị phân, điều này cũng giúp nó hiệu quả hơn.
- Cấu hình enable HTTP/2 trên các webserver phổ biến: Nginx Apache IIS 
- Nginx: 
	- Để bật HTTP/2 trong Nginx, chúng ta cần thêm tham số http2 vào chỉ thị listen trong cấu hình virtual host: Ví dụ file cấu hình mẫu: 
	```
	listen 443 ssl http2;
	```
	```
	server {
	  listen 443 ssl http2;
	  listen [::]:443 ssl http2;

	  server_name example.com;
	  root /path/to/public;

	  ssl_certificate /path/to/certificate.crt;
	  ssl_certificate_key /path/to/private.key;

	  ssl_protocols TLSv1.2;

	}
	```
	- Reload Nginx để apply 
	```
	sudo systemctl reload nginx.service
	```
- Apache2 
	- Disable mpm_prefork và Enable MPM_EVENT trong Apache2 
	```
	sudo a2dismod mpm_prefork
	sudo a2enmod mpm_event
	sudo systemctl restart apache2
	```
	- Enable Module HTTP2
	```
	sudo a2enmod http2
	```
	- Sửa cấu hình virtual host thêm thông số và ngay dưới phần thẻ `<VirtualHost *:443>`
	```
	Protocols h2 http/1.1
	H2Direct on
	```
	```
	  <VirtualHost _default_:443>
		Protocols h2 h2c http/1.1
		H2Direct on
	  </VirtualHost>
	```
	- Reload Apache để apply 
	```
	sudo systemctl restart apache2
	```
- IIS: Mặc định HTTP/2 sẽ được enable khi enable HTTPS và cấu hình chứng chỉ SSL cho website 
	
### 4.5 Tuning thông số: Max connections, keep-alive, worker processes.
- Tuning thông số nhằm để tối ưu hóa hiệu suất cho Webserver. Tăng khả năng phục vụ request, giảm độ trễ, tăng tính ổn định, tối ưu sử dụng tài nguyên (CPU, RAM).
- Không có "thông số vàng" áp dụng cho mọi trường hợp. Cần thử nghiệm, theo dõi (monitoring) và điều chỉnh lặp đi lặp lại.

#### 4.5.1 Max Connections
- Đây là giới hạn số lượng kết nối đồng thời mà một webserver có thể xử lý tại một thời điểm. Khi đạt đến giới hạn này, các yêu cầu mới có thể bị từ chối hoặc phải xếp hàng chờ, dẫn đến trải nghiệm người dùng kém.
- Tác động:
	- Quá thấp: Khi lưu lượng truy cập cao, server dễ bị từ chối kết nối (Connection refused), người dùng không thể truy cập trang.
	- Quá cao: Có thể gây quá tải RAM (mỗi kết nối/tiến trình/luồng tiêu tốn RAM), dẫn đến việc sử dụng ổ cứng làm RAM ảo (swapping), làm chậm server nghiêm trọng hoặc thậm chí gây sập.
- Cách tối ưu:
	- Ước tính tài nguyên: Tính toán lượng RAM mà mỗi kết nối/tiến trình tiêu thụ và so sánh với tổng RAM khả dụng của server. Luôn để lại một phần RAM trống cho hệ điều hành và các dịch vụ khác.
	- Giám sát: Sử dụng các công cụ giám sát (như htop, free -m trên Linux) để theo dõi mức tiêu thụ RAM và CPU trong giờ cao điểm.
	- Bắt đầu thận trọng: Đặt một giá trị an toàn, sau đó tăng dần và theo dõi phản ứng của server.
- Ví dụ tuning max connections 
	- Apache2 : 
		- Chỉnh sửa file cấu hinh `/etc/apache2/mods-available/mpm-prefolk.conf`
		```
		nano /etc/apache2/mods-available/mpm-prefolk.conf
		```
		- Cấu hình các thông số 
			```
			<IfModule mpm_prefork_module>
					StartServers               5
					MinSpareServers            5
					MaxSpareServers           10
					MaxRequestWorkers        150
					MaxConnectionsPerChild     0
			</IfModule>
			```
			- StartServers 5: Khởi động 5 tiến trình Apache khi server bật.
			- MinSpareServers 5: Duy trì ít nhất 5 tiến trình "rảnh rỗi" để xử lý yêu cầu mới nhanh chóng.
			- MaxSpareServers 10: Giới hạn tối đa 10 tiến trình "rảnh rỗi".
			- MaxRequestWorkers 150: Tổng số tiến trình tối đa mà Apache có thể tạo để xử lý yêu cầu đồng thời (giới hạn quan trọng nhất).
			- MaxConnectionsPerChild 0: Mỗi tiến trình con xử lý không giới hạn số yêu cầu trước khi được khởi tạo lại.
		- Restart để apply cấu hình 
		```
		systemctl restart apache2 
		```
	- Nginx :
		- Chỉnh sửa file cấu hình 
		```
		sudo nano /etc/nginx/nginx.conf
		```
		- Tuning thông số worker_connections đây chính là thông số cấu hình số kết nối đồng thời trong Nginx
		```
		worker_connections 10240;
		```
		- Reload Nginx để apply 
		```
		sudo systemctl reload nginx.service
		```
	- IIS: 
		- Trong IIS tại tab Connections chọn Sites cần cấu hình, Click chọn `Set Web Site Defaults... ` trong tab `Action` bên phải 
		- Tại đây điều chỉnh thông số `maxConnections` thiết lập này chỉ định số lượng kết nối tối đa cho một trang web. 
#### 4.5.2  Keep-alive
- Keep-Alive là một tính năng của máy chủ web cho phép phân nhánh các yêu cầu HTTP thông qua một kết nối TCP duy nhất. Điều này có nghĩa là thay vì mở một luồng mới cho mỗi yêu cầu, máy chủ web sẽ gửi chúng qua một luồng duy nhất, giúp tăng đáng kể thời gian phân phối và cải thiện tốc độ tải của trang web.
- ![images](./images/ka.png)
- Theo mặc định, các kết nối HTTP đóng sau mỗi yêu cầu, buộc trình duyệt phải tạo kết nối mới cho từng tệp (ảnh, JS, CSS), làm tăng thời gian tải trang và gây ra trải nghiệm kém.
- Để khắc phục, cần enable Keep-Alive. Khi bật, client có thể tải toàn bộ nội dung (JavaScript, CSS, hình ảnh, video) qua một kết nối TCP duy nhất, thay vì tạo nhiều yêu cầu riêng biệt, giúp tăng tốc độ tải trang đáng kể.
- Các lợi ích của Keep-Alive:
	- Tiết kiệm tài nguyên mạng: Việc sử dụng một kết nối duy nhất cho mỗi client sẽ ít gây tốn kém tài nguyên mạng hơn.
	- Giảm tắc nghẽn mạng: Giảm số lượng kết nối TCP giữa máy chủ và client có thể dẫn đến giảm tắc nghẽn mạng.
	- Giảm độ trễ: Giảm số lần bắt tay ba bước (three-way handshakes) có thể cải thiện độ trễ của trang web. Điều này đặc biệt đúng với các kết nối SSL/TLS, vốn yêu cầu thêm các vòng truyền tải để mã hóa và xác minh kết nối.
- Ví dụ cấu hình keep-alive 
	- Apache 
		- Mở file cấu hình, chỉnh sửa thông số 
		```
		sudo nano /etc/apache2/apache2.conf
		```
		- Cấu hình các thông số Keep-Alive trong Apache như sau:
			- KeepAlive On: Bật tính năng Keep-Alive để cho phép nhiều yêu cầu trên một kết nối duy nhất.
			- MaxKeepAliveRequests: Đặt số lượng yêu cầu tối đa trên một kết nối Keep-Alive. Mặc định là 100, có thể tăng tùy theo số lượng người dùng truy cập web. Tránh đặt 0 (không giới hạn).
			- KeepAliveTimeout: Thời gian để mở một kết nối keepalive. 
		- Reload Apache để apply 
			```
			sudo systemctl restart apache2
			```
	- Nginx 
		- Cấu hình keep-alive trong file 
		```
		sudo nano /etc/nginx/nginx.conf
		```
		- Enable Keepalive Connections cho Client: 
			```
			http {
				  keepalive_timeout 60s;
				  keepalive_requests 1000;
			}
			```
			- keepalive_timeout 60s;: Giữ kết nối mở trong 60 giây nếu không có yêu cầu mới.
			- keepalive_requests 1000;: Cho phép 1000 yêu cầu qua cùng một kết nối trước khi đóng.
		- Enable Keepalive Connections cho Upstream 
			```
			upstream Demo_upstream {
				keepalive 10;
			}
			```
			- keepalive 10; kết nối duy trì trong 10s
		- Reload Nginx để apply 
			```
			sudo systemctl reload nginx.service
			```
	- IIS
		- Trong IIS Manager tại tab Connections chọn sites cần cấu hình. Tại Home pane chọn `HTTP Response Headers`
		- Trong tab Actions chọn Set Common Headers.... Tích chọn enable HTTP keep-alives và chọn OK 
		- Ngoài ra có thể enable bằng lệnh `appcmd set config /section:httpProtocol /allowKeepAlive:true`
####  4.5.3  Worker processes
- NGINX có thể chạy nhiều tiến trình worker, mỗi tiến trình có khả năng xử lý số lượng lớn các kết nối đồng thời. Bạn có thể kiếm soát số lượng tiến trình worker và cách chúng xử lý các kết nối:
	- worker_processes: Số lượng tiến trình worker (mặc định là 1). Trong hấu hết các trường hợp, việc chạy 1 tiến trình trên mỗi lõi CPU đảm bảo hệ thống hoạt động tốt. Nhưng đôi khi bạn muốn tăng số lượng này, chẳng hạn như khi các tiến trình worker phải thực hiện nhiều đĩa I/O.
	- worker_connections: Đây là số lượng kết nối tối đa mà woker có thể đồng thời xử lý. Mặc ddingj là 512, nhưng hầy hết các hệ thống có đủ tài nguyên để hỗ trợ số lượng lớn hơn. Cài đặt tùy thuộc vào kích thước server và lượng truy cập thực tế.
	- Chỉnh sửa các thông số này trong `/etc/nginx/nginx.conf` 
- Với Apache, việc cấu hình worker processes phụ thuộc vào Multi-Processing Module (MPM) mà bạn đang sử dụng.
	- Cấu hình các thông số liên quan của Apache tại `/etc/apache2/mods-available/` `prefork.conf` hoặc `worker.conf`
- Với IIS thực hiện thay đổi `Maximum Worker Processes` tại phần `Advanced settings` trong panel `Application Pools`
	
## 5. Bảo mật Web Server
### 5.1 Phòng chống DDoS, brute force.	
- Tấn công DoS nhằm làm ngừng hoạt động trang web hoặc máy chủ bằng cách làm quá tải nó với lưu lượng truy cập rác từ một nguồn duy nhất. Mục tiêu là khiến dịch vụ không thể truy cập được cho người dùng hợp lệ.
- Tấn công DDoS tương tự DoS nhưng sử dụng nhiều nguồn (thiết bị hoặc botnet) để làm quá tải máy chủ. 
- Tấn công brute-force là kiểu đoán mật khẩu hoặc thông tin đăng nhập bằng cách thử mọi kết hợp có thể.
- Một số chiến lược hiệu quả chống lại các cuộc tấn công DDOS:
	+ Cấu hình các bộ lọc block những traffic từ nguồn lạ 
	+ Sử dụng CDN 
	+ Sử dụng các tường lửa ứng dụng web WAF như mod-security
	+ Cấu hình hệ thống loadbalancing
	+ Giám sát hệ thống đặt các alert khi lưu lượng tăng bất thường nhằm kịp thời ứng phó.
- Một số chiến lược hiệu quả chống lại các cuộc tấn công Brute Force: 
	+ Sử dụng tường lửa: Windows Firewall nếu triển khai trên IIS, CSF Firewall, ...
	+ Sử dụng mật khẩu mạnh >8 ký tự và có sự kết hợp giữa chữ, số, ký tự đặc biệt.
	+ Giám sát hệ thống: Ví dụ đặt ngưỡng cảnh  báo khi có sự gia tăng bất thường sự kiện đăng ngập không rõ ràng để phát hiện và xử lý kịp thời. 
	+ Thiết lập xác minh 2 bước: Đối với các webserver có các dịch vụ tài khoản triển khai xác minh 2 bước, bắt buộc cần có mã xác minh lớp thứ 2 mới cho phép đăng nhập.
	+ Sử dụng captcha: Captcha là những câu hỏi bảo mật giúp xác minh yếu tố con người. Captcha giúp chặn được một số lượng các request ảo từ đó giúp ngăn chặn tấn công.
	+ Thiết lập các chính sách giới hạn đăng nhập: Khoá người dùng không cho đăng nhập sau một vài lần đăng nhập không thành công.
### 5.2 Cấu hình firewall (iptables, Cloudflare).
#### 5.2.1 iptables 
- Cấu hình iptables bảo mật cho máy chủ web thường sẽ chặn tất cả lưu lượng truy cập đến ngoại trừ các dịch vụ cần thiết như HTTP, HTTPS và SSH. Cho phép các kết nối đã được thiết lập và giới hạn lưu lượng truy cập đi.
- Các rules và policy iptables 
	- Thiết lập chính sách mặc định DROP INPUT và FORWARD, ACCEPT cho OUTPUT 
	```
	iptables -P INPUT DROP
	iptables -P FORWARD DROP
	iptables -P OUTPUT ACCEPT
	```
	- Chỉ cho phép các kết nối cần thiết SSH, HTTP, HTTPS 
	```
	iptables -A INPUT -i lo -j ACCEPT
	iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
	iptables -A INPUT -p tcp --dport 22 -j ACCEPT
	iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT
	```
	- Lưu cấu hình 
	```
	iptables-persistent
	```
#### 5.2.2 Cloudflare
- Enable SSL/TLS : Cloudflare cung cấp miễn phí chứng chỉ SSL/TLS cấu hình tại tab SSL/TLS ở Dashboard quản lý tên miền.
- ![images](./images/ssl.webp)
- Under Attack Mode: Chế độ khẩn cấp ngăn chặn DDos. Enable ngay tại Dashboard mặc định của Cloudflare. Ở chế độ này mọi client truy cập qua tên miền đều sẽ được đưa tới trang kiểm tra mất khoảng 5s mới tiếp tục xử lý tới webserver 
- ![images](./images/cloudflare_enable_uam.png)
- Cloudflare hỗ trợ các rules để lọc truy cập nằm trong phần Security. Tại đây có thể tuỳ chỉnh thêm các rules như: Chặn truy cập theo quốc gia, Bật xác nhận captcha, ...
	- Chặn truy cập theo quốc gia: Giới hạn chỉ cho phép truy cập từ IP VietNam. Cấu hình tại: Security -> Rules.
	- ![images](./images/cloud-1.png)
	- Bật xác nhận Capcha trong TH bị tấn công từ IP trong nước enable challenge để lọc người dùng/botnet 
	- ![images](./images/cloud-1.png)

### 5.3 Hardening server (tắt dịch vụ không cần thiết, cập nhật bảo mật).
- Tăng cường bảo mật máy chủ (Server hardening) là một quá trình gia cố hệ thống nhằm bảo vệ và đảm bảo an toàn cho hạ tầng máy chủ trước các cuộc tấn công mạng bằng cách giảm thiểu tấn công bề mặt.
- Tấn công bề mặt bao gồm tất cả các điểm có thể bị khai thác trong hệ thống mà kẻ tấn công trái phép có thể lợi dụng để xâm nhập.
- Việc giảm thiểu số lượng các điểm dễ bị tấn công này giúp "gia cố" máy chủ, khiến việc khai thác trở nên khó khăn hơn và từ đó nâng cao mức độ an toàn của dữ liệu.
- Để tăng cường bảo mật cho web server cần: 
	- Gỡ bỏ tất cả các mô-đun không cần thiết của web server. Nhiều web server mặc định đi kèm với nhiều mô-đun có thể gây ra rủi ro bảo mật.
	- Chỉnh sửa các thiết lập cấu hình mặc định. Ví dụ: nhiều web server mặc định hỗ trợ các giao thức SSL/TLS cũ, điều này khiến máy chủ dễ bị tấn công.
	- Bật các biện pháp bảo vệ bổ sung cho ứng dụng web. Ví dụ: thiết lập Content Security Policy (CSP) để kiểm soát nguồn nội dung được tải.
	- Cài đặt và chạy tường lửa ứng dụng web (WAF). Hầu hết các web server đều hỗ trợ ModSecurity, một firewall mã nguồn mở.
	- Nếu có thể, hãy cập nhật phần mềm máy chủ lên phiên bản mới nhất một cách tự động, hoặc bật thông báo để thực hiện cập nhật thủ công khi có bản vá bảo mật mới.
#### 5.3.1 Apache Hardening
- Tắt không hiển thị thông tin phiên bản webserver 
	- Mở file cấu hình apache `/etc/apache2/apache2.conf` thêm các dòng cấu hình. 
	```
	nano /etc/apache2/apache2.conf
	```
	```
	ServerTokens Prod
	ServerSignature Off
	```
	- Restart apache2 để áp dụng. 
	```
	systemctl restart apache2
	```
- Tắt list thư mục ở Apache 
	- Mở file cấu hình apache `/etc/apache2/apache2.conf` tìm tới thuộc tính `Directory` 
	- Thêm `-Indexes` cho parameter `Options`
	```
	<Directory /var/www/>
		Options -Indexes
	</Directory>
	```
	- ![images](./images/apa.png)
	- Restart apache2 để áp dụng. 
	```
	systemctl restart apache2
	```
- Tắt các module không cần thiết 
	- Xem tất cả các module đã enable trong apache 
	```
	apache2ctl -M
	```
	- ![images](./images/apa-1.png)
	- Kiểm tra chỉ giữ lại các module cần thiết, disable các module không liên quan bằng lệnh 
	```
	sudo a2dismod [tên-module]
	```
-  Hạn chế các dịch vụ không cần thiết
	- Vô hiệu hóa một số dịch vụ như liên kết tượng trưng (symbolic links) và thực thi CGI nếu hiện tại không cần thiết sử dụng.
	- Mở file cấu hình apache `/etc/apache2/apache2.conf` tìm tới thuộc tính `Directory` 
	- Thêm thuộc tính `-ExecCGI -FollowSymLinks -Includes` cho parameter `Options` 
	```
	<Directory /var/www/>
		Options -ExecCGI -FollowSymLinks -Includes
	</Directory>
	```
	- Restart apache2 để áp dụng. 
	```
	systemctl restart apache2
	```
- Cập nhật Apache thường xuyên
	- Việc giữ cho tất cả các ứng dụng luôn được cập nhật là điều luôn được khuyến nghị, bởi vì các phiên bản mới thường đi kèm với bản vá lỗi và cập nhật bảo mật, giúp khắc phục các lỗ hổng tiềm ẩn tồn tại trong các phiên bản cũ.
	```
	sudo apt update && sudo apt upgrade -y 
	```
	
#### 5.3.2 Nginx Hardening
- Tắt nginx server_tokens
	- Chỉnh sửa trong block http tại file cấu hình chính `/etc/nginx/nginx.conf`
	```
	server_tokens off;
	```
- Vô hiệu hoá các module không cần thiết 
	- Khi cài đặt NGINX, nhiều mô-đun sẽ được tích hợp sẵn theo mặc định. Hiện tại, không thể bật hoặc tắt các mô-đun này khi NGINX đang chạy. Để vô hiệu hóa một số mô-đun cụ thể, cần biên dịch lại NGINX từ mã nguồn.
	- Kiểm tra các module đã được cài 
	```
	nginx -V
	```
	- Để disable bất kỳ module nào có trong danh sách trên, cần phải stop Nginx và tiến hành recompile không bao gồm module đó. Ví dụ vô hiệu hoá `http_autoindex_module`
	```
	# ./configure --without-http_autoindex_module
	# make
	# make install
	```
- Kiểm soát và giới hạn resource: 
	- Để bảo vệ Nginx khỏi các cuộc tấn công DoS (hoặc DDoS), cần phải giới hạn lại các cấu hình buffer size sau cho tất cả client kết nối đến webserver:
		- client_max_body_size: sử dụng tham số này để xác định kích thước tối đa được chấp nhận cho cho một request từ client.
		- client_body_buffer_size: sử dụng tham số này để chỉ định kích thước bộ đệm cho body request từ client. Giá trị mặc định là 8k hoặc 16k, nhưng khuyến nghị nên thiết lập dưới mức 1k.
		- client_header_buffer_size: sử dụng tham số này để chỉ định kích thước bộ đệm cho header của request từ client. client_header_buffer_size 1k là đủ cho hầu hết các request.
		- large_client_header_buffers: tham số này để chỉ định số lượng và kích thước tối đa của bộ đệm dùng để đọc các client request header lớn. Một large_client_header_buffers 2 1k thiết lập số lượng tối đa của buffer là 2, mỗi buffer có kích thước tối đa là 1k. Do đó, cấu hình này sẽ chấp nhận 2 kB data URI.
	- ![images](./images/nginx_resouce_limit.webp)
	- Các cấu hình trên được cấu hình trong cấu hình chính của Nginx (/etc/nginx/nginx.conf) 
- Cấu hình SSL và Cipher Suites 
	- Theo mặc định, nginx chấp nhận sử dụng các giao thức SSL phiên bản cũ (tính bảo mật yếu) như: TLS 1.0, TLS 1.1. Điều này có thể dẫn đến bị tấn công.
	- Cần điều chỉnh bỏ các giao thức cũ thay bằng các giao thức mới hơn. Chỉnh sửa trong file cấu hình chính của nginx 
	```
	ssl_protocols TLSv1.2 TLSv1.3;
	```
	- Các Cipher Suites yếu có thể dẫn đến lỗ hổng, theo khuyến nghị chúng ta phải đảm bảo chỉ cho phép sử dụng những bộ mã hóa mạnh và mới.
	- Thêm hoặc cập nhật giá trị của dòng sau trong block server của file cấu hình nginx:
	```
	ssl_ciphers "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA HIGH !RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !SSLv2 !SSLv3";
	```
- Giới hạn tốc độ yêu cầu (Rate Limiting)
	- Giới hạn số lượng yêu cầu là một biện pháp hiệu quả để giảm thiểu các cuộc tấn công brute-force (tấn công dò mật khẩu) và giảm ảnh hưởng từ các cuộc tấn công DoS/DDoS.
	- Cấu hình `limit_req_zone` và `limit_req` trong file cấu hình nginx block http 
	```
	limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;
	```
	- Giới hạn 10 request/giây mỗi IP
		- $binary_remote_addr: dùng IP làm khóa.
		- zone=mylimit:10m: tạo vùng nhớ 10MB tên mylimit.
		- rate=10r/s: cho phép tối đa 10 yêu cầu/giây mỗi IP.
- Cập nhật nginx thường xuyên
	```
	sudo apt update && sudo apt upgrade -y 
	```	
	
#### 5.3.3 IIS Hardening
- IIS gồm nhiều module tích hợp, cấu hình chỉ enable các module cần thiết 
	- Mở IIS Manager.
	- Chọn Server trong cửa sổ bên trái.
	- Vào Modules trong phần Features View.
	- Liệt kê và vô hiệu hóa các mô-đun không cần thiết.
	- ![images](./images/ii.png)
- Tắt phương thức OPTIONS 
	- Phương thức OPTIONS cung cấp danh sách các phương thức được hỗ trợ bởi máy chủ web. Mặc dù điều này có thể có vẻ hữu ích, nhưng nó cũng cung cấp thông tin quan trọng cho kẻ tấn công trong giai đoạn thu thập thông tin (reconnaissance). Do đó, chúng tôi khuyến nghị tắt hoàn toàn phương thức OPTIONS.
	- Điều này có thể thực hiện bằng cách từ chối phương thức OPTIONS trong các quy tắc lọc yêu cầu HTTP verb trên IIS.
	- Các bước thực hiện:
		- Mở IIS Manager.
		- Chọn tên máy chủ để cấu hình.
		- Nhấn đúp vào Request Filtering.
		- Chuyển sang tab HTTP Verbs.
		- Trong Action pane, chọn Deny Verb.
		- Nhập OPTIONS vào trường Verb và nhấn OK để lưu thay đổi.	
	- ![images](./images/ii-1.png)
- Kích hoạt Giới hạn Địa chỉ IP Động
	- Mô-đun Dynamic IP Restrictions giúp chặn truy cập từ các địa chỉ IP vượt quá số lượng yêu cầu nhất định, qua đó giúp ngăn chặn các cuộc tấn công từ chối dịch vụ (DoS). Mô-đun này sẽ kiểm tra địa chỉ IP của mỗi yêu cầu gửi đến máy chủ web và lọc các yêu cầu này, nhằm tạm thời từ chối các địa chỉ IP có hành vi tấn công theo một mẫu cụ thể.
	- Mô-đun Dynamic IP Restrictions có thể được cấu hình để chặn các địa chỉ IP sau khi vượt quá một số yêu cầu đồng thời, hoặc chặn các IP có số lượng yêu cầu vượt mức trong một khoảng thời gian nhất định.
	- Để sử dụng cần enable trong Roles & Features phần Web Server -> Security 
	- ![images](./images/ii-2.png)	
	- Cấu hình sử dụng trong IIS 
		- Mở IIS Manager.
		- Chọn máy chủ hoặc trang web cần cấu hình.
		- Trong mục IIS, nhấn đúp vào Dynamic IP Restrictions.
		- Trong cửa sổ cấu hình, bạn có thể thiết lập các giới hạn:
		- Request Thresholds: Số yêu cầu tối đa trong một khoảng thời gian nhất định.
		- IP Blocking: Thời gian chặn đối với các IP bị tấn công.
	- ![images](./images/ii-3.png)	

- Kích hoạt và Cấu hình Các Quy Tắc Lọc Yêu Cầu (Request Filtering) 
	- Thiết lập rule ngăn chặn yêu cầu độc hại không được truyền vào máy chủ.
	- Ví dụ lọc các yêu cầu tấn công SQL Injection
		- Mở IIS Manager.
		- Chọn máy chủ để cấu hình điều này toàn cục (hoặc chọn trang web cụ thể nếu bạn muốn áp dụng cho một web).
		- Nhấn đúp vào Request Filtering.
		- Chuyển sang tab Rules.
		- Trong Action pane, chọn Add Filtering Rule.
		- Thiết lập các quy tắc cần thiết và nhấn OK để lưu thay đổi.
	- ![images](./images/ii-4.png)	
- Cập nhật IIS và Windows Server thường xuyên 
	-  luôn cập nhật các bản cập nhật mới nhất và các bản vá bảo mật. Phần lớn các cuộc tấn công vào máy chủ web xảy ra trên các máy chủ không được vá. Điều này chứng tỏ tầm quan trọng của việc luôn giữ cho hệ điều hành Microsoft Windows và máy chủ web IIS luôn được cập nhật.

### 5.4 Xử lý các lỗ hổng (SQL injection, XSS, CSRF).
#### 5.4.1 SQL injection
- SQL Injection (SQLi) là một hình thức tấn công bảo mật trong đó kẻ tấn công chèn các câu lệnh SQL độc hại vào các input (thường là URL, form) để thao túng cơ sở dữ liệu như:
	* Đăng nhập trái phép
	* Truy xuất dữ liệu nhạy cảm
	* Xoá hoặc sửa dữ liệu
- Ví dụ SQL Injection
	Giả sử website có URL:
	```
	http://example.com/login.php?user=admin
	```
	Kẻ tấn công có thể sửa thành:
	```
	http://example.com/login.php?user=admin' OR '1'='1
	```
	Nếu ứng dụng không kiểm soát input, câu lệnh SQL phía sau có thể trở thành:
	```
	SELECT * FROM users WHERE username = 'admin' OR '1'='1';
	```
	→ Điều này trả về toàn bộ bảng `users` vì điều kiện `1=1` luôn đúng.
- Xử lý SQLi ở mức Web Server:
	* Cấu hình tường lửa ứng dụng Web (WAF) để chặn chuỗi SQL độc hại.
	* Giới hạn truy cập các chuỗi nghi vấn qua URL, query string.
	* Giám sát và ghi log để phát hiện dấu hiệu tấn công.
- Cấu hình chi tiết:
	- Apache 
		– Sử dụng ModSecurity + OWASP CRS
		```
		sudo apt update
		sudo apt install libapache2-mod-security2
		sudo a2enmod security2
		sudo systemctl restart apache2
		```
		- Chỉnh sửa file cấu hình: `/etc/modsecurity/modsecurity.conf`
		```
		SecRuleEngine On
		```
		- Tích hợp OWASP CRS:
		```
		cd /etc
		sudo git clone https://github.com/coreruleset/coreruleset.git modsecurity-crs
		cd modsecurity-crs
		sudo cp crs-setup.conf.example crs-setup.conf
		```
		- Trong vhost cấu hình:
		```
		<IfModule security2_module>
			Include /etc/modsecurity-crs/crs-setup.conf
			Include /etc/modsecurity-crs/rules/*.conf
		</IfModule>
		```
	- Nginx sử dụng NAXSI hoặc cấu hình thủ công 
		- Ví dụ dùng NAXSI: Để sử dụng được NAXSI cần compile Nginx với NAXSI. 
			- Thực hiện tải source Nginx, NAXSI, giải nén, thêm module NAXSI `–add-module=/root/naxsi-master/naxsi_src/ –sbin-path=/usr/sbin/nginx` trong khi build NGINX 
			- Sau khi đã buid và cài đặt xong thực hiện cấu hình 
			- Copy file core của NAXSI vào thư mục chứa Nginx
			```
			cp /root/naxsi-master/naxsi_config/naxsi_core.rules /etc/nginx/
			```
			- Tạo file cấu hình 
				```
				nano /etc/nginx/naxsi.rules
				```
				```
				SecRulesEnabled;
				DeniedUrl “/block.html”;
				Check Naxsi rules
				CheckRule “$SQL >= 8” BLOCK;
				CheckRule “$RFI >= 8” BLOCK;
				CheckRule “$TRAVERSAL >= 4” BLOCK;
				CheckRule “$EVADE >= 4” BLOCK;
				CheckRule “$XSS >= 8” BLOCK;
				```
				* SecRulesEnabled : Bật NASXI Rules. Lưu ý : mọi người có thể set “LearningMode” để NASXI vào chế độ learning tự động tạo whitelist cho các traffic sạch, ở chế độ “LearningMode” thì NASXI sẽ không chặn bất cứ truy cập nào.
				* DeniedUrl : Đường link mà NASXI sẽ redirect truy cập tới khi truy cập bị block.
				* CheckRule : NASXI sẽ dựa vào các Rule được khai báo mà tiến hành các hành động cần thiết như BLOCK, DROP, LOG, ALLOW.
			- Thêm module vào config của Nginx trong file “/etc/nginx/nginx.conf” tại bên dưới HTTP block 
			```nginx
			include /etc/nginx/naxsi_core.rules;
			```
			- Trong file vhost thêm dòng sau vào block location 
			```
			include /etc/nginx/naxsi.rules;
			```
			- Khởi động lại Nginx để các cấu hình được áp dụng:
			```
			systemctl restart nginx
			```
		- Tùy chọn thủ công: Thêm bộ lọc trong block location của vhost 
		```nginx
		location / {
			if ($query_string ~* "union.*select|sleep\\([0-9]+\\)|benchmark\\(") {
				return 403;
			}
		}
		```

	- IIS – Sử dụng Request Filtering:
	- Trong “Request Filtering” → “Query Strings”:
		* Add Deny Strings: `select`, `' or '1'='1`, `union select`, `sleep(`, `benchmark(`

#### 5.4.2 XSS
- XSS (Cross-Site Scripting) là tấn công chèn mã JavaScript độc hại vào các input (form, URL…) để:
	* Đánh cắp cookie, session
	* Gài mã độc vào trình duyệt người dùng khác
- Ví dụ XSS
	```
	http://example.com/search?q=<script>alert('Hacked')</script>
	```
	- Khi server không filter, trình duyệt sẽ hiển thị popup từ mã JS đó.
- Xử lý XSS từ Web Server:
* Thêm security header: `X-XSS-Protection`, `Content-Security-Policy`
* Cấu hình WAF (ModSecurity, NAXSI)
* Chặn chuỗi nghi vấn như `<script>`, `javascript:`, `onerror=`
- Cấu hình chi tiết:
	- Apache2 
		- Bổ sung vào VirtualHost hoặc global config /etc/apache2/apache2.conf:
		```apache
		<IfModule mod_headers.c>
			Header always set X-XSS-Protection "1; mode=block"
			Header always set Content-Security-Policy "default-src 'self'; script-src 'self';"
		</IfModule>
		```

	- Nginx:
		- Thêm vào `server` hoặc `location`:

		```nginx
		add_header X-XSS-Protection "1; mode=block" always;
		add_header Content-Security-Policy "default-src 'self'; script-src 'self';" always;
		```
		- Chặn truy vấn chứa XSS:
		```nginx
		location / {
			if ($query_string ~* "<script>|javascript:|onerror=") {
				return 403;
			}
		}
		```
	- IIS:
		- Vào IIS Manager → Site → HTTP Response Headers:
		* Add:
		  * Name: `X-XSS-Protection`, Value: `1; mode=block`
		  * Name: `Content-Security-Policy`, Value: `default-src 'self'; script-src 'self';`

#### 5.4.3 CSRF
- CSRF (Cross-Site Request Forgery) là tấn công khiến người dùng (đã đăng nhập) thực hiện hành động trái phép như:
	* Gửi lệnh xoá, đổi mật khẩu, chuyển tiền…
- Xử lý CSRF từ Web Server:
	* Dùng header bảo mật để giảm thiểu rủi ro (không xử lý triệt để được nếu không có mã nguồn)
- Cấu hình 
	- Apache : Bổ sung vào VirtualHost hoặc global config /etc/apache2/apache2.conf:
		```apache
		<IfModule mod_headers.c>
			Header always set X-Frame-Options "SAMEORIGIN"
			Header always set Referrer-Policy "strict-origin"
		</IfModule>
		```
	- Nginx : Thêm vào `server` hoặc `location`
		```
		add_header X-Frame-Options "SAMEORIGIN" always;
		add_header Referrer-Policy "strict-origin" always;
		```
	- IIS – cấu hình chi tiết:
		- Vào IIS Manager → HTTP Response Headers:
		* Add:
		  * Name: `X-Frame-Options`, Value: `SAMEORIGIN`
		  * Name: `Referrer-Policy`, Value: `strict-origin`

## 6. Hiệu suất và Monitoring
### 6.1  Công cụ đo lường hiệu suất (Apache Benchmark, JMeter).
#### 6.1.1 Apache Benchmark
- Apache Bench, thường được viết tắt là ab, là một công cụ dòng lệnh đơn luồng thuộc dự án máy chủ Apache HTTP. Nó được thiết kế để thực hiện các phép đo hiệu suất trên máy chủ Hypertext Transfer Protocol (HTTP) của bạn. Bằng cách mô phỏng nhiều yêu cầu đến một máy chủ, Apache Bench đo lường khả năng xử lý tải của máy chủ.
- Apache Benchmark mang lại một số lợi thế đáng kể cho việc kiểm tra tải và hiệu suất:
	* Nhỏ gọn và Nhanh chóng: Apache Benchmark cài đặt nhanh và chiếm ít tài nguyên, giúp việc thiết lập để kiểm tra cấp tốc trở nên dễ dàng.
	* Đơn giản: Với giao diện dòng lệnh cơ bản, AB cho phép thực hiện kiểm tra ngay lập tức và thẳng thắn.
	* Kiểm soát đồng thời: Apache Benchmark cho phép người dùng cấu hình số lượng yêu cầu đồng thời, điều này rất cần thiết để mô phỏng lưu lượng truy cập trong thế giới thực.
	* Xử lý lỗi: Apache Benchmark cung cấp thông tin chi tiết về các yêu cầu không thành công, có thể làm nổi bật các giới hạn cụ thể của máy chủ.
- Cài đặt: AB được cài thông qua lệnh 
	* Ubuntu/Debian
	```
	sudo apt-get install apache2-utils 
	```
	* CentOS/RHEL
	```
	sudo yum install httpd-tools  
	```
	* Kiểm tra version bằng lệnh 
	```
	ab - V 
	```
	- ![images](./images/ab-1.png)	
- Cấu trúc lệnh 
```
ab [options] <IP hoặc Domain>:<port><path>
```
	- Trong đó `options`
	
		| Tùy chọn          | Mô tả                                                                                                |
		| ----------------- | ---------------------------------------------------------------------------------------------------- |
		| `-n requests`     | Số lượng yêu cầu cần thực hiện                                                                       |
		| `-c concurrency`  | Số lượng yêu cầu đồng thời                                                                           |
		| `-t timelimit`    | Giới hạn thời gian chạy benchmark (tính bằng giây). Tự động đặt `-n 50000`                           |
		| `-s timeout`      | Thời gian chờ tối đa cho mỗi phản hồi (mặc định: 30 giây)                                            |
		| `-b windowsize`   | Kích thước bộ đệm TCP send/receive (tính bằng byte)                                                  |
		| `-B address`      | Địa chỉ cần ràng buộc khi thực hiện kết nối ra ngoài                                                 |
		| `-p postfile`     | Tệp chứa dữ liệu POST. Nhớ sử dụng kèm `-T`                                                          |
		| `-u putfile`      | Tệp chứa dữ liệu PUT. Nhớ sử dụng kèm `-T`                                                           |
		| `-T content-type` | Kiểu nội dung dùng cho POST/PUT, ví dụ: `application/x-www-form-urlencoded` (mặc định: `text/plain`) |
		| `-v verbosity`    | Mức độ chi tiết của thông tin gỡ lỗi                                                                 |
		| `-w`              | In kết quả dưới dạng bảng HTML                                                                       |
		| `-i`              | Sử dụng phương thức HEAD thay vì GET                                                                 |
		| `-x attributes`   | Chuỗi thuộc tính chèn vào bảng HTML                                                                  |
		| `-y attributes`   | Chuỗi thuộc tính chèn vào thẻ `<tr>`                                                                 |
		| `-z attributes`   | Chuỗi thuộc tính chèn vào thẻ `<td>` hoặc `<th>`                                                     |
		| `-C attribute`    | Thêm cookie, ví dụ: `Apache=1234` (có thể lặp lại)                                                   |
		| `-H attribute`    | Thêm dòng header tùy ý, ví dụ: `Accept-Encoding: gzip` (có thể lặp lại)                              |
		| `-A attribute`    | Thêm xác thực cơ bản WWW, định dạng: `user:password`                                                 |
		| `-P attribute`    | Thêm xác thực cơ bản qua proxy, định dạng: `user:password`                                           |
		| `-X proxy:port`   | Địa chỉ proxy và cổng cần sử dụng                                                                    |
		| `-V`              | Hiển thị số phiên bản và thoát                                                                       |
		| `-k`              | Sử dụng tính năng HTTP KeepAlive                                                                     |
		| `-d`              | Không hiển thị bảng phần trăm phục vụ                                                                |
		| `-S`              | Không hiển thị ước lượng độ tin cậy và cảnh báo                                                      |
		| `-q`              | Không hiển thị tiến trình khi thực hiện trên 150 yêu cầu                                             |
		| `-l`              | Chấp nhận độ dài tài liệu thay đổi (dành cho trang động)                                             |
		| `-g filename`     | Xuất dữ liệu thu thập được sang định dạng dùng cho gnuplot                                           |
		| `-e filename`     | Xuất kết quả sang file CSV với phần trăm phục vụ                                                     |
		| `-r`              | Không thoát khi gặp lỗi nhận socket                                                                  |
		| `-m method`       | Đặt tên phương thức HTTP (GET, POST, PUT, v.v.)                                                      |
		| `-h`              | Hiển thị hướng dẫn sử dụng                                                                           |
		| `-I`              | Vô hiệu hóa phần mở rộng SNI (TLS Server Name Indication)                                            |
		| `-Z ciphersuite`  | Chỉ định bộ mã hóa SSL/TLS (xem `openssl ciphers`)                                                   |
		| `-f protocol`     | Chỉ định giao thức SSL/TLS (`SSL2`, `TLS1`, `TLS1.1`, `TLS1.2` hoặc `ALL`)                           |
		| `-E certfile`     | Chỉ định chuỗi chứng chỉ máy khách và khóa riêng (tuỳ chọn)                                          |

- Các câu lệnh ab cơ bản 
	- Yêu cầu GET đơn giản: Chạy một bài kiểm tra với 100 yêu cầu, mỗi lần 10 yêu cầu.
		```
		ab -n 100 -c 10 http://localhost:8000/api/books
		```
		- ![images](./images/ab-2.png)
	- Yêu cầu POST với dữ liệu: Nếu kiểm tra một điểm cuối (endpoint) POST, hãy chỉ định một tệp dữ liệu bằng cách sử dụng cờ -p và loại nội dung bằng -T.	
		```
		ab -n 100 -c 10 -p data.json -T application/json http://localhost:8000/api/books
		```
	- Không thoát khi có lỗi: Tùy chọn -r cho phép bài kiểm tra tiếp tục ngay cả khi có lỗi xảy ra.
		```
		ab -n 500 -c 10 -r http://localhost:8000/api/books
		```
- Apache Benchmark cung cấp thêm các cờ (flag) để tùy chỉnh các bài kiểm tra sâu hơn. Dưới đây là một số tùy chọn thường được sử dụng:
	- Header tùy chỉnh: Thêm các header tùy chỉnh, chẳng hạn như mã thông báo ủy quyền (authorization tokens), bằng cách sử dụng -H.
		```
		ab -H "Authorization: Bearer <token>" -n 100 -c 10 http://localhost:8000/api/books
		```
	- Kết nối Keep-Alive: Theo mặc định, Apache Benchmark đóng các kết nối sau mỗi yêu cầu. Bật các kết nối liên tục bằng -k.
		```
		ab -k -n 500 -c 10 http://localhost:8000/api/books
		```
	- Connection Timeout: Điều chỉnh thời gian chờ bằng -s để chỉ định khoảng thời gian AB chờ phản hồi.
		```
		ab -n 100 -c 10 -s 5 http://localhost:8000/api/books
		```
- Phân tích kết quả trả về của ab : Sau một bài kiểm tra, Apache Benchmark cung cấp một bản tóm tắt với các chỉ số quan trọng:
	* Tổng số yêu cầu: Số lượng yêu cầu đã được thực hiện.
	* Yêu cầu thất bại: Số lượng yêu cầu gặp lỗi.
	* Yêu cầu mỗi giây: Thông lượng đạt được trong quá trình kiểm tra.
	* Thời gian cho mỗi yêu cầu: Thời gian trung bình mà mỗi yêu cầu mất.
	* Tốc độ truyền tải: Lượng dữ liệu được truyền tải mỗi giây.
- Hạn chế của AB 
	* Tính thực tế hạn chế: Apache Benchmark gửi các yêu cầu nhanh nhất có thể, điều này có thể không phản ánh đúng các kiểu lưu lượng truy cập của người dùng thực.
	* Tải trọng cao trên máy kiểm thử: Chính máy dùng để kiểm tra có thể trở thành điểm nghẽn, đặc biệt nếu mức độ đồng thời được đặt quá cao.
	* Thiếu các kịch bản phức tạp: AB không hỗ trợ các giao dịch đa bước hoặc các kịch bản kiểm thử phức tạp như JMeter.

#### 6.1.2 JMeter
- Jmeter là công cụ để đo độ tải và performance của đối tượng, có thể sử dụng để test performance trên cả nguồn tĩnh và nguồn động, có thể kiểm tra độ tải và hiệu năng trên nhiều loại server khác nhau như: Web – HTTP, HTTPS, SOAP, Database via JDBC, LDAP, JMS, Mail – SMTP(S), POP3(S) và IMAP(S)…
- Jmeter là một phần mềm mã nguồn mở được viết bằng java. Cha đẻ của JMeter là Stefano Mazzocchi. Sau đó Apache đã thiết kế lại để cải tiến hơn giao diện đồ họa cho người dùng và khả năng kiểm thử hướng chức năng.
- Đặc trưng của Jmeter
	* Nguồn mở, miễn phí
	* Giao diện đơn giản, trực quan dễ sử dụng
	* Có thể kiểm thử nhiều kiểu server: Web - HTTP, HTTPS, SOAP, Database - JDBC, LDAP, JMS, Mail - POP3,…
	* Một công cụ độc lập có thể chạy trên nhiều nền tảng hệ điều hành khác nhau, trên Linux chỉ cần chạy bằng một shell scrip, trên Windows thì chỉ cần chạy một file .bat
	* Đa luồng, giúp xử lý tạo nhiều request cùng một khoảng thời gian, xử lý các dữ liệu thu được một cách hiệu quả.
	* Đặc tính mở rộng, có rất nhiều plugin được chia trẻ rộng rãi và miễn phí
- Cách thức hoạt động: Jmeter thực hiện giả lập một nhóm người dùng gửi các yêu cầu tới một máy chủ, nhận và xử lý các phản hồi từ máy chủ và cung cấp các kết quả báo cáo hiệu suất dưới dạng biểu đồ trực quan, dễ hiểu.
- Cài đặt 
	- Windows 
		* Install Java JDK: http://www.oracle.com/technetwork/java/javase/downloads/index.html
		* Set JAVA_HOME: My Computer -> Properties -> Advance System Settings -> Environment variables -> System variables -> New Variable name: JAVA_HOME Variable value: đường dẫn đến folder JDK
		* Set Path: Thêm %JAVA_HOME%\bin; vào System Path
		* Download Jmeter và giải nén ra folder C:\Jmeter: http://jmeter.apache.org/download_jmeter.cgi
		* Chạy Jmeter: Vào trong folder C:\Jmeter\bin Chạy file jmeter.bat
	- Ubuntu  
		* Install Java: `apt-get install openjdk-8-jdk -y`
		* Tải và giải nén JMeter: 
			```	
			wget https://downloads.apache.org//jmeter/binaries/apache-jmeter-5.3.zip
			unzip apache-jmeter-5.3.zip
			```
		* Khởi chạy 
			```
			cd apache-jmeter-5.3/bin
			./jmeter
			```
- Tạo test plan 
- ![images](./images/jm-1.webp)	
	- Add Thread Group
		* Khởi động JMeter
		* Chọn Test Plan
		* Add Thread Group
		* Click chuột phải "Test Plan" và thêm thread group mới: Add -> Threads (Users) -> Thread Group
		* Trong Thread Group thực hiện cấu hình
			* Number of Threads: 100 (Số lượng người dùng truy cập trang web: 100)
			* Loop Count: 10 (Thời gian để thực hiện test)
			* Ramp-Up Period: 100
		- ![images](./images/jm-1.png)	
		- ![images](./images/jm-2.png)	
	- Add JMeter elements
		* HTTP request Default
			- Click chuột phải Thread Group and chọn: Add -> Config Element -> HTTP Request Defaults.
			- Ở ví dụ này thực hiện test trang Google.com (http://www.google.com) nên điền thông tin google.com và phần `server name or IP`
		- ![images](./images/jm-4.png)	
		- ![images](./images/jm-5.png)
		* HTTP Request
			- Click chuột phải vào Thread Group and select: Add -> Sampler -> HTTP Request.
			- Tại đây trường Path cho biết yêu cầu URL nào bạn muốn gửi đến máy chủ Google. Ví dụ: Nếu bạn nhập "calendar" trong trường Path. JMeter sẽ tạo yêu cầu URL http://www.google.com/calendar đến máy chủ Google
		- ![images](./images/jm-6.png)	
		- ![images](./images/jm-7.png)			
	- Add Graph result
		- Click chuột phải vào Test Plan: Add -> Listener -> Graph Results
		- ![images](./images/jm-8.png)			
	- Run Test và xem kết quả
		- Ấn nút Run (Ctrl + R) trên Toolbar để bắt đầu chạy. Bạn sẽ nhìn thấy kết quả test hiển thị trên Graph.
		- Ở dưới cùng của hình ảnh, thấy có các số liệu thống kê và được thể hiện bằng màu sắc:
			* Đen: Tổng số Sample hiện tại được gửi.
			* Màu xanh dương: Trung bình hiện tại của tất cả các Sample được gửi.
			* Màu đỏ: Độ lệch chuẩn hiện tại.
			* Màu xanh lá cây: Tỷ lệ throughput mà đại diện cho số lượng yêu cầu trên mỗi phút mà máy chủ xử lý. 
		- ![images](./images/jm-9.png)			
- Ngoài GUI jmeter có thể chạy bằng dòng lệnh ví dụ trong thư mục `apache-jmeter-5.3/bin`
```
jmeter -n -t testplan.jmx - l log.jtl -H google.com -P 80
```
- ![images](./images/jm-11.png)			
#### 6.1.3 So sánh 
- Khi kiểm thử hiệu năng của hệ thống web, việc lựa chọn công cụ phù hợp là rất quan trọng. Hai công cụ phổ biến nhất hiện nay là Apache Benchmark (ab) và Apache JMeter. Mỗi công cụ đều có thế mạnh riêng, tùy vào mục tiêu và độ phức tạp của bài kiểm thử mà bạn đang hướng tới.
- Apache Benchmark thường được dùng cho các bài test đơn giản, nhanh chóng và dễ triển khai ngay từ dòng lệnh. Trong khi đó, JMeter lại phù hợp hơn với các kịch bản kiểm thử có nhiều bước, yêu cầu mô phỏng người dùng thực tế, hoặc cần theo dõi chi tiết về hiệu suất.

| Đặc điểm           | Apache Benchmark                | JMeter                                          |
| ------------------ | ------------------------------- | ----------------------------------------------- |
| Mức độ dễ sử dụng  | Dễ dùng, chạy bằng dòng lệnh    | Có giao diện đồ họa và cũng chạy được dòng lệnh |
| Tùy chỉnh nâng cao | Ít tùy chỉnh, cấu hình đơn giản | Có nhiều lựa chọn cấu hình, linh hoạt           |
| Kiểm soát mức tải  | Gửi yêu cầu ồ ạt ngay lập tức   | Có thể điều chỉnh thời gian gửi tải             |
| Báo cáo kết quả    | Chỉ có thông tin cơ bản         | Có báo cáo chi tiết, có biểu đồ thống kê        |

### 6.2   Giám sát log (access log, error log).
- `Access_log` thu thập dữ liệu liên quan đến các tệp được yêu cầu từ máy chủ. Log này cung cấp thông tin như: có bao nhiêu người dùng truy cập vào hệ thống, họ đến từ đâu (nguồn truy cập), và họ đã làm gì trên trang. Dữ liệu từ access log giúp tổ chức hiểu rõ hơn cách người dùng tương tác với website — từ đó cải thiện trải nghiệm người dùng, điều hướng trang, hoặc nội dung hiển thị.
- `Error log` ghi lại các sự cố, điểm nghẽn, hoặc lỗi mà máy chủ web gặp phải trong quá trình xử lý yêu cầu từ người dùng. Những log này thường chứa thông tin chi tiết như:
	* Tệp bị thiếu
	* Liên kết hỏng
	* Dịch vụ không phản hồi 
	* Thông tin chẩn đoán liên quan đến hoạt động của máy chủ
	* Error logs rất quan trọng trong việc khắc phục sự cố máy chủ, giúp xác định và xử lý các vấn đề có thể ảnh hưởng đến khả năng hoạt động của website.
- Các file log này thường đường lưu trong 
	- Ubuntu 
	```
	/var/log/apache2 
	/var/log/nginx 
	```
	- Windows 
	```
	%SystemDrive%\inetpub\logs\LogFiles
	```
- Giám sát cơ bản 
	- Sử dụng các lệnh `tail, less` kết hợp
		- Monitor log theo real-time 
		```
		tail -f /var/log/apache2/access.log
		less var/log/apache2/access.log
		```
		- Combine với lệnh grep 
		```
		tail -f var/log/apache2/access.log | grep "ERROR"
		grep "ERROR" var/log/apache2/access.log | less
		```
	- Sử dụng công cụ hỗ trợ: ví dụ goaccess
		- Cài đặt 
		```
		apt install goaccess
		```
		- Sử dụng goaccess để giám sát. Chọn Common Log Format  
		```
		goaccess /var/log/apache2/access.log -c 
		```
		- ![images](./images/log-1.png)		
		- ![images](./images/log-2.png)		
		
### 6.3  Công cụ phân tích (Prometheus, Grafana, ELK Stack).
### 6.3.1 Prometheus
- Prometheus là một dịch vụ theo dõi và cảnh báo về hệ thống. Đây là một dịch vụ mã nguồn mở (Open source) hoàn toàn miễn phí. SoundCloud đã khởi đầu xây dựng Prometheus từ năm 2012. Prometheus đã được rất nhiều hệ thống tin tưởng áp dụng. Dự án có một cộng đồng người đóng góp, phát triển rất tích cực.
- Tính năng quan trọng nhất của Prometheus là thu thập thông số, dữ liệu từ các mục tiêu (dịch vụ) được nhắm đến theo khoảng thời gian nhất định đã được cài đặt trước. Ngoài ra còn các API khác thể hiện được kết quả, đánh giá bằng biểu thức quy tắc và đưa ra cảnh báo. Prometheus còn cung cấp một ngôn ngữ truy vấn rất mạnh PromQL, cực kì hữu ích khi giao tiếp với các dịch vụ monitor khác.
- Một số tính năng của Prometheus
	- Mô hình dữ liệu Time series đặc biệt phù hợp để theo dõi số liệu theo thời gian.
	- Có ngôn ngữ truy vấn riêng PromQL rất mạnh mẽ.
	- Tích hợp tốt với rất nhiềunền tảng ứng dụng.
	- Yêu cầu hạ tầng để triển khai đơn giản.
	- Hỗ trợ Push Gateway (khi làm việc với các dịch vụ tồn tại trong thời gian ngắn và hủy sau khi hoàn thành).
	- Có hỗ trợ Service discovery hoặc cấu hình tĩnh để tìm, nhắm mục tiêu cần theo dõi.
### 6.3.2 Grafana
- Grafana là một nền tảng mã nguồn mở giúp bạn truy vấn, hiển thị, và cảnh báo dữ liệu từ nhiều nguồn khác nhau. Bạn có thể sử dụng Grafana để theo dõi thông tin theo thời gian thực từ nhiều loại dữ liệu khác nhau, như cơ sở dữ liệu thời gian thực (Time Series Database), SQL, NoSQL, hoặc các dịch vụ cloud thông qua các bảng điều khiển (dashboard) có thể tùy chỉnh.
- Grafana Lab đã phát triển rất nhiều công cụ cho cộng đồng, chúng được chia thành các nhóm chính như sau:
	- Bộ công cụ cốt lõi (Grafana stack): Bao gồm LGTM (Loki, Grafana, Tempo, Mimir) và Grafana Agent, dùng để quản lý logs, metrics và tracing.
	- Plugin cho doanh nghiệp: Mở rộng khả năng của Grafana cho các tổ chức lớn.
	- Công cụ xử lý sự cố: Giúp quản lý và khắc phục sự cố nhanh chóng.
	- Các công cụ khác: Tăng cường khả năng giám sát và quản lý hệ thống.
- Grafana là một vizualizer hiển thị các metric dưới dạng các biểu đồ (chart) hoặc đồ thị (graph), được tập hợp lại thành dashboard có tính tùy biến cao, giúp dễ dàng theo dõi tình trạng của node. Đơn giản cho các bạn dễ hiểu là sau khi lấy được metric từ các thiết bị, grafana sẽ sử dụng metric đó để phân tích và tạo ra dashboard mô tả trực quan các metric cần thiết cho việc monitoring như CPU, RAM, disks, IO operations...

### 6.3.3 ELK Stack 
- ELK Stack là viết tắt của ba công cụ mã nguồn mở phổ biến: Elasticsearch, Logstash, và Kibana. Bộ công cụ này thường được gọi chung là Elasticsearch, nhưng thực chất là một hệ sinh thái giúp bạn:
	* Thu thập log từ tất cả các hệ thống và ứng dụng
	* Phân tích log theo thời gian thực
	* Trực quan hóa dữ liệu để theo dõi hệ thống, giám sát ứng dụng và hạ tầng
	* Xử lý sự cố nhanh hơn
	* Phân tích bảo mật và phát hiện bất thường
- ELK Stack thường được sử dụng trong các hệ thống giám sát và logging tập trung, giúp đội ngũ vận hành (Ops), bảo mật (Sec) và phát triển (Dev) dễ dàng theo dõi và phản ứng kịp thời với các sự cố.
- Cụ thể về các thành phần của ELK 
	- `E - Elasticsearch` 
		- là một công cụ mã nguồn mở hiện đại, dùng để tìm kiếm toàn văn (full-text search) và phân tích dữ liệu.
		- Là trái tim của ELK Stack, Elasticsearch có thể được sử dụng để tìm kiếm nhiều loại dữ liệu khác nhau — từ văn bản, số, dữ liệu không gian địa lý (geospatial), đến các dữ liệu có cấu trúc hoặc không có cấu trúc.
		- Đặc điểm kỹ thuật nổi bật:
			* Xây dựng trên thư viện Apache Lucene, một nền tảng tìm kiếm mạnh mẽ
			* Kiến trúc phân tán giúp mở rộng quy mô dễ dàng
			* Giao tiếp qua RESTful API đơn giản
			* Lưu trữ dữ liệu dạng JSON không cần schema cố định
			* Khả năng tìm kiếm với tốc độ cao ngay cả với khối lượng dữ liệu lớn và tăng nhanh
		- Elasticsearch rất phù hợp để triển khai trong các hệ thống tìm kiếm, phân tích log, giám sát thời gian thực, và các ứng dụng đòi hỏi hiệu suất truy vấn cao
	- `L - Logstash`
		- là một công cụ mã nguồn mở, chạy phía máy chủ, hoạt động như một pipeline xử lý dữ liệu. Nó có khả năng thu thập dữ liệu đầu vào (ingest), xử lý (transform), và chuyển tiếp dữ liệu tới bất kỳ điểm đích đã cấu hình.
		- Tính năng chính:
			* Có thể thu thập dữ liệu không cấu trúc từ nhiều nguồn khác nhau cùng lúc — như website, máy chủ ứng dụng, cơ sở dữ liệu, v.v.
			* Lọc và phân tích dữ liệu đầu vào, sau đó chuyển đổi thành định dạng thống nhất
			* Gửi dữ liệu đã xử lý đến nơi bạn mong muốn (phổ biến nhất là gửi vào Elasticsearch) để lập chỉ mục và tìm kiếm
			* Sau khi dữ liệu được đẩy vào Elasticsearch, bạn có thể tiếp tục trực quan hóa và phân tích nó bằng Kibana.
		- Logstash giúp chuẩn hóa dữ liệu từ nhiều hệ thống khác nhau, tạo nền tảng cho việc giám sát, phân tích log, và xử lý dữ liệu thời gian thực một cách hiệu quả.
	- `K - Kibana` 
		- là một công cụ mã nguồn mở dùng để phân tích và trực quan hóa dữ liệu, giúp biến dữ liệu được lưu trữ trong Elasticsearch thành các biểu đồ, đồ thị, biểu đồ tần suất (histogram) và các dạng hiển thị trực quan khác dễ hiểu và dễ sử dụng.
		- Tính năng chính:
			* Giao diện sử dụng trên trình duyệt, dễ thao tác
			* Cung cấp dashboard có sẵn để khám phá và phân tích khối lượng lớn dữ liệu
			* Hỗ trợ tạo biểu đồ, biểu đồ tròn, bản đồ nhiệt, bảng dữ liệu, v.v.
			* Không cần kỹ năng lập trình, người dùng không chuyên kỹ thuật vẫn có thể sử dụng để theo dõi xu hướng, đánh giá các chỉ số hiệu suất (KPI)
		- Kibana là công cụ lý tưởng để chia sẻ thông tin và phân tích dữ liệu nội bộ, giúp các bộ phận khác nhau trong tổ chức có cái nhìn chung về hoạt động hệ thống hoặc kết quả kinh doanh — thông qua các biểu đồ trực quan, dễ hiểu và có thể tùy chỉnh.

| Thành phần        | Vai trò chính                            |
| ----------------- | ---------------------------------------- |
| **Elasticsearch** | Lưu trữ, tìm kiếm và phân tích dữ liệu   |
| **Logstash**      | Thu thập, xử lý và gửi dữ liệu           |
| **Kibana**        | Hiển thị dữ liệu qua giao diện trực quan |

- ![images](./images/elk-1.png)

- Chức năng và Lợi ích của ELK Stack
	- Quản lý và phân tích log
		* ELK Stack vượt trội trong việc tập trung lưu trữ log từ nhiều hệ thống khác nhau và hỗ trợ phân tích log toàn diện.
		* Hỗ trợ xử lý log theo thời gian thực
		* Lập chỉ mục dữ liệu hiệu quả, giúp truy xuất và phân tích nhanh chóng
		=> Giúp tìm lỗi, giám sát hoạt động hệ thống và đảm bảo tính minh bạch của dữ liệu log.
	- Trực quan hóa dữ liệu và dashboard
		* Kibana là công cụ mạnh để tạo các biểu đồ tương tác và dashboard tùy chỉnh.
		* Biến dữ liệu log phức tạp thành hình ảnh dễ hiểu
		* Hỗ trợ đưa ra insight có thể hành động được (actionable insights)
		=> Giúp đội ngũ kỹ thuật và không kỹ thuật hiểu rõ hơn về hiệu suất và hành vi hệ thống.
	- Giám sát hệ thống và phân tích hiệu suất
		* ELK Stack cực kỳ hiệu quả cho việc giám sát hoạt động hệ thống và phân tích hiệu suất.
		* Phát hiện bất thường (anomaly detection)
		* Hỗ trợ xử lý sự cố và tối ưu hạ tầng
		* Có thể mở rộng sang phân tích dự đoán và ứng dụng machine learning
		=> Là công cụ linh hoạt, phù hợp với nhiều mục tiêu như DevOps, SecOps, hoặc phân tích kinh doanh.
		
## 7. So sánh Web Server vs Application Server
- 
- 
- so sanh 
- 
•  Khi nào dùng web server (phục vụ file tĩnh)?
•  Khi nào cần application server (xử lý logic như Node.js, Tomcat)?
- 1 vài 

8. Xu hướng hiện đại
•  Serverless (AWS Lambda, Cloud Functions).
•  Container hóa (Docker + Web Server).
•  Edge Computing (xử lý gần người dùng hơn).
9. Thực hành/Tutorials
•  Cài đặt Apache/Nginx trên Linux/Windows.
•  Host một website đơn giản (HTML, PHP).
•  Triển khai HTTPS với Let’s Encrypt.

10. Các vấn đề thường gặp
•  Lỗi 403, 404, 500 và cách khắc phục.
•  Tối ưu database kết hợp web server.
•  Xử lý tải cao (scaling theo chiều ngang/dọc).
11. Công cụ hỗ trợ
•  Công cụ quản lý web server: 
	o  cPanel, DA, Plesk
	o  Một số panel free
•  Công cụ kiểm tra hiệu suất: 
	o  ApacheBench (ab), JMeter, Siege.
•  Công cụ bảo mật: 
	o  Nmap, OpenVAS để quét lỗ hổng.
	o  ModSecurity cho tường lửa ứng dụng web.