# SSL (Secure Sockets Layer) - TLS (Transport Layer Security)

## 1. Tổng quan SSL/TLS
### 1.1 SSL/TLS  
- SSL, hay Secure Sockets Layer, là một giao thức bảo mật trên Internet dựa trên mã hóa. Nó được phát triển lần đầu tiên bởi Netscape vào năm 1995 nhằm đảm bảo tính riêng tư, xác thực và toàn vẹn dữ liệu trong các giao tiếp qua Internet. SSL là tiền thân của giao thức mã hóa hiện đại TLS được sử dụng ngày nay.
- Transport Layer Security, hay TLS, là một giao thức bảo mật được sử dụng rộng rãi nhằm hỗ trợ quyền riêng tư và bảo mật dữ liệu trong các giao tiếp qua Internet. Một trong những ứng dụng chính của TLS là mã hóa thông tin trao đổi giữa các ứng dụng web và máy chủ, ví dụ như khi trình duyệt tải một trang web. TLS cũng có thể được sử dụng để mã hóa các hình thức giao tiếp khác như email, tin nhắn và thoại qua IP (VoIP).
- Giao thức TLS được đề xuất bởi Internet Engineering Task Force (IETF), một tổ chức tiêu chuẩn quốc tế, và phiên bản đầu tiên được công bố vào năm 1999. Phiên bản mới nhất là TLS 1.3, được phát hành vào năm 2018.
- Sự khác biệt cốt lõi giữa SSL và TLS nằm ở việc TLS giới thiệu một loạt cải tiến quan trọng như thuật toán mã hóa mạnh mẽ hơn, cơ chế xác thực tốt hơn và phương pháp trao đổi khóa an toàn hơn. Những nâng cấp này giúp giảm đáng kể nguy cơ bị tấn công và đảm bảo mức độ bảo mật cao hơn trong truyền tải dữ liệu. Một số điểm nổi bật của TLS bao gồm:
	- Mã hóa mạnh hơn: TLS hỗ trợ các thuật toán mã hóa tiên tiến như AES (Advanced Encryption Standard), mang lại khả năng bảo vệ tốt hơn trước các cuộc tấn công brute-force.
	- Khác biệt về mật mã học: Mặc dù cả hai giao thức đều dựa trên nguyên tắc tương tự, TLS áp dụng các kỹ thuật mật mã mạnh mẽ hơn. Ví dụ, TLS sử dụng HMAC (Mã xác thực thông điệp dựa trên hàm băm) cho tính toàn vẹn của dữ liệu, an toàn hơn so với MAC trong SSL. Ngoài ra, TLS cũng hỗ trợ các bộ mã hóa (cipher suite) an toàn hơn.
	- Xác thực cải tiến: TLS sử dụng phương thức xác thực bảo mật hơn để xác minh danh tính giữa các bên giao tiếp, giảm nguy cơ tấn công giả mạo trung gian. Quy trình bắt tay (handshake) của TLS cũng an toàn hơn với các cơ chế xác thực mạnh mẽ.
	- Hiệu suất cao hơn: TLS được thiết kế tối ưu hơn, giảm tải khi thiết lập kết nối bảo mật, từ đó giúp quy trình bắt tay diễn ra nhanh hơn và độ trễ thấp hơn—phù hợp cho các ứng dụng web hiện đại đòi hỏi tốc độ cao và thời gian phản hồi nhanh.
	- Trao đổi khóa nâng cao: TLS sử dụng các giao thức trao đổi khóa an toàn hơn như Diffie-Hellman và Elliptic Curve Diffie-Hellman để thiết lập kết nối bảo mật.
### 1.2 Lịch sử, phiên bản 
- SSL và TLS là những giao thức dùng để bảo mật các kết nối mạng. SSL, do Netscape phát triển, là giao thức được sử dụng rộng rãi đầu tiên, nhưng sau đó đã được thay thế bởi TLS – một phiên bản nâng cấp với các tính năng bảo mật và hiệu suất cải tiến vượt trội. TLS, được giới thiệu lần đầu vào năm 1999 như bản nâng cấp của SSL 3.0, hiện nay đã trở thành tiêu chuẩn cho việc bảo mật giao tiếp trên Internet.
**SSL (Secure Sockets Layer):**  
- Được phát triển bởi Netscape vào giữa những năm 1990  
- *SSL 1.0* chưa từng được phát hành công khai do có nhiều lỗ hổng bảo mật  
- *SSL 2.0* phát hành vào năm 1995, là phiên bản công khai đầu tiên nhưng cũng tồn tại nhiều điểm yếu  
- *SSL 3.0* ra mắt năm 1996, là một bản thiết kế lại với cải tiến rõ rệt, nhưng theo thời gian vẫn bị phát hiện có lỗ hổng  

**TLS (Transport Layer Security):**  
- TLS 1.0: Đây là phiên bản đầu tiên được phát hành vào năm 1999. Là phiên bản tiếp nối và chứa nhiều đặc điểm tương đồng với SSL 3.0. Phiên bản này đã được cải tiến và cập nhật các giao thức và quy trình để tương thích với các máy tính và kết nối Internet trong giai đoạn đầu của thập kỷ 2000. Phiên bản 1.0 được công bố theo RFC 2246, định nghĩa các yêu cầu và quy định chi tiết cho giao thức này.
- TLS 1.1: Đây là phiên bản thứ hai được ra mắt vào năm 2006, đại diện cho sự tiến bộ đáng kể đầu tiên của giao thức này. Phiên bản này đã mang đến nhiều thay đổi và cải tiến đáng kể, bao gồm việc thay thế Vectơ Khởi tạo bằng một phiên bản rõ ràng hơn để cung cấp khả năng bảo vệ tốt hơn chống lại các cuộc tấn công mạng.
	- Ngoài ra, phiên bản 1.1 cũng đã cải thiện quá trình xử lý lỗi và xác thực để phù hợp với môi trường sử dụng Internet vào năm 2006. Bên cạnh đó, các ghi chú và giải thích liên quan đến các hình thức tấn công mạng mới đã được bổ sung vào phiên bản này. Phiên bản 1.1 đã được công bố theo RFC 4346.
- TLS 1.2: Đây là phiên bản thứ ba và được ra mắt vào năm 2008. Là phiên bản cập nhật quan trọng thứ hai của giao thức và hiện vẫn là phiên bản tiêu chuẩn được sử dụng rộng rãi. Được coi là phiên bản mới nhất, Phiên bản 1.2 mang đến nhiều cải tiến bảo mật đáng kể cùng với việc cải thiện tốc độ và khả năng của cả máy chủ và máy khách trong quá trình thiết lập kết nối và sử dụng tất cả các thuật toán liên quan đến quy trình TLS.
	- Một cải tiến quan trọng của phiên bản 1.2 là việc áp dụng các thuật toán bảo mật mạnh hơn để đảm bảo tính toàn vẹn và bảo mật dữ liệu. Phiên bản này đã được công bố theo RFC 5246.
- TLS 1.3: Đây là phiên bản mới nhất của giao thức này, được công bố vào năm 2016 và đang trong giai đoạn thử nghiệm. Mục tiêu chính của bản cập nhật này là cải thiện đáng kể giao thức bảo mật hiện có, tăng cường tính an toàn trên internet và đảm bảo tính toàn vẹn của việc truyền dữ liệu. Phiên bản 1.3 đã áp dụng các cải tiến để đối phó với các kỹ thuật hack phức tạp, nhằm bảo vệ dữ liệu nhạy cảm và thông tin cá nhân, chẳng hạn như thông tin tài khoản ngân hàng và thanh toán.

| Protocol | Published | Status |
|----------|-----------|--------|
| 🔴 SSL 1.0 | Unpublished | Unpublished |
| 🔴 SSL 2.0 | 1995 | Deprecated in 2011 (RFC 6176) |
| 🔴 SSL 3.0 | 1996 | Deprecated in 2015 (RFC 7568) |
| 🔴 TLS 1.0 | 1999 | Deprecated in 2021 (RFC 8996) |
| 🔴 TLS 1.1 | 2006 | Deprecated in 2021 (RFC 8996) |
| 🟡 TLS 1.2 | 2008 | In use since 2008 |
| 🟢 TLS 1.3 | 2018 | In use since 2018 |

### 1.3 Vai trò của SSL trong bảo mật mạng (HTTPS, email, VPN, v.v.)
- HTTPS (Hypertext Transfer Protocol Secure): SSL/TLS là nền tảng của HTTPS – một phiên bản bảo mật của HTTP. Giao thức này mã hóa dữ liệu truyền giữa trình duyệt và máy chủ, giúp bảo vệ thông tin khỏi bị nghe lén hoặc chỉnh sửa. Nó cũng thực hiện xác thực máy chủ để người dùng biết họ đang kết nối với đúng website.
- Email: Các giao thức email như SMTPS, POP3S và IMAPS sử dụng SSL/TLS để bảo vệ nội dung thư điện tử trong quá trình truyền tải. Điều này ngăn chặn việc rò rỉ hoặc giả mạo email, đồng thời đảm bảo tính toàn vẹn của thông tin.
- VPN (Virtual Private Network): Một số giao thức VPN (ví dụ: OpenVPN) dựa trên SSL/TLS để mã hóa dữ liệu giữa thiết bị của người dùng và máy chủ VPN. Điều này tạo ra một kênh truyền thông an toàn, đặc biệt hữu ích khi sử dụng mạng công cộng.
- Các ứng dụng khác: SSL/TLS được ứng dụng trong bảo mật các dịch vụ như nhắn tin, thoại qua IP (VoIP), truy cập từ xa, và API trong kiến trúc microservices hoặc hệ thống đám mây. Việc sử dụng SSL giúp bảo vệ các tương tác giữa các thành phần phần mềm khác nhau khỏi rò rỉ hoặc can thiệp dữ liệu.
### 1.4 Lợi ích
- Lợi ích của  SSL/TLS:
	- Bảo vệ dữ liệu: Mã hóa thông tin giúp ngăn chặn nghe lén, đánh cắp và chỉnh sửa dữ liệu.
	- Xác thực danh tính: Đảm bảo người dùng đang truy cập đúng website hợp pháp.
	- Tuân thủ tiêu chuẩn: Bắt buộc với các website thanh toán để đáp ứng yêu cầu PCI-DSS.
	- Ngăn chặn tấn công: Bảo vệ khỏi giả mạo, nghe lén và đánh cắp danh tính.
	- Chống lừa đảo: Khó có trang giả mạo nào đạt được chứng chỉ bảo mật cao cấp như EV/OV.
	- Cải thiện thứ hạng tìm kiếm: Google ưu tiên các website sử dụng HTTPS.
	- Tăng niềm tin người dùng: Biểu tượng ổ khóa và HTTPS tạo cảm giác an toàn khi giao dịch.

### 1.5 Các vấn đề khi sử dụng SSL/TLS
- Mặc dù SSL/TLS mang lại nhiều lợi ích, nhưng các nhà phát triển có thể gặp phải một số thách thức khi triển khai:
	- Tác động đến hiệu suất: SSL/TLS tạo ra một mức độ tải bổ sung do quá trình mã hóa và giải mã. Điều này có thể ảnh hưởng đến hiệu suất ứng dụng, đặc biệt khi xử lý lượng lớn dữ liệu hoặc giao tiếp theo thời gian thực.
	- Vấn đề tương thích: Việc triển khai SSL/TLS có thể khác nhau giữa các nền tảng, thư viện và phiên bản. Điều này có thể dẫn đến sự cố tương thích khi thiết lập kết nối bảo mật giữa máy khách và máy chủ.
	- Khả năng mở rộng: Các ứng dụng nhắn tin và chat theo thời gian thực thường phải xử lý nhiều kết nối đồng thời. Việc mở rộng SSL/TLS có thể gặp khó khăn vì cần thêm tài nguyên tính toán để thực hiện mã hóa và giải mã. Cần xem xét triển khai các chiến lược cân bằng tải và bộ đệm (caching) để xử lý lưu lượng tăng cao.
	- Độ phức tạp trong tích hợp: Tích hợp SSL/TLS vào ứng dụng có thể phức tạp, đặc biệt là đối với kiến trúc phân tán hoặc các hệ thống phụ thuộc vào nhiều dịch vụ bên thứ ba.
	- Quản lý chứng chỉ: Việc quản lý và gia hạn chứng chỉ số có thể tốn thời gian và công sức, đặc biệt trong các hệ thống quy mô lớn với nhiều máy chủ và tên miền.
	- Chi phí phát triển và bảo trì bổ sung: Việc triển khai SSL/TLS cho các ứng dụng chat thời gian thực đòi hỏi thêm nỗ lực về mặt phát triển và bảo trì.

### 1.6 So sánh SSL/TLS

| Tiêu chí                  | SSL                                                                      | TLS                                                                      |
| ------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------ |
| Viết tắt                  | SSL là viết tắt của *Secure Sockets Layer*.                              | TLS là viết tắt của *Transport Layer Security*.                          |
| Lịch sử phiên bản         | SSL hiện đã bị thay thế bởi TLS. Bao gồm các phiên bản 1.0, 2.0 và 3.0.  | TLS là phiên bản nâng cấp từ SSL. Có các phiên bản 1.0, 1.1, 1.2 và 1.3. |
| Tình trạng hoạt động      | Tất cả các phiên bản SSL đều đã bị khai tử (deprecated).                 | TLS 1.2 và 1.3 vẫn đang được sử dụng phổ biến.                           |
| Thông báo cảnh báo        | Chỉ có hai loại thông báo cảnh báo. Các thông báo này không được mã hóa. | Thông báo cảnh báo được mã hóa và đa dạng hơn.                           |
| Xác thực thông điệp       | Sử dụng MAC (Message Authentication Code).                               | Sử dụng HMAC (Hash-based MAC), an toàn hơn.                              |
| Bộ mã hóa (Cipher Suites) | Hỗ trợ các thuật toán cũ, nhiều thuật toán đã có lỗ hổng.                | Sử dụng thuật toán mã hóa tiên tiến, bảo mật cao.                        |
| Bắt tay (Handshake)       | Quá trình bắt tay phức tạp và chậm.                                      | Bắt tay đơn giản hơn, thiết lập kết nối nhanh hơn.                       |


## 2. Cách thức hoạt động của SSL 
### 2.1 Hoạt động của SSL/TLS 
- Giao tiếp an toàn bắt đầu bằng quá trình bắt tay TLS (TLS handshake), trong đó hai bên tham gia sẽ thiết lập kết nối bảo mật và trao đổi khóa công khai.
- Trong quá trình bắt tay, cả hai bên sẽ tạo ra khóa phiên (session key), và các khóa này sẽ được sử dụng để mã hóa và giải mã toàn bộ dữ liệu truyền sau đó.
- Mỗi phiên giao tiếp mới sử dụng một khóa phiên khác nhau, đảm bảo tính riêng tư và bảo mật.
- TLS đảm bảo rằng bên máy chủ (hoặc website mà người dùng đang tương tác) thực sự là đối tượng chính xác như họ tuyên bố.
- TLS cũng đảm bảo rằng dữ liệu không bị thay đổi trong quá trình truyền, nhờ sử dụng mã xác thực thông điệp (MAC – Message Authentication Code).
- Với TLS, tất cả dữ liệu HTTP mà người dùng gửi đến website (như nhấp chuột, điền biểu mẫu…) và dữ liệu mà website gửi lại cho người dùng đều được mã hóa. Dữ liệu này chỉ có thể được giải mã bởi bên nhận bằng khóa thích hợp.

### 2.2 Handshake SSL/TLS: Cách thiết lập kết nối an toàn.
- Các "SSL handshakes" thực chất là TLS handshakes, mặc dù tên “SSL” vẫn được sử dụng phổ biến trong thực tế.
- TLS handshake xảy ra khi người dùng truy cập vào dịch vụ sử dụng SSL/TLS và client liên lạc với server.
- Lưu ý: TLS handshake được thực hiện sau khi kết nối TCP đã được thiết lập thông qua quá trình TCP handshake.
- Trong quá trình TLS handshake, máy khách (client) và máy chủ (server) sẽ thực hiện các bước sau:
	- Xác định phiên bản TLS sẽ sử dụng (ví dụ: TLS 1.0, 1.2, 1.3, v.v.)
	- Thỏa thuận lựa chọn bộ thuật toán mã hóa (cipher suites) được hỗ trợ và sử dụng
	- Xác thực danh tính của máy chủ thông qua khóa công khai (public key) và chữ ký số từ tổ chức phát hành chứng chỉ SSL
	- Tạo khóa phiên (session key) để sử dụng mã hóa đối xứng sau khi handshake hoàn tất
- TLS handshake là một chuỗi các datagram (gói tin) hoặc thông điệp được trao đổi giữa máy khách (client) và máy chủ (server). Quá trình handshake bao gồm nhiều bước, trong đó hai bên trao đổi các thông tin cần thiết để hoàn tất handshake và thiết lập khả năng giao tiếp bảo mật tiếp theo.
- Các bước cụ thể trong một TLS handshake có thể khác nhau tùy thuộc vào thuật toán trao đổi khóa được sử dụng và các bộ mã hóa (cipher suites) mà cả hai bên hỗ trợ. Thuật toán trao đổi khóa RSA – hiện nay không còn được coi là an toàn – từng được sử dụng trong các phiên bản TLS trước 1.3. Quy trình điển hình như sau:
	1. Thiết lập kết nối bảo mật (Quy trình Handshake)
	- Client Hello: Máy khách (trình duyệt của bạn) gửi một thông điệp đến máy chủ để yêu cầu thiết lập kết nối bảo mật. Thông điệp này bao gồm các thuật toán mã hóa được hỗ trợ và một số ngẫu nhiên dùng để khởi tạo mã hóa.
	- Server Hello: Máy chủ phản hồi bằng số ngẫu nhiên của riêng nó, chọn thuật toán mã hóa phù hợp từ danh sách của máy khách và gửi kèm chứng chỉ SSL/TLS (chứa khóa công khai và danh tính của máy chủ).
	2. Xác thực
	- Máy khách kiểm tra tính hợp lệ của chứng chỉ SSL/TLS thông qua tổ chức chứng thực (CA) đã cấp chứng chỉ đó. Việc này đảm bảo máy chủ là đúng đối tượng được khai báo.
	- Nếu chứng chỉ hợp lệ và đáng tin cậy, máy khách sẽ tiếp tục kết nối. Nếu không, sẽ xuất hiện cảnh báo (ví dụ: “kết nối không đáng tin”).
	3. Trao đổi khóa
	- Client Key Exchange: Máy khách tạo một số ngẫu nhiên gọi là "pre-master secret" và mã hóa nó bằng khóa công khai của máy chủ rồi gửi đến máy chủ.
	- Server Decrypts: Máy chủ giải mã pre-master secret bằng khóa bí mật của mình.
	- Cả hai bên sau đó sử dụng pre-master secret cùng với các số ngẫu nhiên từ handshake để tạo ra khóa phiên (session key). Khóa này sẽ được sử dụng để mã hóa và giải mã dữ liệu trong suốt phiên làm việc.
	4. Mã hóa dữ liệu và giao tiếp an toàn
	- Khi cả hai đã có chung một khóa phiên, họ có thể mã hóa và giải mã dữ liệu trao đổi. Nhờ đó, ngay cả khi kẻ tấn công chặn được dữ liệu, họ cũng không thể đọc nội dung nếu không có khóa phiên.
	5. Kết thúc phiên làm việc
	- Sau khi trao đổi xong, máy khách và máy chủ gửi thông báo cho nhau rằng phiên làm việc đã kết thúc. Việc này đảm bảo khóa phiên được hủy bỏ và kết nối bảo mật được đóng lại.
	- ![images](./images/tls-sequence-diagram.png)
- Handshake trong TLS 1.3 
	- TLS 1.3 không hỗ trợ RSA hay các bộ mã hóa và tham số dễ bị tấn công. Giao thức này cũng rút gọn quá trình handshake, giúp TLS 1.3 handshake diễn ra nhanh hơn và an toàn hơn.
	- Các bước cơ bản trong TLS 1.3 handshake:
		- Client Hello: Máy khách gửi thông điệp hello chứa phiên bản giao thức, client random và danh sách các cipher suite được hỗ trợ. Do TLS 1.3 đã loại bỏ các thuật toán yếu, danh sách cipher suite đã được rút gọn đáng kể. Thông điệp cũng bao gồm các tham số cần thiết để tính toán "premaster secret". Trên thực tế, máy khách gần như đoán trước được phương pháp trao đổi khóa mà máy chủ ưa dùng — điều này giúp rút ngắn tổng thời gian handshake, là điểm khác biệt chính so với các phiên bản TLS cũ hơn (1.0 – 1.2).
		- Máy chủ tạo master secret: Sau khi nhận được client random và các tham số, máy chủ tự tạo server random và có đủ thông tin để tính master secret.
		- Server Hello + Finished: Server hello bao gồm chứng chỉ số, chữ ký số, server random và cipher suite đã chọn. Vì đã có master secret, máy chủ cũng gửi luôn thông điệp "Finished".
		- Bước cuối – Client Finished: Máy khách xác minh chữ ký và chứng chỉ, tạo master secret và gửi lại thông điệp "Finished".
		→ Mã hóa đối xứng an toàn được thiết lập.
	- 0-RTT (Zero Round Trip Time) cho tái sử dụng phiên: TLS 1.3 còn hỗ trợ chế độ 0-RTT cho các lần kết nối tiếp theo: nếu client và server đã từng kết nối trước đó, họ có thể tạo ra một "resumption main secret" từ phiên đầu tiên. Trong phiên đầu, server gửi cho client một vé phiên (session ticket). Khi client kết nối lại, nó dùng shared secret này và session ticket để mã hóa dữ liệu ngay từ thông điệp đầu tiên, không cần mất thời gian trao đổi thông điệp qua lại.

### 2.3 Vai trò của khóa công khai (public key) và khóa bí mật (private key).
- Trong SSL, khóa công khai (public key) và khóa bí mật (private key) là hai thành phần cốt lõi trong hệ thống mã hóa được sử dụng cho giao tiếp an toàn.
	- Khóa công khai được dùng để mã hóa dữ liệu.
	- Khóa bí mật được dùng để giải mã dữ liệu đã mã hóa.
- Đây là phương pháp mã hóa bất đối xứng, đảm bảo rằng chỉ người nhận dự kiến sở hữu khóa bí mật tương ứng mới có thể giải mã và truy cập thông tin. Nhờ vậy, dữ liệu được bảo vệ ngay cả khi truyền qua các kênh không an toàn.
- Khóa công khai (Public Key):
	- Khả dụng: Khóa công khai được chia sẻ tự do và sẵn sàng cho bất kỳ ai muốn gửi dữ liệu được mã hóa đến người sở hữu khóa.
	- Mã hóa: Khóa này được dùng để mã hóa các thông điệp hoặc dữ liệu mà chỉ người giữ khóa bí mật tương ứng mới có thể giải mã và đọc được.
	- Ví dụ: Nếu Alice muốn gửi một thông điệp an toàn cho Bob, cô ấy sẽ mã hóa thông điệp bằng khóa công khai của Bob. Khi Bob nhận được thông điệp, anh ấy sẽ giải mã nó bằng khóa bí mật của mình.
- Khóa bí mật (Private Key):
	- Bảo mật: Khóa bí mật được giữ kín tuyệt đối và không bao giờ được chia sẻ. Nó được sử dụng để giải mã dữ liệu đã được mã hóa bằng khóa công khai tương ứng.
	- Giải mã: Đây là khóa duy nhất có khả năng giải mã dữ liệu đã được mã hóa bằng khóa công khai của nó.
	- Ví dụ: Chỉ Bob sở hữu khóa bí mật tương ứng với khóa công khai được dùng để mã hóa thông điệp do Alice gửi.
	- ![images](./images/s-1.png)

## 3. Chứng chỉ SSL (SSL Certificate)
### 3.1 Khái niệm và mục đích 
- SSL/TLS Certificate hay Chứng chỉ SSL/TLS là một đối tượng số cho phép các hệ thống xác minh danh tính và thiết lập kết nối mạng được mã hóa với một hệ thống khác thông qua giao thức SSL/TLS (Secure Sockets Layer/Transport Layer Security).
- Các chứng chỉ này hoạt động trong một hệ thống mật mã gọi là cơ sở hạ tầng khóa công khai (PKI – Public Key Infrastructure). PKI cho phép một bên xác minh danh tính của bên kia nếu cả hai cùng tin tưởng vào một bên thứ ba – gọi là tổ chức chứng thực (Certificate Authority – CA).
- Chứng chỉ SSL/TLS đóng vai trò như một thẻ căn cước số, giúp bảo vệ các kết nối mạng, xác thực danh tính của các website trên Internet cũng như các tài nguyên trong mạng nội bộ.
- Lợi ích của chứng chỉ SSL/TLS:
	- Bảo vệ dữ liệu cá nhân: Trình duyệt kiểm tra chứng chỉ SSL/TLS trước khi cho phép kết nối bảo mật. Công nghệ này giúp mã hóa toàn bộ thông tin giữa người dùng và máy chủ web.
	- Tăng độ tin cậy với khách hàng: Người dùng hiểu biết về Internet quan tâm đến quyền riêng tư và tin tưởng hơn vào các website có biểu tượng ổ khóa xanh. SSL/TLS giúp khẳng định rằng dữ liệu của họ đang được bảo vệ.
	- Tuân thủ quy định pháp lý: Một số ngành, như ngành thanh toán, bắt buộc phải tuân thủ các quy định bảo mật như PCI DSS – trong đó yêu cầu cài chứng chỉ SSL/TLS để đảm bảo giao dịch an toàn.
	- Cải thiện thứ hạng SEO: Các công cụ tìm kiếm lớn xem SSL/TLS là yếu tố đánh giá xếp hạng. Website được bảo mật bằng SSL/TLS thường có vị trí cao hơn so với website không có bảo vệ, từ đó thu hút nhiều lượt truy cập hơn.
- Xác thực và thời hạn của chứng chỉ 
	- Cơ quan cấp chứng chỉ (CA – Certificate Authority) là tổ chức chuyên cung cấp các chứng chỉ SSL/TLS cho chủ sở hữu trang web, công ty lưu trữ web hoặc doanh nghiệp. CA sẽ xác minh thông tin tên miền và người sở hữu trước khi cấp chứng chỉ SSL/TLS.
	- Chứng chỉ SSL/TLS hiện có thời hạn tối đa là 13 tháng. Trong những năm qua, thời hạn này đã dần được rút ngắn nhằm giảm thiểu rủi ro bảo mật cho doanh nghiệp và người dùng web. Ví dụ, bên thứ ba không đáng tin có thể tận dụng chứng chỉ vẫn còn hiệu lực của một tên miền đã hết hạn để tạo ra một trang web trái phép.
	- Việc rút ngắn thời gian hiệu lực sẽ giúp hạn chế khả năng bị lạm dụng. Khi chứng chỉ SSL/TLS hết hạn, trình duyệt sẽ cảnh báo người dùng rằng trang web không còn an toàn. Do đó, tổ chức cần thu hồi chứng chỉ cũ và thay thế bằng chứng chỉ mới được gia hạn. Quá trình gia hạn này cần hoàn tất trước khi chứng chỉ hiện tại hết hạn để tránh các sự cố bảo mật.

### 3.2 Các loại chứng chỉ SSL:
#### 3.2.1 Theo cấp độ xác thực 
- Mục đích chính của chứng chỉ SSL là nhằm xác minh danh tính máy chủ trên mạng 
- Để thực hiện điều đó, mỗi chứng chỉ chứa thông tin về thực thể được cấp chứng chỉ. Mức độ chi tiết của thông tin phụ thuộc vào cấp độ xác thực của chứng chỉ. SSL có ba cấp độ xác thực.
	- DV (Domain Validation) 
		- Xác thực tên miền (Domain Validation) là cấp độ xác thực nhẹ nhất trong các loại chứng chỉ SSL. Với chứng chỉ DV, điều duy nhất được xác thực về danh tính của người sở hữu chứng chỉ là họ thực sự có quyền kiểm soát tên miền mà chứng chỉ được cấp cho.
		- Ưu điểm chính của chứng chỉ DV là có thể được cấp trong vài phút. Chứng chỉ DV được khuyến nghị sử dụng trong các trường hợp chỉ cần mã hóa hoặc yêu cầu có chứng chỉ, nhưng không phải mục tiêu của các cuộc tấn công lừa đảo và không đòi hỏi phải tạo dựng sự tin tưởng đặc biệt với người truy cập trang web.
	- OV (Organization Validation)
		- Xác thực tổ chức là cấp độ xác thực trung bình trong các loại chứng chỉ SSL. Chứng chỉ OV đưa ra tuyên bố về danh tính của tổ chức được cấp chứng chỉ và nơi tổ chức đó hoạt động.
		- Việc xác thực OV chủ yếu do từng tổ chức cấp chứng chỉ (CA) quyết định. Mặc dù chứng chỉ này cung cấp thông tin về danh tính tổ chức, nhưng do quy trình xác thực không được thực hiện và kiểm toán ở một tiêu chuẩn chung toàn cầu nên các trình duyệt phổ biến không hiển thị tên công ty trong thanh địa chỉ.
	- EV (Extended Validation)
		- Xác thực mở rộng (Extended Validation – EV) là cấp độ xác thực SSL cao nhất. Danh tính của chủ sở hữu chứng chỉ EV được xác minh theo một bộ giao thức tiêu chuẩn, được đánh giá là có độ tin cậy cao và đã được kiểm chứng qua thực tiễn sử dụng rộng rãi.
		- Vì mức độ tin tưởng cao đối với thông tin trong loại chứng chỉ này, hầu hết các trình duyệt phổ biến đều hiển thị biểu tượng tin cậy màu xanh lá (thanh địa chỉ màu xanh), kèm theo tên của tổ chức ở bên trái đường dẫn URL. Nhiều trình duyệt còn cung cấp thêm thông tin như thành phố nơi tổ chức hoạt động và tên của cơ quan cấp chứng chỉ.
		- Chứng chỉ EV được khuyến nghị sử dụng cho các ứng dụng cần tối đa hóa giao dịch hoặc xây dựng lòng tin với người dùng, các ứng dụng xử lý thông tin giá trị cao như dữ liệu nhận dạng cá nhân (PII) hoặc số thẻ tín dụng, hay các ứng dụng yêu cầu tuân thủ tiêu chuẩn cần EV. EV hiện là chuẩn mặc định cho các doanh nghiệp trực tuyến như ngân hàng, cửa hàng, sàn giao dịch, cổng khai thuế, dịch vụ y tế và các tài khoản mạng xã hội.
#### 3.2.2 Theo phạm vi bảo vệ
- Mặc dù mỗi tên miền cụ thể cần được bảo vệ bằng chứng chỉ SSL để kích hoạt mã hóa và các chỉ báo tin cậy trên trình duyệt, nhưng vẫn có thể sử dụng các loại chứng chỉ có thể bảo vệ nhiều tên miền cùng lúc.
- Xét về phạm vi bảo vệ tên miền, chứng chỉ SSL được chia thành ba loại.
	- Basic SSL certificates
		- Chứng chỉ SSL cơ bản chỉ bảo vệ một tên miền hoặc tên miền phụ. Muốn bảo vệ nhiều tên miền, bạn cần nhiều chứng chỉ tương ứng. Tuy nhiên, phần lớn CA sẽ cấp chứng chỉ cho cả www.domain.com và domain.com trong cùng một chứng chỉ.
		- Chứng chỉ cơ bản có thể áp dụng ở cả 3 mức xác thực: DV, OV, và EV. Dù bảo mật tốt, nhưng sử dụng nhiều chứng chỉ riêng lẻ sẽ tốn công quản lý hơn, đặc biệt trong hệ thống phức tạp.
	- Wildcard SSL certificates 
		- Chứng chỉ SSL Wildcard có thể bảo vệ nhiều tên miền phụ dưới một tên miền gốc chính. 
		- Ví dụ, một chứng chỉ wildcard cho domain.com sẽ bảo vệ được các tên miền như:
			- www.domain.com
			- login.domain.com
			- cart.domain.com
			- ftp.domain.com
		- và bất kỳ tên miền phụ nào khác của domain.com. Trong trường hợp này, tên miền gốc domain.com cũng sẽ được bảo vệ.
		- Wildcard cũng có thể áp dụng cho một tên miền phụ cụ thể, từ đó bảo vệ các tên miền con sâu hơn. Ví dụ, một chứng chỉ wildcard cho shop.domain.com sẽ áp dụng được cho:
			- a.shop.domain.com
			- b.shop.domain.com
		- Tuy nhiên, một wildcard không thể áp dụng cho nhiều tên miền gốc khác nhau. Ví dụ, wildcard của domain.com sẽ không thể bảo vệ example.com hoặc bất kỳ tên miền phụ nào của nó. Tương tự, wildcard cho shop.domain.com sẽ không hoạt động với checkout.domain.com.
		- Wildcard thuận tiện hơn đáng kể trong việc cấp phát và quản lý nếu bạn có nhiều tên miền phụ. Có thể tạo thêm các tên miền phụ mới sau khi chứng chỉ được phát hành mà vẫn sử dụng cùng chứng chỉ đó.
		- Chứng chỉ Wildcard có thể được cấp ở mức DV (Domain Validation) và OV (Organization Validation). Tuy nhiên, theo tiêu chuẩn hiện hành, không được phép cấp chứng chỉ Wildcard ở mức EV (Extended Validation). Vì vậy, với các website hướng tới công chúng yêu cầu độ tin cậy cao (như trang thương mại điện tử có các tên miền phụ như www., shop., checkout.), nên cân nhắc dùng chứng chỉ đa miền EV.
	- Multi-domain or SAN certificates 
		- Chứng chỉ đa miền (Multi-domain) hoặc SAN cho phép một chứng chỉ duy nhất bảo vệ tối đa 100 tên miền cụ thể. Không giống như chứng chỉ wildcard, chứng chỉ đa miền có thể bảo vệ bất kỳ tập hợp tên miền nào bằng cùng một chứng chỉ. Ví dụ, một chứng chỉ đa miền có thể bảo vệ:
			- www.domain.com
			- ftp.domain.net
			- shop.domain.com
			- a.shop.domain.mobi
			- www.example.com
			- login.example.com
		- Chứng chỉ đa miền có thể được cấp ở các mức xác thực DV, OV và EV. Mỗi tên miền bổ sung được bảo vệ trong chứng chỉ đa miền được gọi là SAN (Subject Alternative Name). Các chứng chỉ có SAN đôi khi được gọi là chứng chỉ SAN thay vì chứng chỉ đa miền, nhưng cả hai thuật ngữ đều mang cùng một ý nghĩa.
		- Chứng chỉ đa miền có thể thuận tiện hơn so với chứng chỉ cơ bản trong các môi trường phức tạp. Tuy nhiên, vì nhiều tên miền được bảo vệ bởi một chứng chỉ duy nhất, nên chúng không được khuyến nghị cho các môi trường nhạy cảm đòi hỏi mức độ bảo mật cao nhất. Do chứng chỉ đa miền có thể được phát hành ở mức xác thực mở rộng (EV), chúng là lựa chọn phù hợp cho các trang web doanh nghiệp hướng đến người dùng có nhiều tên miền phụ, chẳng hạn như các trang bán lẻ trực tuyến.
#### 3.2.3 Theo nguồn cấp 
- Ngoài việc phân loại chứng chỉ SSL theo phạm vi bảo vệ tên miền (cơ bản, wildcard, đa miền) và cấp độ xác thực (DV, OV, EV), chứng chỉ SSL còn được phân loại dựa trên nguồn cấp phát
	- Chứng chỉ tự ký (Self-Signed Certificates):
		- Được tạo và ký bởi chính thực thể sử dụng chứng chỉ (ví dụ: chủ sở hữu website).
		- Không được các trình duyệt hoặc hệ thống tin tưởng mặc định.
		- Yêu cầu thiết lập tin cậy thủ công (ví dụ: thêm chứng chỉ vào danh sách tin cậy).
		- Thường được sử dụng cho kiểm thử nội bộ, phát triển hoặc mạng riêng — nơi mức độ tin cậy không quá quan trọng.
		- Không trải qua quy trình xác thực của tổ chức cấp chứng chỉ (CA).
		- Tiềm ẩn rủi ro bảo mật do thiếu xác thực từ bên thứ ba.
	- Chứng chỉ do CA cấp (CA-Signed Certificates):
		- Được tạo và ký bởi một tổ chức cấp chứng chỉ đáng tin cậy (CA).
		- Được hầu hết các trình duyệt và hệ thống tin tưởng tự động.
		- Trải qua quy trình xác thực bởi CA.
		- Được ưu tiên sử dụng cho các website và ứng dụng hướng ra công chúng nhờ mức độ tin cậy cao.
		- Cung cấp sự đảm bảo về danh tính của website.
		- Có thể bị thu hồi bởi CA khi cần thiết.


### 3.3 Mã hóa trong SSL/TLS:
- Mã hóa (Encryption) là quá trình chuyển đổi thông tin từ dạng ban đầu thành dạng không đọc được bằng cách sử dụng thuật toán và khóa mật mã.
`Dữ liệu + Khóa >>> Thuật toán mã hóa >>> Dữ liệu được mã hóa`
- Giải mã (Decryption)là quá trình chuyển dữ liệu đã được mã hóa trở lại dưới dạng thông tin có thể đọc được
`Dữ liệu được mã hóa + Khóa >>> Thuật toán giải mã >>> Dữ liệu`
- Mã hóa SSL/TLS thiết lập một kết nối an toàn và được mã hóa giữa máy khách (như trình duyệt web) và máy chủ (như một trang web) bằng cách sử dụng kết hợp giữa mã hóa bất đối xứng và đối xứng. Điều này ngăn chặn các bên không được phép đọc hoặc can thiệp vào dữ liệu được truyền trong suốt phiên làm việc đó.
	- Bước 1: Mã hóa bất đối xứng (Asymmetric Encryption):	Khi trình duyệt (client) kết nối đến máy chủ (server), máy chủ gửi chứng chỉ số chứa khóa công khai. Trình duyệt xác minh chứng chỉ này thông qua một Tổ chức cấp chứng chỉ (CA) trong hệ thống PKI. Sau đó, trình duyệt sử dụng khóa công khai này để mã hóa một khóa phiên (session key) và gửi lại cho máy chủ.
	- Bước 2: Mã hóa đối xứng (Symmetric Encryption): Máy chủ sử dụng khóa riêng tư để giải mã khóa phiên. Từ thời điểm đó, cả hai bên sử dụng khóa phiên đối xứng này để mã hóa và giải mã dữ liệu truyền đi — vì mã hóa đối xứng nhanh hơn và hiệu quả hơn cho truyền dữ liệu liên tục.
- Ví dụ quy trình giao tiếp giữa client-server 
	- Máy khách liên hệ với máy chủ bằng một URL bảo mật (HTTPS…).
	- Máy chủ gửi cho máy khách chứng chỉ và khóa công khai của mình.
	- Máy khách xác minh chứng chỉ này với một Tổ chức chứng thực gốc đáng tin cậy để đảm bảo tính hợp lệ.
	- Máy khách và máy chủ đàm phán loại mã hóa mạnh nhất mà cả hai bên hỗ trợ.
	- Máy khách mã hóa một khóa phiên (bí mật) bằng khóa công khai của máy chủ và gửi lại cho máy chủ.
	- Máy chủ sử dụng khóa riêng để giải mã thông tin từ máy khách và thiết lập phiên kết nối.
	- Khóa phiên (mã hóa đối xứng) giờ đây được sử dụng để mã hóa và giải mã dữ liệu truyền giữa máy khách và máy chủ.
#### 3.3.1 Mã hóa đối xứng (Symmetric Encryption).
- Mã hóa đối xứng (hay mã hóa bằng khóa chia sẻ trước) sử dụng một khóa duy nhất để mã hóa và giải mã dữ liệu. Cả người gửi và người nhận đều cần có cùng một khóa để giao tiếp.
- Kích thước khóa đối xứng thường là 128 hoặc 256 bit — khóa càng dài thì càng khó bị phá vỡ.
- Việc sử dụng khóa 128 hay 256 bit phụ thuộc vào khả năng mã hóa của cả máy chủ và phần mềm phía máy khách. Chứng chỉ TLS/SSL không quyết định kích thước khóa được sử dụng.
- Phương pháp này có tốc độ xử lý nhanh và thường dùng để mã hóa dữ liệu trong suốt phiên làm việc sau khi khóa được trao đổi an toàn. Tuy nhiên, điểm yếu của nó là việc phân phối khóa — nếu khóa bị lộ, toàn bộ dữ liệu có thể bị giải mã.
- ![images](./images/symmetric-encryption.png)
#### 3.3.2 Mã hóa bất đối xứng (Asymmetric Encryption).
- Mã hóa bất đối xứng, còn được gọi là Mật mã khóa công khai sử dụng hai khóa riêng biệt để mã hóa và giải mã. Với mã hóa bất đối xứng, bất kỳ ai cũng có thể sử dụng khóa công khai để mã hóa một thông điệp. Tuy nhiên, khóa giải mã được giữ bí mật. Nhờ đó, chỉ người nhận dự kiến mới có thể giải mã thông điệp.
- Thuật toán mã hóa bất đối xứng phổ biến nhất là RSA. RSA là viết tắt của Ron Rivest, Adi Shamir và Leonard Adleman — những người đầu tiên công bố thuật toán này vào năm 1977. Các khóa bất đối xứng thường có độ dài 1024 hoặc 2048 bit. Tuy nhiên, các khóa nhỏ hơn 2048 bit hiện không còn được xem là an toàn. Khóa 2048 bit có hàng loạt mã hóa duy nhất với độ dài lên tới 617 chữ số.
- Dù có thể tạo ra các khóa lớn hơn, nhưng gánh nặng tính toán tăng lên đáng kể khiến các khóa lớn hơn 2048 bit hiếm khi được sử dụng. Để dễ hình dung, một máy tính trung bình sẽ mất hơn 14 tỷ năm để phá vỡ một chứng chỉ 2048 bit.
- ![images](./images/asymmetric-encryption.png)

| Tiêu chí                    | Mã hóa đối xứng                         | Mã hóa bất đối xứng                           |
| --------------------------- | --------------------------------------- | --------------------------------------------- |
| **Số lượng khóa sử dụng**   | 1 khóa (dùng chung để mã hóa & giải mã) | 2 khóa (khóa công khai & khóa riêng tư)       |
| **Tốc độ xử lý**            | Nhanh hơn                               | Chậm hơn do tính toán phức tạp hơn            |
| **Bảo mật khi truyền khóa** | Cần kênh an toàn để chia sẻ khóa        | Không cần chia sẻ khóa riêng tư               |
| **Ứng dụng phổ biến**       | Mã hóa dữ liệu trong phiên làm việc     | Trao đổi khóa an toàn, xác thực danh tính     |
| **Thuật toán tiêu biểu**    | AES, DES, RC4                           | RSA, ECC                                      |
| **Độ dài khóa phổ biến**    | 128 hoặc 256 bit                        | 2048 bit trở lên                              |
| **Rủi ro bảo mật**          | Nếu khóa bị lộ, toàn bộ dữ liệu bị nguy | Khó bị tấn công nếu giữ khóa riêng tư an toàn |


#### 3.3.3 Thuật toán trao đổi khóa (Diffie-Hellman, RSA, ECC).
##### DH (Diffie-Hellman)
- Trao đổi khóa Diffie–Hellman (D-H) là một phương pháp trao đổi khóa được phát minh sớm nhất trong mật mã học. Phương pháp trao đổi khóa Diffie–Hellman cho phép hai bên (người, thực thể giao tiếp) thiết lập một khóa bí mật chung để mã hóa dữ liệu sử dụng trên kênh truyền thông không an toàn mà không cần có sự thỏa thuận trước về khóa bí mật giữa hai bên. Khóa bí mật tạo ra sẽ được sử dụng để mã hóa dữ liệu với phương pháp mã hóa khóa đối xứng.
- Giao thức này được công bố đầu tiên bởi Whitfield Diffie và Martin Hellman vào năm 1976
- Giao thức này tận dụng các đặc tính toán học của logarit rời rạc và số học mô-đun để đảm bảo rằng ngay cả khi kẻ thù chặn được đường truyền, chúng cũng không thể lấy được khóa bí mật chung.
- Tính bảo mật của trao đổi khóa Diffie-Hellman dựa trên độ khó của Bài toán logarit rời rạc (DLP). DLP tuyên bố rằng với một số nguyên tố lớn nhất định p, một gốc nguyên thủy g hình thức p, và một số y như vậy mà y = g^x \mod p, về mặt tính toán không thể xác định được x được y, gvà p. Tính khó điều chỉnh này là nền tảng cho tính bảo mật của giao thức.
- Các bước giao thức
1. Tạo tham số:
– Alice và Bob đồng ý về một số nguyên tố lớn p và một gốc nguyên thủy g hình thức p. Những giá trị này không cần phải giữ bí mật và có thể được chia sẻ một cách công khai. Sự lựa chọn của p và g là rất quan trọng; p phải đủ lớn để chống lại các cuộc tấn công, thường ít nhất là 2048 bit trong các triển khai hiện đại.
2. Lựa chọn khóa riêng tư:
– Alice chọn khóa riêng a, là một số nguyên ngẫu nhiên sao cho 1 < a < p-1.
– Bob chọn khóa riêng b, tương tự như vậy là một số nguyên ngẫu nhiên sao cho 1 < b < p-1.
3. Tính toán khóa công khai:
– Alice tính toán khóa công khai của mình A as A = g^a \mod p.
– Bob tính khóa công khai của mình B as B = g^b \mod p.
4. Trao đổi khóa công khai:
– Alice gửi khóa công khai của mình A gửi Bob.
– Bob gửi khóa công khai của mình B tới Alice.
5. Tính toán bí mật được chia sẻ:
– Alice tính toán bí mật được chia sẻ S as S = B^a \mod p.
– Bob tính toán bí mật được chia sẻ S as S = A^b \mod p.
- Do đặc tính của số học mô-đun, cả hai phép tính đều dẫn đến cùng một bí mật chung S
  \[ S = (g^b \mod p)^a \mod p = g^{ba} \mod p \]
  \[ S = (g^a \mod p)^b \mod p = g^{ab} \mod p \]
- Vì vậy, Alice và Bob bây giờ chia sẻ một bí mật chung S có thể được sử dụng để liên lạc an toàn hơn.
- Ví dụ 
- ![images](./images/DiffieHellman.png)
- Ưu điểm:
	- Hỗ trợ trao đổi khóa an toàn: Thuật toán Diffie-Hellman cho phép hai thực thể thiết lập một khóa chung bí mật qua kênh truyền không bảo mật, khóa này sau đó được sử dụng trong các hệ thống mã hóa đối xứng.
	- Perfect Forward Secrecy: Việc lộ khóa riêng không ảnh hưởng đến tính bảo mật của các phiên giao tiếp trước đó, do mỗi phiên sử dụng khóa tạm thời khác nhau.
	- Không yêu cầu dữ liệu tiền chia sẻ: Các bên tham gia không cần có kiến thức hay khóa bảo mật chung trước đó để thiết lập phiên làm việc bảo mật.
- Nhược điểm: 
	- Dễ bị tấn công kiểu Man-in-the-Middle: Nếu không áp dụng biện pháp xác thực bổ sung, kẻ tấn công có thể giả mạo một trong hai bên, chèn vào quá trình trao đổi và kiểm soát phiên giao tiếp.
	- Thiếu cơ chế xác thực tích hợp: Giao thức không bao gồm thành phần xác minh danh tính, làm tăng rủi ro bị giả mạo.
	- Tốn tài nguyên khi sử dụng khóa kích thước lớn: Việc sử dụng khóa có độ dài lớn để tăng tính bảo mật sẽ làm gia tăng chi phí tính toán.
	- Không thích hợp cho chữ ký số: Diffie-Hellman không hỗ trợ việc tạo và xác minh chữ ký điện tử, do mục đích thiết kế chỉ nhằm trao đổi khóa.
	- Không an toàn trước tấn công lượng tử: Thuật toán dựa trên độ khó của bài toán logarit rời rạc, vốn có thể bị giải quyết hiệu quả bằng máy tính lượng tử thông qua thuật toán Shor.

##### RSA (Rivest–Shamir–Adleman)
- RSA là một thuật toán mã hóa khóa công khai, được sử dụng rộng rãi trong nhiều ứng dụng bảo mật, như chữ ký số, xác thực, mã hóa đường truyền, v.v. RSA được đặt theo tên của ba nhà khoa học đã phát minh ra nó: Ron Rivest, Adi Shamir và Leonard Adleman.
- RSA được phát minh vào năm 1977 bởi ba nhà khoa học làm việc tại Viện Công nghệ Massachusetts (MIT). 
- Trao đổi khóa RSA là quá trình hai bên liên lạc chia sẻ khóa công khai của họ để có thể mã hóa và giải mã thông tin một cách an toàn. Điều này cho phép họ trao đổi thông tin mật mà không cần phải chia sẻ khóa riêng tư, vốn là bí mật và chỉ được giữ bởi chủ sở hữu.
- Thuật toán RSA dựa trên việc phân tích số nguyên lớn thành thừa số nguyên tố và sử dụng số học modulo để mã hóa và giải mã dữ liệu. Nó bao gồm ba giai đoạn chính:
- **Sinh khóa**: Tạo ra Khóa công khai và Khóa riêng  
- **Mã hóa**: Người gửi mã hóa dữ liệu bằng Khóa công khai để tạo ra bản mã (cipher text)  
- **Giải mã**: Giải mã bản mã bằng Khóa riêng để khôi phục dữ liệu ban đầu
- ![images](./images/RSA-Encryption-Works.png)
- Cụ thể các quá trình
	- Sinh khoá 
		- Chọn hai số nguyên tố lớn, gọi là p và q. Hai số nguyên tố này cần được giữ bí mật.
		- Tính tích của hai số nguyên tố: n = p × q. Giá trị n là một phần của cả khóa công khai lẫn khóa riêng.
		- Tính hàm phi Euler Φ(n) theo công thức:
		`Φ(n) = Φ(p × q) = Φ(p) × Φ(q) = (p − 1) × (q − 1)`
		- Chọn số mũ mã hóa e, sao cho:
		`1 < e < Φ(n)` và `gcd(e, Φ(n)) = 1`, nghĩa là e phải nguyên tố cùng nhau với Φ(n).
		- Tính số mũ giải mã d, sao cho:`(d × e) ≡ 1 mod Φ(n)`, tức là d là nghịch đảo modular của e theo modulo Φ(n).
		- Một số phương pháp phổ biến để tính nghịch đảo modular là: Thuật toán Euclid mở rộng, Định lý Fermat nhỏ, v.v.
		- Có thể tồn tại nhiều giá trị d thỏa mãn (d × e) ≡ 1 mod Φ(n), nhưng không quan trọng chọn giá trị nào, vì tất cả đều là khóa hợp lệ và sẽ giải mã ra cùng một thông điệp.
		- Cuối cùng:
			- Khóa công khai = (n, e)
			- Khóa riêng = (n, d)
	- Mã hoá: Sử dụng khóa công khai (n, e) để mã hóa thông điệp và tạo bản mã (cipher text) theo công thức: `C = Mᵉ mod n`, trong đó C là bản mã, còn e và n là các thành phần của khóa công khai.
	- Giải mã: Để giải mã bản mã C, sử dụng khóa riêng (n, d) để khôi phục dữ liệu ban đầu theo công thức: `M = Cᵈ mod n`, trong đó M là thông điệp gốc, còn d và n là các thành phần của khóa riêng.
- Ví dụ 
```
Chọn p = 3 và q = 11  
Tính n = p × q = 3 × 11 = 33  
Tính φ(n) = (p − 1) × (q − 1) = 2 × 10 = 20  
Chọn e sao cho 1 < e < φ(n) và e nguyên tố cùng nhau với φ(n). Chọn e = 7  
Tính d sao cho (d × e) % φ(n) = 1. Một nghiệm là d = 3 [(3 × 7) % 20 = 1]  
Khóa công khai là (e, n) => (7, 33)  
Khóa riêng là (d, n) => (3, 33)  
Mã hóa m = 2 được: c = 2⁷ % 33 = 29  
Giải mã c = 29 được: m = 29³ % 33 = 2
```
- Ưu điểm
	- Bảo mật cao: Thuật toán RSA được xem là rất an toàn và được sử dụng rộng rãi trong việc truyền dữ liệu bảo mật.
	- Mật mã khóa công khai: RSA là thuật toán mật mã bất đối xứng, sử dụng hai khóa khác nhau—khóa công khai để mã hóa và khóa riêng để giải mã.
	- Trao đổi khóa an toàn: Cho phép hai bên thiết lập một khóa bí mật mà không cần truyền trực tiếp khóa này qua mạng.
	- Chữ ký số: Có thể được sử dụng để tạo chữ ký số, trong đó người gửi ký bằng khóa riêng và người nhận xác minh bằng khóa công khai của người gửi.
	- Ứng dụng rộng rãi: Được triển khai trong các lĩnh vực như ngân hàng trực tuyến, thương mại điện tử và truyền thông an toàn.
- Nhược điểm
	- Tốc độ xử lý chậm: Chậm hơn so với nhiều thuật toán mã hóa khác, đặc biệt là khi xử lý dữ liệu có dung lượng lớn.
	- Kích thước khóa lớn: Đòi hỏi khóa có độ dài lớn để đảm bảo an toàn, dẫn đến việc tiêu tốn nhiều tài nguyên tính toán và không gian lưu trữ.
	- Dễ bị tấn công kênh phụ: Có thể bị tấn công thông qua các kênh rò rỉ như tiêu thụ năng lượng, bức xạ điện từ hoặc phân tích thời gian thực thi để lấy khóa riêng.
	- Hạn chế trong một số ứng dụng: Không phù hợp với những ứng dụng yêu cầu mã hóa và giải mã liên tục với lượng lớn dữ liệu do tốc độ thấp.
	- Độ phức tạp cao: Là một thuật toán toán học phức tạp, có thể gây khó khăn trong việc hiểu và triển khai.
	- Quản lý khóa khó khăn: Việc bảo mật khóa riêng là điều bắt buộc, nhưng đôi khi có thể gặp nhiều khó khăn trong quá trình triển khai thực tế.
	- Không an toàn trước máy tính lượng tử: RSA có thể bị phá vỡ bởi máy tính lượng tử, vì các thuật toán như Shor có thể giải được bài toán phân tích thừa số rất nhanh.

##### ECC (Elliptic Curve Cryptography)
- Mã hoá đường cong elliptic (Elliptic Curve Cryptography – ECC) là một phương pháp mạnh mẽ và hiệu quả trong lĩnh vực mật mã khóa công khai, cung cấp mức độ bảo mật cao với kích thước khóa nhỏ hơn so với các phương pháp truyền thống. 
- ECC (Elliptic Curve Cryptography) là một hệ thống mật mã khóa công khai dựa trên cấu trúc đại số của các đường cong elliptic trên trường hữu hạn.  
- Nó cung cấp mức độ bảo mật tương đương với RSA nhưng sử dụng độ dài khóa ngắn hơn nhiều, từ đó giúp tăng tốc độ xử lý và giảm mức tiêu thụ tài nguyên.  
- ECC được ứng dụng rộng rãi trong nhiều lĩnh vực như truyền thông an toàn, chữ ký số và tiền mã hóa.
- Elliptic Curve
	- Đường cong elliptic là một đường cong toán học được xác định bởi phương trình:
	`y² = x³ + ax + b`
	- Trong đó a và b là các hằng số. Trong lĩnh vực mật mã, đường cong elliptic được sử dụng trên các trường hữu hạn, tức là các tọa độ x và y bị giới hạn trong một phạm vi giá trị nguyên nhất định.
	- ![images](./images/Elliptic-Curve-Cryptography.png)
	- Các tính chất chính của đường cong elliptic:
		- Đối xứng qua trục hoành (x-axis)
		- Không kỳ dị (không có điểm nhọn hoặc tự cắt)
		- Mỗi đường thẳng đứng cắt đường cong tại nhiều nhất ba điểm
- ECC tận dụng các tính chất toán học của đường cong elliptic để xây dựng hệ thống mật mã an toàn. Mô tả đơn giản hóa về quy trình:
	- Chọn một đường cong elliptic cùng với một điểm trên đường cong đó làm điểm sinh (G).
	- Chọn một khóa riêng, là một số nguyên ngẫu nhiên.
	- Nhân điểm sinh G với khóa riêng để thu được khóa công khai.
	- Sử dụng khóa công khai để mã hóa hoặc xác minh chữ ký.
- Ví dụ: Giả sử:
	- Chọn một đường cong elliptic công khai và một điểm sinh G trên đường cong.
		- Alice chọn khóa riêng là a = 5, tính khóa công khai A = aG.
		- Bob chọn khóa riêng là b = 7, tính khóa công khai B = bG.
	- Trao đổi khóa:
		- Alice nhận B từ Bob và tính S = aB = a(bG) = abG.
		- Bob nhận A từ Alice và tính S = bA = b(aG) = abG.
	- Cả hai bên đều tính được cùng một điểm S = abG, được dùng làm khóa phiên để mã hóa dữ liệu.
- Ví dụ khác về ECC ứng dụng với Diffie-Hellman -> ECDH: 
	- Các bước để Alice và Bob trao đổi khóa một cách an toàn (trong khi Cathy là kẻ tấn công nghe lén), mà không cần chia sẻ khóa trước:
		- Alice, Bob và Cathy cùng thống nhất về một đường cong elliptic công khai và một điểm cố định trên đường cong đó, gọi là G.
		- Alice chọn một số nguyên ngẫu nhiên α làm khóa riêng của mình.
		- Alice tính khóa công khai: A = αG (nhân vô hướng). Cô công khai A.
		- Bob chọn một số nguyên ngẫu nhiên β làm khóa riêng của mình.
		- Bob tính khóa công khai: B = βG và công khai B.
		- Cathy cũng thực hiện tương tự để tạo khóa riêng và khóa công khai của mình.
	- Giả sử Alice muốn gửi thông điệp cho Bob:
		- Alice tính P = αB = α(βG) và dùng P làm khóa riêng của phiên liên lạc.
		- Bob tính P = βA = β(αG) và cũng dùng P cho phiên liên lạc.
		- Do αB = α(βG) = β(αG) = βA, nên chỉ có Alice và Bob biết khóa phiên P.
	- Còn nếu Cathy muốn đọc cuộc trò chuyện giữa Alice và Bob:
		- Cathy biết đường cong elliptic, điểm G, bậc của G và khóa công khai A và B của Alice và Bob.
		- Tuy nhiên, Cathy không biết α và β (các khóa riêng), và để tính được P, cô ta cần giải được Bài toán logarit rời rạc trên đường cong elliptic—điều này được coi là cực kỳ khó trong thực tế.
	- ![images](./images/ecdh.png)
- Tính bảo mật của ECC dựa trên độ khó của Bài toán Logarit rời rạc trên đường cong elliptic (ECDLP)—tức là bài toán tìm giá trị vô hướng (scalar) đã được dùng để nhân một điểm trên đường cong.
- Ưu điểm của ECC
	- Kích thước khóa nhỏ hơn: ECC cung cấp mức độ bảo mật tương đương RSA nhưng với độ dài khóa ngắn hơn đáng kể. Ví dụ: một khóa ECC 256-bit có mức bảo mật tương đương với khóa RSA 3072-bit.
	- Tốc độ tính toán nhanh hơn: Kích thước khóa nhỏ hơn giúp giảm thời gian xử lý, làm cho ECC hiệu quả hơn trên các thiết bị có tài nguyên hạn chế.
	- Tốn ít tài nguyên hơn: ECC yêu cầu ít bộ nhớ và băng thông hơn, lý tưởng cho các thiết bị di động và ứng dụng IoT.
	- Tính thích ứng trong tương lai: Khi năng lực tính toán tăng lên, ECC mở rộng bảo mật hiệu quả hơn so với RSA, chỉ cần tăng nhẹ độ dài khóa để duy trì mức độ an toàn.
- Một số hạn chế của ECC
	- Vấn đề bằng sáng chế: Một số thuật toán ECC từng được cấp bằng sáng chế, điều này ban đầu đã làm chậm quá trình phổ biến. Tuy nhiên, nhiều bằng sáng chế quan trọng hiện nay đã hết hiệu lực.
	- Độ phức tạp khi triển khai: Việc triển khai chính xác ECC có thể phức tạp hơn so với RSA, đòi hỏi sự cẩn trọng trong từng chi tiết kỹ thuật.
	- Mối đe dọa từ máy tính lượng tử: Tương tự như các hệ mật mã khóa công khai khác, ECC cũng có thể bị tấn công bởi các máy tính lượng tử quy mô lớn (mặc dù ít chịu ảnh hưởng hơn so với RSA).
	- Hạn chế trong mức độ triển khai: Dù có nhiều lợi thế, ECC vẫn chưa được áp dụng rộng rãi như RSA trong một số lĩnh vực, điều này có thể dẫn đến các vấn đề về khả năng tương thích.
##### So sánh 

| Tiêu chí                        | Diffie-Hellman (DH)                    | RSA                                            | Elliptic Curve Diffie-Hellman (ECDH)               |
| ------------------------------- | -------------------------------------- | ---------------------------------------------- | -------------------------------------------------- |
| **Loại thuật toán**             | Mật mã khóa công khai (trao đổi khóa)  | Mật mã khóa công khai (mã hóa & trao đổi khóa) | Mật mã khóa công khai dựa trên đường cong elliptic |
| **Cơ sở toán học**              | Logarit rời rạc trong trường số nguyên | Phân tích thừa số nguyên lớn                   | Logarit rời rạc trên đường cong elliptic (ECDLP)   |
| **Kích thước khóa tương đương** | 2048 bit (an toàn hiện tại)            | 3072 bit                                       | 256 bit ECC ≈ 3072 bit RSA                         |
| **Hiệu suất**                   | Trung bình                             | Chậm với khóa lớn                              | Nhanh, hiệu quả trên thiết bị hạn chế tài nguyên   |
| **Tính bảo mật**                | Bảo mật tốt, nhưng không xác thực      | Bảo mật tốt, hỗ trợ xác thực                   | Bảo mật cao, cần xác thực bổ sung                  |
| **Chống tấn công lượng tử**     | Không an toàn                          | Không an toàn                                  | Không an toàn, nhưng tốt hơn RSA                   |

#### 3.3.4 Các thuật toán mã hóa phổ biến (AES, 3DES, ChaCha20).
##### AES
- Chuẩn mã hóa nâng cao (Advanced Encryption Standard – AES) là một thuật toán mã hóa rất đáng tin cậy, được sử dụng để bảo vệ dữ liệu bằng cách chuyển đổi nó thành dạng không thể đọc được nếu không có khóa giải mã phù hợp. Thuật toán này được phát triển bởi Viện Tiêu chuẩn và Công nghệ Quốc gia Hoa Kỳ (NIST) vào năm 2001.
- Hiện nay, AES được sử dụng rộng rãi vì mạnh hơn nhiều so với DES và Triple DES, dù việc triển khai có phần phức tạp hơn. AES hỗ trợ nhiều độ dài khóa khác nhau (128, 192 hoặc 256 bit), mang lại khả năng bảo mật mạnh mẽ chống lại truy cập trái phép. Giải pháp bảo mật này hiệu quả và được áp dụng phổ biến trong việc đảm bảo an toàn truyền thông trên Internet, bảo vệ dữ liệu nhạy cảm và mã hóa tệp tin.
- Đặc điểm của AES
	- AES là một mã khối (Block Cipher).
	- Kích thước khóa có thể là 128, 192 hoặc 256 bit.
	- AES mã hóa dữ liệu theo các khối 128 bit.
- AES là một thuật toán mã hóa khối đối xứng với độ dài khóa là 128 bít (một chữ số nhị phân có giá trị 0 hoặc 1), 192 bít và 256 bít tương ứng dọi là AES-128, AES-192 và AES-256. AES-128 sử dụng 10 vòng (round), AES-192 sử dụng 12 vòng và AES-256 sử dụng 14 vòng.
- Quy trình mã hóa AES: Mã hóa AES bao gồm một chuỗi bước nhằm biến plaintext thành ciphertext, với các giai đoạn chính như sau:
	- Mở rộng khóa (Key Expansion): Khóa mã hóa được mở rộng thành một dãy các khóa vòng (round keys), mỗi vòng sẽ sử dụng một khóa riêng biệt được suy ra từ khóa ban đầu.
	- Vòng khởi đầu – AddRoundKey: Khối plaintext được kết hợp với khóa vòng đầu tiên bằng phép XOR (loại trừ theo bit), bắt đầu quá trình trộn dữ liệu với khóa mã hóa.
	- Các vòng biến đổi (Transformation Rounds)
	- Mỗi vòng (trừ vòng cuối) thực hiện các bước sau:
		- SubBytes (Thay thế): Mỗi byte trong khối được thay bằng một byte khác từ S-box – một bảng tra phi tuyến được xác định trước – để tăng mức độ nhiễu giữa plaintext và ciphertext.
		 - ShiftRows (Hoán vị hàng): Ma trận dữ liệu 4×4 bị dịch theo hàng:
			- Hàng 0: giữ nguyên
			- Hàng 1: dịch trái 1 byte
			- Hàng 2: dịch trái 2 byte
			- Hàng 3: dịch trái 3 byte
			- Việc này làm thay đổi vị trí byte, gia tăng tính phức tạp của dữ liệu.
		- MixColumns (Trộn cột): Mỗi cột được biến đổi bằng toán học trên trường Galois, làm lan tỏa ảnh hưởng của mỗi byte tới toàn bộ khối.
		- AddRoundKey: XOR khối dữ liệu hiện tại với khóa vòng tương ứng, tiếp tục đưa yếu tố khóa vào quá trình mã hóa.
	- Vòng cuối cùng (Final Round): Vòng cuối không thực hiện MixColumns, chỉ bao gồm:
		- SubBytes
		- ShiftRows
		- AddRoundKey
	- Kết quả tạo thành ciphertext hoàn chỉnh sau cùng.
- Quy trình giải mã AES: Giải mã AES thực hiện quá trình ngược lại với mã hóa, sử dụng cùng một khóa. Các thao tác được đảo ngược theo thứ tự ngược lại:
	- Inverse SubBytes: Đảo ngược bước thay thế byte.
	- Inverse ShiftRows: Đảo ngược việc dịch chuyển các hàng.
	- Inverse MixColumns: Đảo ngược quá trình trộn các cột.
	- AddRoundKey: Áp dụng lại phép XOR như trong quá trình mã hóa.
	- Quá trình giải mã được thiết kế để hiệu quả tương đương với mã hóa, đảm bảo tính đối xứng của thuật toán.
- Ưu điểm:
	- Bảo mật mạnh mẽ: AES là một thuật toán mã hóa mạnh mẽ, được chính phủ Hoa Kỳ và nhiều quốc gia khác công nhận. Mã hóa AES 256 bit, đặc biệt, gần như không thể bị phá vỡ, là một trong những tiêu chuẩn mã hóa mạnh nhất hiện nay.
	- Tính linh hoạt: AES có thể được sử dụng trong nhiều ứng dụng khác nhau, từ bảo vệ dữ liệu trên các thiết bị lưu trữ đến bảo mật các kết nối mạng.
	- Hiệu suất tốt: AES có hiệu suất tương đối tốt, đặc biệt là khi được triển khai trên phần cứng.
	- Tiêu chuẩn quốc tế: AES là một tiêu chuẩn mã hóa được công nhận trên toàn cầu, giúp đảm bảo khả năng tương tác và tính bảo mật nhất quán.
	- Được nghiên cứu kỹ lưỡng: AES đã được nghiên cứu và kiểm tra kỹ lưỡng trong nhiều năm, giúp đảm bảo tính bảo mật của nó. 
- Nhược điểm:
	- Độ phức tạp: Việc triển khai và quản lý AES có thể phức tạp, đặc biệt là đối với các hệ thống lớn hoặc phức tạp.
	- Yêu cầu về phần cứng: Để đạt được hiệu suất tối ưu, AES có thể yêu cầu phần cứng chuyên dụng hoặc các bộ xử lý hỗ trợ mã hóa AES.
	- Vấn đề quản lý khóa: Quản lý khóa mã hóa AES là một yếu tố quan trọng và có thể gây ra các vấn đề bảo mật nếu không được thực hiện đúng cách.
	- Tấn công kênh phụ: Mặc dù AES là mạnh mẽ, nó vẫn có thể bị tấn công thông qua các kênh phụ như phân tích thời gian hoặc phân tích năng lượng. 

##### 3DES
- Triple DES là một thuật toán mã hóa được phát triển dựa trên Tiêu chuẩn Mã hóa Dữ liệu (DES) ban đầu. Đây là thuật toán mã hóa đối xứng sử dụng nhiều vòng DES để tăng cường bảo mật. Nó có tên là "Triple DES" vì sử dụng cơ chế DES ba lần để mã hóa dữ liệu. Về bản chất, đây là một thuật toán mã khối, hoạt động với khối dữ liệu 64 bit. Về mặt bảo mật, Triple DES vượt trội hơn so với DES gốc, nhưng hiệu suất thấp hơn và chậm hơn so với Chuẩn Mã hóa Nâng cao (AES).
- Đặc điểm của Triple DES
	- Áp dụng mã hóa ba lớp, nghĩa là sử dụng ba khóa khác nhau để mã hóa plaintext ba lần.
	- Hỗ trợ kích thước khóa linh hoạt, từ 128 bit đến 192 bit.
	- Sử dụng hệ mã hóa đối xứng, tức là cùng một khóa được dùng cho cả mã hóa và giải mã.
	- Là thuật toán mã khối hoạt động với các khối plaintext có kích thước 64 bit.
	- Phù hợp với các hệ thống cũ cần mã hóa bảo mật nhưng chưa thể chuyển sang công nghệ mới hơn.
- Quy trình mã hóa Triple DES
	- Tạo khóa (Key Generation): Đây là bước đầu tiên trong quá trình mã hóa của Triple DES. Trong bước này, ba khóa riêng biệt được tạo ra bằng thuật toán dẫn xuất khóa.
	- Hoán vị ban đầu (Initial Permutation): Sau khi tạo khóa, các bit của plaintext sẽ được sắp xếp lại theo một bảng hoán vị được định nghĩa sẵn.
	- Ba vòng mã hóa (Three Rounds of Encryption): Đây được xem là giai đoạn quan trọng nhất. Toàn bộ quá trình thường gồm 48 vòng biến đổi. Plaintext sẽ được xử lý ba lần, mỗi lần sử dụng một khóa khác nhau, tạo nên ba lớp mã hóa liên tiếp.
	- Hoán vị cuối cùng (Final Permutation): Kết thúc quá trình mã hóa Triple DES. Khối ciphertext cuối cùng được xử lý thông qua bước hoán vị cuối – là phép đảo ngược của hoán vị ban đầu – nhằm trả các bit về đúng trật tự mong muốn.
- 3DES tăng cường bảo mật của DES bằng cách sử dụng không phải một, không phải hai, mà là ba khóa DES có độ dài 56 bit. Thuật toán mã hóa 3DES được mô tả như sau, trong đó K1, K2 và K3 là ba khóa 56-bit:
	- Thuật toán mã hóa 3DES
		- Mã hóa plaintext bằng thuật toán DES với khóa K1.
		- Giải mã kết quả thu được bằng thuật toán DES với khóa K2.
		- Mã hóa lại kết quả bằng thuật toán DES với khóa K3.
		→ Kết quả cuối cùng là ciphertext của 3DES.
	- Thuật toán giải mã 3DES
		- Giải mã ciphertext bằng thuật toán DES với khóa K3.
		- Mã hóa kết quả vừa giải mã bằng DES với khóa K2.
		- Giải mã kết quả đó bằng DES với khóa K1.
		→ Kết quả cuối cùng là phục hồi lại plaintext ban đầu.
- Ưu điểm:
	- Bảo mật nâng cao: 3DES cung cấp mức độ bảo mật tốt hơn so với thuật toán DES gốc bằng cách áp dụng DES ba lần với các khóa khác nhau, giúp chống lại các cuộc tấn công vét cạn (brute-force) hiệu quả hơn.
	- Tương thích với hệ thống cũ: 3DES từng được sử dụng rộng rãi và vẫn tương thích với nhiều hệ thống hoặc giao thức cũ.
	- Chống lại một số hình thức tấn công: Nhờ cấu trúc ba lớp khóa, 3DES có khả năng chống lại các phương pháp phân tích mật mã cổ điển như phân tích sai biệt (differential) và tuyến tính (linear).
- Nhược điểm:
	- Hiệu suất chậm: 3DES thực hiện thuật toán DES ba lần trên mỗi khối dữ liệu, khiến nó chậm hơn đáng kể so với các thuật toán hiện đại như AES.
	- Hạn chế độ dài khóa thực tế: Mặc dù sử dụng tổng cộng 168 bit (3 khóa DES 56 bit), độ dài khóa hiệu dụng bị giảm xuống còn khoảng 112 bit do lỗ hổng meet-in-the-middle.
	- Dễ bị tấn công lượng tử: Cũng giống như DES, 3DES dễ bị tổn thương trước các cuộc tấn công bằng máy tính lượng tử.
	- Bị loại bỏ bởi NIST: Viện Tiêu chuẩn và Công nghệ Quốc gia Hoa Kỳ (NIST) đã chính thức ngừng khuyến nghị sử dụng 3DES và đề xuất chuyển sang các thuật toán mạnh hơn như AES.
	- Không phù hợp cho ứng dụng mới: Do hiệu suất thấp và không đáp ứng được yêu cầu bảo mật hiện đại, 3DES không còn được khuyến nghị cho các hệ thống mới, và đang dần được thay thế bởi các thuật toán mã hóa hiện đại, hiệu quả hơn.

##### ChaCha20
- ChaCha20 là một thuật toán mã hóa dòng (stream cipher) 256-bit được phát triển bởi Daniel J. Bernstein. Nó được sử dụng rộng rãi để mã hóa dữ liệu trực tuyến, như email, tin nhắn, lưu lượng truy cập web và các tệp tải lên đám mây. ChaCha20 được biết đến với hiệu suất cao và khả năng bảo mật mạnh mẽ, đặc biệt là khi kết hợp với Poly1305 để tạo thành ChaCha20-Poly1305, một hệ mã hóa dòng có xác thực. 
- Đặc điểm nổi bật của ChaCha20
	- Là một thuật toán mã hóa đối xứng (symmetric key encryption).
	- Thiết kế đơn giản và dễ triển khai, giúp nhanh hơn AES trong nhiều trường hợp.
	- Nổi tiếng với tính bảo mật cao và tốc độ xử lý nhanh.
	- Tạo ra một chuỗi bit giả ngẫu nhiên gọi là key-stream, sau đó XOR với plaintext để tạo ra ciphertext.
	- Được hỗ trợ rộng rãi trong nhiều nền tảng và giao thức hiện đại.
- ChaCha20 là một mã dòng (stream cipher). Đầu vào của nó bao gồm: một khóa 256 bit, một bộ đếm 32 bit, một nonce 96 bit và plaintext.
	- Trạng thái khởi tạo ban đầu là một ma trận 4×4 gồm các từ 32 bit:
		- Hàng đầu tiên là chuỗi hằng số "expand 32-byte k" được chia thành 4 từ 32 bit.
		- Hàng thứ hai và thứ ba chứa khóa 256 bit (tức là 8 từ 32 bit).
		- Hàng cuối cùng gồm: từ đầu là bộ đếm 32 bit, ba từ còn lại là nonce 96 bit.
	- ChaCha20 tạo ra một keystream dài 512 bit trong mỗi vòng lặp để mã hóa một khối plaintext 512 bit.
	- Khi phần còn lại của plaintext nhỏ hơn 512 bit sau nhiều lần mã hóa, cần đệm thêm các bit 0 vào bên trái (bit có trọng số cao – MSB) trong dữ liệu đầu vào cuối cùng, và loại bỏ số bit tương ứng không cần thiết khỏi dữ liệu đầu ra cuối cùng.
	- Quá trình mã hóa và giải mã là giống nhau, miễn là sử dụng cùng một khóa, bộ đếm và nonce ban đầu.
- Quy trình mã hóa ChaCha20:
	- Tạo khóa (Key Generation): Thuật toán ChaCha20 tạo ra một khóa 256 bit từ khóa do người dùng cung cấp và một nonce 96 bit được tạo ngẫu nhiên.
	- Khởi tạo (Initialization): Thuật toán sử dụng khóa và nonce để khởi tạo trạng thái nội bộ của bộ mã hóa.
	- Mã hóa dữ liệu (Data Encryption): ChaCha20 mã hóa từng khối dữ liệu bằng trạng thái hiện tại của bộ mã, và trạng thái này được cập nhật sau mỗi khối.
	- Xuất kết quả (Output): Ciphertext được tạo ra bằng cách thực hiện phép XOR giữa plaintext và đầu ra của bước mã hóa dữ liệu.
- Kết hợp với Poly1305 tạo thành ChaCha20-Poly1305 là một thuật toán mã hóa xác thực dữ liệu liên kết (AEAD), kết hợp thuật toán mã dòng ChaCha20 và mã xác thực thông báo Poly1305. Nó cung cấp tính bảo mật và xác thực, thường được sử dụng trong các giao thức bảo mật như TLS 1.3 và WireGuard. 
	- ChaCha20: Một thuật toán mã dòng, tạo ra một chuỗi các byte ngẫu nhiên để mã hóa dữ liệu. 
	- Poly1305: Một thuật toán mã xác thực thông báo, tạo ra một mã tag để xác thực tính toàn vẹn của dữ liệu. 
- AEAD: ChaCha20-Poly1305 là một thuật toán AEAD, có nghĩa là nó không chỉ mã hóa dữ liệu mà còn tạo ra một mã tag để xác minh rằng dữ liệu không bị thay đổi trong quá trình truyền. 
- Cách hoạt động: Thuật toán này sử dụng một khóa 256-bit và một số ngẫu nhiên (nonce) 96-bit. Dữ liệu liên kết (nếu có) và dữ liệu cần mã hóa được đưa vào thuật toán ChaCha20 để tạo ra dữ liệu đã mã hóa. Sau đó, dữ liệu đã mã hóa và dữ liệu liên kết (nếu có) được đưa vào thuật toán Poly1305 để tạo ra mã tag xác thực. 
- Ứng dụng: ChaCha20-Poly1305 được sử dụng trong nhiều giao thức bảo mật như TLS 1.3, WireGuard, S/MIME v4. Nó thường được sử dụng trong môi trường mà việc tăng tốc phần cứng cho AES không có sẵn, vì nó có thể nhanh hơn AES-GCM trong các trường hợp như vậy. 
- Bảo mật: ChaCha20-Poly1305 được coi là một thuật toán an toàn, tuy nhiên, việc sử dụng đúng cách là rất quan trọng, đặc biệt là việc sử dụng nonce không được lặp lại cho cùng một khóa. 
### 3.4 Cấu trúc của chứng chỉ SSL (Common Name, SAN, Issuer, Validity Period).
- Chứng chỉ SSL về bản chất là một chứng chỉ X.509. X.509 là một tiêu chuẩn xác định cấu trúc của chứng chỉ, bao gồm các trường dữ liệu cần có trong chứng chỉ SSL. X.509 sử dụng một ngôn ngữ hình thức gọi là Abstract Syntax Notation One (ASN.1) để biểu diễn cấu trúc dữ liệu của chứng chỉ.
- Có nhiều định dạng khác nhau của chứng chỉ X.509 như PEM, DER, PKCS#7 và PKCS#12. Các định dạng PEM và PKCS#7 sử dụng mã hóa ASCII dạng Base64, trong khi DER và PKCS#12 sử dụng mã hóa nhị phân. Các tệp chứng chỉ có phần mở rộng khác nhau tùy theo định dạng và kiểu mã hóa được sử dụng.
- `X.509` là một định dạng chuẩn cho chứng chỉ khóa công khai, các tài liệu kỹ thuật số liên kết an toàn các cặp khóa mật mã với các danh tính như trang web, cá nhân hoặc tổ chức.
- Được giới thiệu lần đầu tiên vào năm 1988 cùng với tiêu chuẩn X.500 cho các dịch vụ thư mục điện tử, X.509 đã được điều chỉnh để sử dụng internet bởi Cơ sở hạ tầng khóa công khai của IETF (X.509) (PKIX) nhóm làm việc. RFC 5280 cấu hình chứng chỉ X.509 v3, danh sách thu hồi chứng chỉ X.509 v2 (CRL) và mô tả thuật toán để xác thực đường dẫn chứng chỉ X.509.
- Các thành phần của chứng chỉ X.509:
	- Version – Phiên bản của tiêu chuẩn X.509 (thường là v3).
	- Serial Number – Số định danh duy nhất của chứng chỉ.
	- Signature Algorithm – Thuật toán dùng để ký chứng chỉ (ví dụ: SHA256withRSA).
	- Issuer – Tổ chức phát hành chứng chỉ (CA).
	- Validity Period
	- Not Before: Ngày bắt đầu hiệu lực
	- Not After: Ngày hết hạn
	- Subject – Thông tin của thực thể sở hữu chứng chỉ (tên miền, tổ chức, v.v.)
	- Subject Public Key Info
	- Thuật toán khóa công khai
	- Giá trị khóa công khai
	- Extensions (chỉ có ở v3)
	- Subject Alternative Name (SAN)
	- Key Usage
	- Extended Key Usage
	- Basic Constraints
	- Và nhiều mục khác tùy theo mục đích sử dụng
	- Signature – Chữ ký số của CA để xác thực chứng chỉ.
- Cụ thể cần chú ý tới 
- Common Name (CN) nằm bên trong phần Subject — phần mô tả danh tính của thực thể sở hữu chứng chỉ: Là tên miền chính mà chứng chỉ bảo vệ. Ví dụ: www.example.com. Trình duyệt sẽ kiểm tra tên miền truy cập có khớp với CN không (hoặc với SAN nếu có). Trong các chứng chỉ hiện đại, CN thường chỉ mang tính tham khảo vì trình duyệt ưu tiên kiểm tra SAN.
- Subject Alternative Name (SAN): Là phần mở rộng cho phép chứng chỉ bảo vệ nhiều tên miền hoặc địa chỉ IP cùng lúc. Ví dụ: example.com, www.example.com, mail.example.com. Đây là trường được ưu tiên kiểm tra trong xác thực tên miền hiện nay.
- Issuer: Là tổ chức phát hành chứng chỉ (Certificate Authority – CA), ví dụ: DigiCert, Let's Encrypt, GlobalSign. Trường này xác định ai là người cấp chứng chỉ và có thể được dùng để xác minh độ tin cậy của chứng chỉ.
- Validity Period: Khoảng thời gian chứng chỉ có hiệu lực, bao gồm:
	- Not Before: ngày bắt đầu có hiệu lực
	- Not After: ngày hết hạn
	- Thông thường, chứng chỉ SSL có thời hạn từ vài tháng đến tối đa 13 tháng (theo quy định mới của CA/B Forum).
- ![images](./images/s-2.png)

### 3.5 Các phương pháp xác minh chứng chỉ SSL
- Chứng chỉ SSL/TLS được xác minh thông qua một quy trình nhiều bước nhằm đảm bảo danh tính của website và mã hóa dữ liệu trao đổi giữa trình duyệt và máy chủ. Các bước chính bao gồm xác thực chứng chỉ, kiểm tra chuỗi chứng chỉ, xác minh tên miền và (tùy chọn) kiểm tra trạng thái thu hồi. Cụ thể:
	- Xác thực chứng chỉ:
		- Mật mã khóa công khai: Trình duyệt tải chứng chỉ từ máy chủ, trong đó chứa khóa công khai.
		- Xác minh chữ ký: Trình duyệt sử dụng khóa công khai của CA để giải mã chữ ký số trên chứng chỉ và so sánh với nội dung chứng chỉ.
		- CA gốc đáng tin cậy: Trình duyệt kiểm tra xem CA phát hành chứng chỉ có nằm trong danh sách CA tin cậy được cài sẵn hay không.
	- Kiểm tra chuỗi chứng chỉ:
		- Chuỗi tin cậy: Chứng chỉ máy chủ thường là một phần của chuỗi gồm chứng chỉ trung gian và chứng chỉ gốc.
		- Xác minh chuỗi: Trình duyệt xác thực từng chứng chỉ trong chuỗi cho đến khi đạt đến CA gốc đáng tin cậy.
	- Xác minh tên miền:
		- So khớp tên miền: Trình duyệt so sánh tên miền truy cập với Common Name (CN) hoặc Subject Alternative Name (SAN) trong chứng chỉ.
		- Xác minh quyền sở hữu: Đảm bảo chứng chỉ thực sự được cấp cho website mà người dùng đang truy cập.
	- Kiểm tra trạng thái thu hồi (tùy chọn): Trình duyệt có thể kiểm tra xem chứng chỉ có bị thu hồi trước thời hạn hay không thông qua OCSP hoặc CRL.
	- Thiết lập kết nối an toàn:
		- Mã hóa: Nếu tất cả bước trên hợp lệ, trình duyệt và máy chủ thiết lập kết nối được mã hóa.
		- Tải trang an toàn: Trình duyệt hiển thị biểu tượng ổ khóa để báo hiệu kết nối bảo mật.

## 4. Nhà cung cấp chứng chỉ (CA – Certificate Authority)
### 4.1 Các CA uy tín:
- Các CA đóng vai trò trung tâm trong hạ tầng khóa công khai (PKI) bằng cách phát hành và quản lý chứng chỉ số. 
- Sectigo
	- Tiền thân là Comodo CA, đổi tên thành Sectigo vào năm 2018.
	- Phát hành nhiều chứng chỉ SSL cho cá nhân, doanh nghiệp và tổ chức chính phủ.
	- Hỗ trợ đầy đủ các loại chứng chỉ: DV, OV, EV, Wildcard, Multi-Domain.
	- Được các nền tảng hosting và control panel tích hợp rộng rãi.
- DigiCert
	- CA thương mại lớn, có độ tin cậy cao trong lĩnh vực bảo mật số.
	- Là nhà cung cấp của các thương hiệu chứng chỉ như GeoTrust, Thawte và RapidSSL.
	- Được sử dụng phổ biến trong các hệ thống doanh nghiệp, ngân hàng, và chính phủ.
	- Cung cấp công cụ quản lý vòng đời chứng chỉ chuyên nghiệp.
- GlobalSign
	- CA lâu đời có nguồn gốc từ Nhật Bản, được công nhận quốc tế.
	- Tập trung vào khách hàng doanh nghiệp và dịch vụ PKI quy mô lớn.
	- Hỗ trợ cấp chứng chỉ tự động qua API, quản lý tập trung và triển khai linh hoạt.
- Let's Encrypt
	- CA phi lợi nhuận do Internet Security Research Group (ISRG) vận hành.
	- Phát hành chứng chỉ miễn phí, tự động, chủ yếu dành cho mục đích phổ thông.
	- Chỉ hỗ trợ chứng chỉ DV, không hỗ trợ OV hoặc EV.
	- Sử dụng giao thức ACME để tự động cài đặt và gia hạn chứng chỉ.

### 4.2 Cơ chế xác minh chứng chỉ: 
- Domain Control Validation (DCV) là quá trình xác minh quyền sở hữu tên miền trước khi cấp chứng chỉ SSL/TLS, nhằm đảm bảo tính tin cậy và an toàn.
- Các phương pháp DCV phổ biến bao gồm:
	- Email: Gửi mã xác minh đến địa chỉ email quản trị tên miền.
	- DNS: Thêm bản ghi DNS (TXT hoặc CNAME) vào cấu hình tên miền.
	- HTTP: Tải tệp xác minh lên máy chủ web tại đường dẫn cụ thể.
	- Thông qua bản ghi CAA record
	- WHOIS: (ít dùng hiện nay) Kiểm tra thông tin liên hệ trong cơ sở dữ liệu WHOIS.
- Xác minh qua email
- Tổ chức cấp chứng chỉ (CA) sẽ gửi một email đến địa chỉ email mặc định liên kết với tên miền được sử dụng để tạo yêu cầu ký chứng chỉ (CSR). Các địa chỉ email này thường là các địa chỉ quản trị chung như postmaster@domain.com, hostmaster@example.com, hoặc webmaster@domain.com. Người đăng ký chứng chỉ sẽ đăng nhập vào tài khoản email đó và làm theo hướng dẫn trong email, ví dụ như nhập mã xác minh hoặc nhấp vào liên kết trong email DCV để xác nhận quyền sở hữu tên miền.
- Phương pháp xác minh qua email áp dụng được cho tất cả các loại chứng chỉ SSL/TLS, bao gồm Domain Validation (DV), Organization Validation (OV) và Extended Validation (EV). Tuy nhiên, các tên miền sử dụng dịch vụ ẩn thông tin WHOIS có thể cần dùng phương pháp xác minh khác.
- ![images](./images/s-3.png)

- Xác minh qua DNS
- Phương pháp này yêu cầu người đăng ký chứng chỉ tạo một bản ghi TXT trong vùng DNS của tên miền, với nội dung cụ thể do CA cung cấp. Sau đó, hệ thống xác minh của CA sẽ kiểm tra bản ghi DNS để xác nhận quyền kiểm soát tên miền. DNS validation thường được sử dụng cho chứng chỉ DV và OV. Phương pháp này không phổ biến với chứng chỉ EV, nhưng lại là lựa chọn ưu tiên khi xác minh chứng chỉ Wildcard TLS.
- ![images](./images/s-4.png)

- Xác minh qua HTTP
- Người đăng ký chứng chỉ sẽ tải lên một tệp văn bản chứa nội dung đặc biệt do CA cung cấp vào thư mục gốc của máy chủ web, hoặc vào vị trí được CA chỉ định. Sau đó, hệ thống xác minh của CA sẽ gửi yêu cầu HTTP đến URL tương ứng để kiểm tra sự tồn tại của tệp. Phương pháp này thường không được sử dụng cho chứng chỉ Wildcard TLS vì nó không đủ bằng chứng xác minh quyền kiểm soát tất cả các tên miền con, dẫn đến rủi ro bảo mật tiềm ẩn.
- Xác minh dựa trên WHOIS (WHOIS-based validation)
- Khi đăng ký chứng chỉ SSL/TLS, người đăng ký cung cấp thông tin liên quan đến tên miền (ví dụ: tên chủ sở hữu và thông tin liên hệ). Tổ chức cấp chứng chỉ (CA) sẽ truy vấn cơ sở dữ liệu WHOIS và so sánh thông tin đó với dữ liệu trong đơn đăng ký chứng chỉ. Nếu thông tin trùng khớp, CA sẽ coi quá trình xác minh là thành công.
- Phương pháp xác minh này thường được sử dụng cho chứng chỉ DV (Domain Validation). Tuy nhiên, nó ít phổ biến hơn đối với OV (Organization Validation) và hầu như không được dùng cho EV (Extended Validation) do các yêu cầu xác minh nghiêm ngặt hơn. Nếu tên miền của bạn sử dụng dịch vụ ẩn thông tin WHOIS (WHOIS privacy), bạn có thể không sử dụng được phương pháp DCV này.
- ![images](./images/s-5.png)

- Xác minh bằng bản ghi CAA (CAA-based validation)
- Phương pháp này sử dụng bản ghi CAA trong hệ thống DNS để kiểm soát việc cấp phát chứng chỉ SSL/TLS cho tên miền. Chủ sở hữu tên miền tạo một bản ghi CAA để chỉ định rõ tổ chức cấp chứng chỉ (CA) nào được phép phát hành chứng chỉ cho tên miền đó.
- Khi có yêu cầu cấp chứng chỉ, CA sẽ truy vấn DNS để kiểm tra bản ghi CAA. Nếu CA được liệt kê trong bản ghi, quá trình xác minh được coi là hợp lệ. Nếu không, CA sẽ từ chối cấp chứng chỉ.
- Cấu trúc bản ghi CAA:
`example.com.  CAA  0 issue "letsencrypt.org"`
→ Chỉ cho phép Let’s Encrypt cấp chứng chỉ cho example.com.
- Đặc điểm:
	- Áp dụng: Cho tất cả các loại chứng chỉ (DV, OV, EV), nhưng thường được dùng như một lớp kiểm soát bổ sung chứ không phải là phương pháp xác minh duy nhất.
	- Tính năng: Có thể chỉ định nhiều CA, hoặc ngăn chặn hoàn toàn việc cấp chứng chỉ bằng cách không cho phép CA nào (issue ";").
	- Tính kế thừa: CA sẽ kiểm tra bản ghi CAA từ tên miền con đến tên miền gốc, dừng lại ở bản ghi đầu tiên tìm thấy.
	- Tự động hóa: Có thể cấu hình dễ dàng trong hệ thống DNS của nhà cung cấp tên miền.
- Lưu ý: Nếu không có bản ghi CAA, CA được phép cấp chứng chỉ theo mặc định. Tuy nhiên, nếu có bản ghi, CA bắt buộc phải tuân thủ theo quy định trong đó

### 4.3 So sánh ưu/nhược điểm

| Tiêu chí                | Sectigo                            | DigiCert                                     | GlobalSign                         | Let's Encrypt                       |
| ----------------------- | ---------------------------------- | -------------------------------------------- | ---------------------------------- | ----------------------------------- |
| Loại chứng chỉ hỗ trợ   | DV, OV, EV, Wildcard, Multi-Domain | DV, OV, EV, Wildcard, Multi-Domain           | DV, OV, EV, Wildcard, Multi-Domain | DV (chỉ hỗ trợ Domain Validation)   |
| Chi phí                 | Thấp đến trung bình                | Cao                                          | Trung bình đến cao                 | Miễn phí                            |
| Tốc độ cấp phát         | Nhanh (DV: vài phút)               | Rất nhanh (DV/OV: vài phút đến giờ)          | Nhanh (DV: vài phút)               | Tự động, gần như tức thì            |
| Tự động hóa (ACME)      | Có (qua API riêng)                 | Có (API doanh nghiệp)                        | Có (API doanh nghiệp)              | Có (chuẩn ACME)                     |
| Thời hạn chứng chỉ      | Tối đa 13 tháng                    | Tối đa 13 tháng                              | Tối đa 13 tháng                    | 90 ngày (tự động gia hạn)           |
| Hỗ trợ doanh nghiệp lớn | Có                                 | Rất mạnh                                     | Rất mạnh                           | Không                               |
| Tính năng quản lý       | Có bảng điều khiển quản lý         | Có hệ thống quản lý vòng đời (CertCentral)   | Có hệ thống quản lý tập trung      | Không có giao diện quản lý          |
| Mức độ tin cậy          | Cao                                | Rất cao (được dùng bởi chính phủ, ngân hàng) | Cao                                | Cao (dù miễn phí, vẫn được tin cậy) |
| Hỗ trợ kỹ thuật         | Có (24/7, nhiều cấp độ)            | Có (24/7, chuyên sâu)                        | Có (đa ngôn ngữ, chuyên nghiệp)    | Không hỗ trợ trực tiếp              |


## 5. Thành phần kỹ thuật cần làm rõ hơn
### 5.1 Public key – Private key 
- Trong mật mã khóa công khai – khóa riêng (public-private key cryptography), khóa công khai và khóa riêng hoạt động cùng nhau để đảm bảo an toàn cho dữ liệu được trao đổi. Một thông điệp sẽ được mã hóa bằng khóa công khai, vốn có thể được chia sẻ rộng rãi, và chỉ có thể được giải mã bằng khóa riêng tương ứng, vốn chỉ thuộc về chủ sở hữu.
- Khóa công khai thường được ví như địa chỉ công ty – ai cũng có thể tra cứu và chia sẻ. Trong mã hóa bất đối xứng, khóa công khai có thể được phân phối cho bất kỳ ai trong hệ thống. Khi người gửi có khóa công khai, họ sử dụng nó để mã hóa thông điệp.
- Mỗi khóa công khai luôn đi kèm với một khóa riêng duy nhất. Có thể hình dung khóa riêng giống như chìa khóa cửa chính của một doanh nghiệp – chỉ bạn mới có bản sao. Đây chính là điểm khác biệt cốt lõi giữa hai loại khóa: khóa công khai để mã hóa, khóa riêng để giải mã. Trong trường hợp thông điệp được mã hóa, bạn sẽ sử dụng khóa riêng để giải mã và đọc nội dung.
- Ví dụ sử dụng cặp khoá 
	- Bob muốn gửi cho Alice một email được mã hóa. Để làm điều này, Bob sử dụng khóa công khai của Alice để mã hóa thông điệp của mình. Khi Alice nhận được thông điệp, cô ấy sẽ sử dụng khóa riêng tương ứng (chỉ mình cô ấy biết) để giải mã thông điệp từ Bob.
	- Kẻ tấn công có thể cố gắng xâm nhập vào máy chủ để truy cập thông tin đã mã hóa, nhưng sẽ không thể giải mã được vì không có khóa riêng. Alice là người duy nhất sở hữu khóa riêng, do đó cũng là người duy nhất có thể giải mã và đọc được nội dung thông điệp.
	- Khi Alice muốn trả lời Bob, cô ấy chỉ cần lặp lại quy trình: sử dụng khóa công khai của Bob để mã hóa thông điệp gửi lại cho anh ấy.
- ![images](./images/s-6.webp)
- Sự khác biệt giữa **khóa công khai** và **khóa riêng**:

| **Khóa công khai (Public Key)**                  | **Khóa riêng (Private Key)**                         |
|--------------------------------------------------|------------------------------------------------------|
| Dùng để mã hóa dữ liệu                           | Dùng để giải mã dữ liệu                              |
| Được chia sẻ công khai                           | Chỉ chủ sở hữu mới có quyền truy cập                 |
| Có thể dùng để mã hóa hoặc ký                    | Dùng để giải mã hoặc xác minh chữ ký                 |
| Không thể dùng để suy ra khóa riêng              | Không thể dùng để suy ra khóa công khai              |

- Sử dụng cặp khóa công khai và khóa riêng giúp bảo vệ dữ liệu khi truyền thông tin qua mạng, đảm bảo ba yếu tố:
	- Bí mật: Dữ liệu được mã hóa bằng khóa công khai chỉ người sở hữu khóa riêng mới giải mã được.
	- Toàn vẹn: Quá trình giải mã cho phép kiểm tra dữ liệu có bị thay đổi hay không.
	- Xác thực: Chữ ký số bằng khóa riêng cho phép người nhận xác minh đúng người gửi bằng khóa công khai.

### 5.2 CSR (Certificate Signing Request)
- CSR (Certificate Signing Request) là một trong những bước đầu tiên để lấy chứng chỉ SSL/TLS. Tệp này được tạo trên chính máy chủ nơi chứng chỉ sẽ được cài đặt, và chứa các thông tin (ví dụ: common name, organization, country) mà Tổ chức cấp chứng chỉ (CA) sẽ sử dụng để tạo chứng chỉ. CSR cũng bao gồm khóa công khai sẽ được đưa vào chứng chỉ và được ký bằng khóa riêng tương ứng. \
- Tổ chức cấp chứng chỉ (CA) sẽ sử dụng dữ liệu từ CSR để tạo chứng chỉ SSL. Các thông tin chính bao gồm:
	- Thông tin về doanh nghiệp và website cần cài đặt SSL, bao gồm:
		- Common Name (CN):
			- Ví dụ: *.example.com, www.example.com, mail.example.com
			- Đây là tên miền đầy đủ (FQDN) của máy chủ.
		- Organization (O):
			- Tên pháp lý đầy đủ của tổ chức. Không viết tắt và cần bao gồm hậu tố như Inc., Corp., hoặc LLC nếu có.
			- Đối với chứng chỉ SSL loại EV và OV, thông tin này sẽ được CA xác minh và đưa vào chứng chỉ.
		- City/Locality (L): Thành phố nơi tổ chức đặt trụ sở. Không viết tắt.
		- State/County/Region (S): Bang hoặc khu vực nơi tổ chức đặt trụ sở. Không viết tắt.
		- Country (C): Mã quốc gia gồm hai chữ cái theo chuẩn ISO (ví dụ: VN cho Việt Nam).
		- Email Address: Địa chỉ email dùng để liên hệ với tổ chức.
	- Khóa công khai sẽ được đưa vào chứng chỉ. SSL sử dụng mã hóa bất đối xứng (public-key cryptography) để bảo vệ dữ liệu truyền tải. Khóa công khai dùng để mã hóa, còn khóa riêng tương ứng dùng để giải mã.
	- Thông tin về loại và độ dài khóa: Kích thước khóa phổ biến nhất là RSA 2048 bit. Một số CA (như GlobalSign) hỗ trợ khóa lớn hơn (ví dụ: RSA 4096+) hoặc khóa dạng ECC.
- CSR thường được tạo ở định dạng PEM dựa trên mã hóa Base-64.
```
-----BEGIN NEW CERTIFICATE REQUEST-----MIIDVDCCAr0CAQAweTEeMBwGA1UEAxMVd3d3Lmpvc2VwaGNoYXBtYW4uY29tMQ8w DQYDVQQLEwZEZXNpZ24xFjAUBgNVBAoTDUpvc2VwaENoYXBtYW4xEjAQBgNVBAcT CU1haWRzdG9uZTENMAsGA1UECBMES2VudDELMAkGA1UEBhMCR0IwgZ8wDQYJKoZI hvcNAQEBBQADgY0AMIGJAoGBAOEFDpnOKRabQhDa5asDxYPnG0c/neW18e8apjOk 1yuGRk+3GD7YQvuhBVS1x6wkw1D2RnmnZgN1nNUK0cRK7sIvOyCh1+jgD7u46mLk 81j+b4YSEmYZGPLIuclyocPDm0hXayjCUqWt7z6LMIKpLym8gayEZzz9Gn97PsbP kVFBAgMBAAGgggGZMBoGCisGAQQBgjcNAgMxDBYKNS4xLjI2MDAuMjB7BgorBgEE AYI3AgEOMW0wazAOBgNVHQ8BAf8EBAMCBPAwRAYJKoZIhvcNAQkPBDcwNTAOBggq hkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsOAwIHMAoGCCqGSIb3DQMH MBMGA1UdJQQMMAoGCCsGAQUFBwMBMIH9BgorBgEEAYI3DQICMYHuMIHrAgEBHloA TQBpAGMAcgBvAHMAbwBmAHQAIABSAFMAQQAgAFMAQwBoAGEAbgBuAGUAbAAgAEMA cgB5AHAAdABvAGcAcgBhAHAAaABpAGMAIABQAHIAbwB2AGkAZABlAHIDgYkAk0kf HSkr4jsEVya3mgUoyaYMO456ECNZr4Cb+WhPgexfjOO5qwOG1oDOTaKycrkc5pG+ IPBQnq+4cotT8hWJQwpc+qGb8xUETpxCokhrhN5079vFXq/5dsHkmtOTwkSqSnz9 yruVoxYeDQ8jI3KG3HTgxwFto8oZnm+E+Y4oshUAAAAAAAAAADANBgkqhkiG9w0B AQUFAAOBgQAuAxetLzgfjBdWpjpixeVYZXuPZ+6jvZNL/9hOw7Fk5pVVXWdr8csJ 6JUW8QdH9KB6ZlM4yg8Df+vat1/DG6GuD2hiIR7fQ0NtPFBQmbrSm+TTBo95lwP+ ZSZTusPFTLKaqValdnS9Uw+6Vq7/I4ouDA8QBIuaTFtPOp+8wEGBHQ==
-----END NEW CERTIFICATE REQUEST-----
```
- Quy trình lấy chứng chỉ CSR
	- Tạo cặp khóa trên máy chủ (khóa công khai và khóa riêng).
	- Điền thông tin CSR: tên miền, tổ chức, địa chỉ, khóa công khai...
	- Đảm bảo thông tin khớp với tên miền đã đăng ký để tránh bị từ chối.
	- Gửi CSR đến CA để được xác minh và phát hành chứng chỉ.

### 5.3 Các định dạng file chứng chỉ X.509
- Tất cả chứng chỉ SSL đều là chứng chỉ x.509 — đây là định dạng tiêu chuẩn cho chứng chỉ khóa công khai, được biểu diễn bằng một ngôn ngữ hình thức gọi là Abstract Syntax Notation One (ASN.1). 
- Một cách đơn giản để phân biệt các định dạng này là dựa vào kiểu mã hóa:
	- PEM và PKCS#7 sử dụng mã hóa ASCII dạng Base64, phổ biến cho các tệp văn bản.
	- DER và PKCS#12 sử dụng mã hóa nhị phân (binary), tức là hệ nhị phân chỉ gồm các số 0 và 1.
- Do sự khác biệt về định dạng và mã hóa, chứng chỉ SSL có thể có nhiều phần mở rộng tệp (file extension) khác nhau.
- Các định dạng chứng chỉ SSL bao gồm PEM, DER, PFX và PKCS#7, mỗi định dạng phù hợp với các mục đích sử dụng khác nhau. Một số phần mở rộng tệp phổ biến là:

| **Format**      | **Extension**            | **Description**                                                |
|-----------------|--------------------------|----------------------------------------------------------------|
| PEM             | .pem, .crt, .cer         | Base64 encoded, used in Unix/Linux systems                     |
| DER             | .der, .cer               | Binary format, used in Windows                                 |
| PFX / PKCS#12   | .pfx, .p12               | Stores certificate and private key, used in Windows            |
| PKCS#7          | .p7b, .p7c               | Certificate chain, used in Java environments                   |

- Định dạng DER: DER là viết tắt của Distinguished Encoding Rules, một định dạng mã hóa nhị phân, hiếm khi được sử dụng ngoài môi trường Windows. Các tệp DER thường có phần mở rộng là .der hoặc .cer.
- Định dạng PEM: 
	- PEM là định dạng chứng chỉ SSL phổ biến nhất và thường gặp nhất. Phần lớn các tổ chức cấp chứng chỉ (CA) cung cấp chứng chỉ SSL ở định dạng PEM với các phần mở rộng tệp như .pem, .crt, .cer hoặc .key.
	- PEM là viết tắt của Privacy-Enhanced Email, mặc dù mục đích ban đầu liên quan đến email không thành công, nhưng định dạng này lại được sử dụng rộng rãi như một định dạng chứa dữ liệu.
	- Về bản chất, tệp PEM là tệp DER được mã hóa theo chuẩn Base64, trong đó các bit nhị phân được chuyển thành chuỗi ký tự có thể đọc được. Nhờ đó, có thể mở tệp PEM bằng bất kỳ trình soạn thảo văn bản nào, kể cả Notepad.
	- Một tệp .pem có thể chứa chứng chỉ máy chủ, chứng chỉ trung gian và cả khóa riêng. Ngoài ra, cũng có thể nhận chứng chỉ máy chủ và trung gian dưới dạng tệp .crt hoặc .cer, còn khóa riêng nằm trong tệp .key.
- Định dạng PKCS#7
	- PKCS là viết tắt của Public Key Cryptography Standards.
	- PKCS#7 là định dạng chứng chỉ SSL đa năng dùng để phân phối dữ liệu được mã hóa. Nó chủ yếu được sử dụng trên nền tảng Windows và máy chủ Java Tomcat.
	- Hiện nay, định dạng kế nhiệm của nó là CMS (Cryptographic Message Syntax) đang được sử dụng, nhưng tên gọi PKCS#7 vẫn phổ biến như cách gọi SSL thay vì TLS.
	- PKCS#7 có hai phần mở rộng tệp: .p7b hoặc .p7c. Khác với PEM, PKCS#7 không thể chứa khóa riêng, mà chỉ chứa chứng chỉ chính và chứng chỉ trung gian.
- Định dạng PKCS#12
	- PKCS#12 là một tiêu chuẩn mã hóa công khai khác với tính bảo mật cao hơn. Giống như PEM, nó có thể chứa toàn bộ chuỗi chứng chỉ SSL và cặp khóa trong một tệp .pfx.
	- Điểm khác biệt chính là PKCS#12 là một container được bảo vệ bằng mật khẩu.
	- Một số hệ thống máy chủ sẽ yêu cầu nhập mật khẩu trong quá trình tạo CSR, và mật khẩu này có thể được sử dụng để mở tệp .pfx.

### 5.4 Intermediate CA, Root CA và Chuỗi chứng chỉ (Certificate Chain)
- Certificate Chain
	- Chuỗi chứng chỉ (Certificate Chain) là một danh sách có thứ tự các chứng chỉ, bao gồm chứng chỉ SSL/TLS và các chứng chỉ của Tổ chức cấp chứng chỉ (CA), cho phép bên nhận xác minh rằng người gửi và tất cả các CA trong chuỗi đều đáng tin cậy.
	- Chuỗi này bắt đầu từ chứng chỉ SSL/TLS của máy chủ, và mỗi chứng chỉ trong chuỗi được ký bởi tổ chức được xác định trong chứng chỉ kế tiếp.
- Intermediate CA
	- Chuỗi tin cậy: Intermediate CA được liên kết với Root CA thông qua việc chứng chỉ của nó được ký bởi Root CA hoặc một Intermediate CA khác.
	- Ký chéo (Cross-Signed): Chứng chỉ của Intermediate CA có thể được ký chéo bởi Root CA hoặc Intermediate CA khác để chứng minh độ tin cậy.
	- Hoạt động trực tuyến: Intermediate CA được sử dụng trong các hoạt động trực tuyến như cấp chứng chỉ cho website hoặc người dùng.
	- Bảo mật: Intermediate CA đóng vai trò như một lớp bảo vệ; nếu khóa riêng của nó bị lộ, Root CA vẫn không bị ảnh hưởng trực tiếp.
	- Thời hạn ngắn hơn: Chứng chỉ trung gian thường có thời hạn hiệu lực ngắn hơn (ví dụ: 1–2 năm) so với chứng chỉ gốc.
	- Bất kỳ chứng chỉ nào nằm giữa chứng chỉ SSL/TLS và chứng chỉ gốc (Root Certificate) đều được gọi là chứng chỉ trung gian (Intermediate Certificate) hoặc chuỗi chứng chỉ (chain certificate).
		- Chứng chỉ trung gian là bên ký/phát hành chứng chỉ SSL/TLS.
		- Chứng chỉ gốc (Root CA Certificate) là bên ký/phát hành chứng chỉ trung gian.
	- Nếu chứng chỉ trung gian không được cài đặt trên máy chủ (nơi chứng chỉ SSL/TLS được triển khai), một số trình duyệt, thiết bị di động hoặc ứng dụng có thể không tin tưởng chứng chỉ SSL/TLS đó.
	- Để đảm bảo chứng chỉ SSL/TLS tương thích với tất cả các máy khách, việc cài đặt đầy đủ chứng chỉ trung gian là bắt buộc.
- Root CA
	- Trust Anchor: Root CA là nền tảng của sự tin cậy trong hạ tầng khóa công khai (PKI), với chứng chỉ được cài sẵn trong phần mềm hoặc phân phối qua các kênh bảo mật.
	- Tự ký (Self-Signed): Root CA tự ký chứng chỉ của chính mình, thiết lập gốc của chuỗi tin cậy.
	- Bảo mật: Root CA thường được lưu trữ ngoại tuyến trong các mô-đun bảo mật phần cứng (HSM) để bảo vệ khóa riêng và giảm thiểu rủi ro bị xâm phạm.
	- Giới hạn cấp phát: Root CA chỉ cấp chứng chỉ cho các Intermediate CA, không cấp trực tiếp cho người dùng cuối (như website hoặc người dùng).
	- Thời hạn dài: Chứng chỉ gốc có thời hạn hiệu lực dài hơn (ví dụ: 10–20 năm).
	- Chuỗi chứng chỉ kết thúc bằng chứng chỉ gốc (Root CA Certificate). CA đóng vai trò là điểm khởi đầu của chuỗi tin cậy.
	- Tất cả các chứng chỉ trong chuỗi — từ chứng chỉ SSL/TLS đến các chứng chỉ trung gian — đều phải được xác minh chữ ký số liên tiếp cho đến khi đạt đến chứng chỉ gốc. Việc xác minh này đảm bảo rằng mỗi chứng chỉ đều được phát hành bởi một CA hợp lệ trong hệ thống hạ tầng khóa công khai (PKI).
- ![images](./images/figure-chain.jpg)

## 6. Cài đặt SSL trên máy chủ
- Thông thường, sau khi được CA cấp chứng chỉ, sẽ có các tệp sau:
	- your_domain.crt: Chứng chỉ SSL cho domain .
	- your_domain.key: Khóa riêng (private key) – được tạo cùng lúc với CSR.
	- intermediate.crt hoặc ca_bundle.crt: Chứng chỉ trung gian từ CA.
	- (Tùy chọn): Có thể được hợp nhất thành một chuỗi chứng chỉ fullchain.crt

### 6.1 Trên các Webserver 
#### Apache
- Tạo Private key và CSR 
```
openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr
```
	- Lệnh trên tạo ra hai tệp sau:
		- Tệp Private Key: Dùng để tạo CSR và sau đó dùng để bảo mật và xác minh các kết nối thông qua chứng chỉ SSL.
		- Tệp Certificate Signing Request (CSR): Dùng để yêu cầu cấp chứng chỉ SSL và sau này để mã hóa các thông điệp mà chỉ khóa riêng tương ứng mới giải mã được.
	- Cấu hình domain cần bảo vệ, các thông tin địa lý liên quan. 
- Thực hiện gửi CSR tới CA xin cấp chứng chỉ, thực hiện quá trình xác minh domain hoặc các trường hợp xác minh sâu hơn tuỳ theo loại SSL cert DV, EV hay OV.
- Sau khi quá trình xác minh xong, CA cấp chứng chỉ thu được các file domain cert, intermediate CA cert. Tiến hành cài đặt:
- Chỉnh sửa file `virtualhost` tương ứng của website trong apache thường nằm trong `/etc/apache2/sites-enabled/`
	- Trường hợp website chạy trên cả 80 và 443 thì cần 2 file riêng biệt, cấu hình ssl trên virtual host sử dụng port 443 
	- Ví dụ file virtual host mẫu 
	```
	<VirtualHost 192.168.0.1:443>
	DocumentRoot /var/www/
	SSLEngine on
	SSLCertificateFile /path/to/your_domain_name.crt
	SSLCertificateKeyFile /path/to/your_private.key
	SSLCertificateChainFile /path/to/DigiCertCA.crt
	</VirtualHost>
	```
	- Các tham số cần cấu hình: 
		- SSLCertificateFile là tệp chứng chỉ cho domain được cấp (ví dụ: your_domain_name.crt).
		- SSLCertificateKeyFile là tệp .key được tạo ra khi tạo CSR (ví dụ: your_private.key).
		- SSLCertificateChainFile là tệp chứng chỉ trung gian của CA cấp (ví dụ: intermediate.crt).
	- Sau khi cấu hình thực hiện kiểm tra 
	```
	apachectl configtest
	```
	- Enable module SSL 
	```
	sudo a2enmod ssl
	```
	- Restart Apache2
	```
	systemctl restart apache2 
	```
#### Nginx
- Qúa trình sinh CSR và thực hiện xác minh tương tự Apache2 
- Cài đặt SSL trên Nginx 
- Khi triển khai SSL trên máy chủ Nginx, cần đảm bảo rằng chuỗi chứng chỉ được cung cấp đầy đủ và theo đúng thứ tự. Điều này thường yêu cầu kết hợp (concatenate) chứng chỉ chính và các chứng chỉ trung gian vào một tệp duy nhất.
- Thành phần chứng chỉ
	- Chứng chỉ chính (server certificate): Được cấp cho tên miền cụ thể.
	- Chứng chỉ trung gian (intermediate certificate): Được dùng để liên kết chứng chỉ chính với chứng chỉ gốc.
	- Chứng chỉ gốc (root certificate): Thường đã được trình duyệt và hệ điều hành tin cậy sẵn, không bắt buộc phải cung cấp.
- Tạo tệp chứng chỉ hợp nhất: 
	- Trên hệ thống Linux hoặc macOS, sử dụng lệnh sau để nối các tệp chứng chỉ:
	`cat server.crt intermediate.crt > fullchain.pem`
		- Trong đó:
			- server.crt là chứng chỉ chính.
			- intermediate.crt là chứng chỉ trung gian.
			- fullchain.pem là tệp kết quả chứa chuỗi chứng chỉ đầy đủ.
	- Nếu có thêm chứng chỉ gốc, có thể nối thêm vào cuối:
	`cat server.crt intermediate.crt root.crt > fullchain.pem`
	- Lưu ý: Thứ tự các chứng chỉ trong tệp hợp nhất phải là: chứng chỉ chính → trung gian → gốc.

- Tạo file cấu hình VirtualHost tương ứng với domain thường nằm trong `/etc/nginx/conf.d/`
	- Thực hiện sao chép virtual host không sử dụng ssl và cấu hình thêm ssl trên đó. 
	- Cấu hình mẫu: 
	```
	server {
		listen   443;
		
		ssl    on;
		ssl_certificate    /etc/ssl/your_domain_name.pem; (or bundle.crt)
		ssl_certificate_key    /etc/ssl/your_domain_name.key;
		
		server_name your.domain.com;
		access_log /var/log/nginx/nginx.vhost.access.log;
		error_log /var/log/nginx/nginx.vhost.error.log;
		location / {
		root   /home/www/public_html/your.domain.com/public/;
		index  index.html;
		}
	}
	```
	- Cần chú ý các cấu hình 
		- ssl on; Kích hoạt chế độ SSL cho máy chủ. 
		- ssl_certificate /etc/ssl/your_domain_name.pem; Chỉ định đường dẫn đến chứng chỉ SSL công khai của máy chủ. Tệp .pem hoặc .crt này có thể bao gồm cả chứng chỉ trung gian (intermediate certificate) nếu cần thiết.
		- ssl_certificate_key /etc/ssl/your_domain_name.key; Chỉ định đường dẫn đến khóa riêng tư (private key) tương ứng với chứng chỉ ở trên. Tệp .key này được tạo khi tạo CSR (Certificate Signing Request)
- Sau khi cấu hình thực hiện kiểm tra 
```
nginx -t
```
- Restart Nginx
```
systemctl restart nginx 
```
#### IIS
- Tạo yêu cầu cấp chứng chỉ (CSR) bằng IIS 10:
	- Mở menu Start của Windows, nhập Internet Information Services (IIS) Manager và khởi chạy công cụ.
	- Trong cửa sổ IIS Manager, ở cây thư mục Connections (bên trái), chọn tên máy chủ.
	- Ở trang chính (center pane) của tên máy chủ, trong mục IIS, nhấp đúp Server Certificates.
	- Tại trang Server Certificates, trong menu Actions (bên phải), nhấp vào liên kết Create Certificate Request.
	- Trình hướng dẫn Request Certificate sẽ mở ra. Ở trang Distinguished Name Properties, nhập các thông tin sau và nhấn Next:
		- Common Name: Nhập tên miền đầy đủ (FQDN), ví dụ www.example.com
		- Organization: Nhập tên pháp lý đầy đủ của tổ chức
		- Organizational Unit: Nhập tên phòng ban (ví dụ: IT, Web Security); trường này có thể để trống
		- City/Locality: Thành phố nơi tổ chức được đăng ký hợp pháp
		- State/Province: Tỉnh hoặc bang nơi tổ chức được đăng ký hợp pháp
		- Country: Chọn quốc gia từ danh sách
	- Ở trang Cryptographic Service Provider Properties, nhập các lựa chọn:
		- Cryptographic service provider: Chọn Microsoft RSA SChannel Cryptographic Provider (trừ khi có nhu cầu khác)
		- Bit length: Chọn 2048 (trừ khi có yêu cầu đặc biệt)
	- Tại trang File Name, dưới mục Specify a file name for the certificate request, nhấp nút […] để duyệt đến vị trí lưu tệp CSR.
		- Lưu ý: Nếu chỉ nhập tên tệp mà không chỉ định đường dẫn, tệp CSR (csr.txt) sẽ được lưu ở C:\Windows\System32.
	- Nhấn Finish để hoàn tất quá trình tạo CSR.
- Sử dụng CSR gửi tới CA xin cấp cert, thực hiện quá trình xác minh và cấp chứng chỉ.
- Cài đặt chứng chỉ SSL
	- Trên máy chủ đã tạo CSR, lưu tệp chứng chỉ .cer (ví dụ: your_domain_com.cer) được cấp bởi CA.
	- Mở Internet Information Services (IIS) Manager từ menu Start của Windows. Trong cửa sổ IIS Manager, tại cây thư mục Connections (bên trái), chọn tên máy chủ.
	- Tại trang chính của máy chủ (center pane), trong mục IIS, nhấp đúp vào Server Certificates. Trong trang Server Certificates, tại menu Actions (bên phải), chọn Complete Certificate Request.
	- Trong trình hướng dẫn Complete Certificate Request, tại trang Specify Certificate Authority Response:
		- File name containing the certificate authority's response: Nhấp nút […] để duyệt và chọn tệp .cer đã nhận từ CA.
		- Friendly name: Nhập tên định danh dễ nhớ cho chứng chỉ. Nên thêm tên CA và ngày hết hạn, ví dụ: yoursite-2026, để dễ phân biệt và quản lý.
		- Certificate store: Chọn Web Hosting từ danh sách.
	- Nhấn OK để hoàn tất cài đặt chứng chỉ.
- Gán chứng chỉ SSL cho website
	- Trong IIS Manager, tại cây thư mục Connections, mở rộng tên máy chủ đã cài chứng chỉ. Mở rộng mục Sites và chọn website cần bảo mật.
	- Tại trang chính của website, trong menu Actions (bên phải), chọn Bindings. Trong cửa sổ Site Bindings, nhấn Add.
	- Trong cửa sổ Add Site Binding:
		- Type: Chọn https.
		- IP address: Chọn địa chỉ IP cụ thể hoặc All Unassigned.
		- Port: Nhập 443.
		- SSL certificate: Chọn chứng chỉ SSL vừa cài đặt (ví dụ: yourdomain.com).
	- Nhấn OK để lưu cấu hình. Website hiện đã được cấu hình để chấp nhận kết nối HTTPS an toàn.
- Chú ý trong trường hợp gán cert với server IIS host nhiều website, từ website thứ hai được thêm SSL trong cửa sổ Add Site Binding, phần Hostname cần tích chọn `Require Server Name Indication` 

#### Tomcat 
- Tạo keystore và CSR cho Tomcat
	- Bước 1: Tạo keystore mới bằng Keytool
		- Tạo một keystore mới được khuyến nghị để tránh lỗi khi cài đặt chứng chỉ hoặc khiến chứng chỉ không hoạt động đúng.
		- Trước khi thực hiện, cần sao lưu và xóa các keystore cũ.
		- Di chuyển đến thư mục dự kiến quản lý keystore và chứng chỉ SSL/TLS.
		- Thực thi lệnh:
		```
		keytool -genkey -alias server -keyalg RSA -keysize 2048 -keystore your_site_name.jks
		```
			- Trong đó your_site_name là tên miền cần bảo mật. Không dùng dấu * nếu là chứng chỉ Wildcard.
		- Khi được nhắc, tạo mật khẩu cho keystore: Mật khẩu này sẽ được khai báo trong cấu hình Tomcat, dùng để tạo CSR và cài đặt chứng chỉ.
		- Khi được yêu cầu nhập tên (first and last name), nhập đầy đủ tên miền (FQDN), ví dụ: www.domain.com hoặc *.domain.com nếu là chứng chỉ Wildcard.
		- Nhập thông tin tổ chức theo yêu cầu.
		- Xác nhận thông tin bằng cách nhập y hoặc yes.
		- Khi được hỏi "key password for <server>", nhấn Enter để dùng lại mật khẩu keystore.
		- Keystore your_site_name.jks sẽ được tạo trong thư mục hiện tại.

	- Bước 2: Tạo CSR từ keystore vừa tạo
		- Thực thi lệnh:
		```
		keytool -certreq -alias server -file csr.txt -keystore your_site_name.jks
		```
		- Thay thế your_site_name bằng tên của keystore đã tạo.
		- Nhập lại mật khẩu keystore khi được yêu cầu.
		- Tệp csr.txt (hoặc your_site_domain.txt) chứa CSR sẽ được tạo trong thư mục hiện tại.

- Sử dụng CSR trên xin CA cấp , xác minh Domain.
- Convert định dạng chứng chỉ 
	- Chuyển đổi tệp chứng chỉ từ định dạng PEM (.cer hoặc .crt) sang định dạng PKCS#7 (.p7b). Có thể thực hiện trực tiếp trên hệ thống bằng cách sử dụng lệnh OpenSSL sau:
	```
	openssl crl2pkcs7 -nocrl -certfile certificate.cer -out certificate.p7b -certfile CACert.cer
	```
	- Trong đó:
		- certificate.cer: là tệp chứng chỉ chính cần chuyển đổi.
		- CACert.cer: là chứng chỉ của Tổ chức phát hành (CA).
		- certificate.p7b: là tệp đầu ra ở định dạng PKCS#7.
	- Lệnh này kết hợp chứng chỉ chính và chuỗi chứng chỉ trung gian, tạo ra tệp .p7b dùng để cài đặt trên một số máy chủ và nền tảng yêu cầu định dạng PKCS#7.
- Lưu tệp chứng chỉ được cấp ví dụ `your_domain_com.p7b` vào cùng thư mục với keystore Java.
- Cài đặt tệp chứng chỉ vào keystore
- Lưu ý: Phải cài đặt tệp chứng chỉ SSL/TLS vào đúng keystore và sử dụng đúng alias (ví dụ: -alias server) đã dùng khi tạo CSR. Nếu cài vào keystore khác hoặc dùng alias khác, lệnh import sẽ không hoạt động.
- Thực hiện lệnh sau để import chứng chỉ vào keystore:
	```
	keytool -import -alias server -file your_site_name.p7b -keystore your_site_name.jks
	```
	- Trong đó:
		- your_site_name.p7b: tệp chứng chỉ đã tải về.
		- your_site_name.jks: keystore đã tạo từ Bước 1 .
		- server: tên alias đã dùng khi tạo CSR.
	- Nếu thực hiện thành công, xuất hiện thông báo "Certificate reply was installed in keystore".
	- Nếu được hỏi có tin tưởng chứng chỉ không, nhập y hoặc yes.
	- Việc cài đặt này sẽ nạp toàn bộ chuỗi chứng chỉ cần thiết vào keystore.
	- Tệp your_site_name.jks hiện đã sẵn sàng để sử dụng trên máy chủ Tomcat.
- Cấu hình SSL/TLS Connector
- Trước khi Tomcat có thể chấp nhận kết nối an toàn, cần cấu hình SSL Connector.
- Mở tệp server.xml thông thường, tệp server.xml nằm trong thư mục conf của thư mục cài đặt Tomcat.
- Tìm đoạn cấu hình connector mà keystore mới sẽ được sử dụng.
- Thông thường sử dụng cổng 443 hoặc 8443. Có thể cần bỏ dấu chú thích (<!-- -->) để kích hoạt connector.
- Cấu hình lại đoạn connector, khai báo đầy đủ đường dẫn keystore và mật khẩu.Cấu hình mẫu như sau:
```
<Connector port="443"
           maxHttpHeaderSize="8192"
           maxThreads="100"
           minSpareThreads="25"
           maxSpareThreads="75"
           enableLookups="false"
           disableUploadTimeout="true"
           acceptCount="100"
           scheme="https"
           secure="true"
           SSLEnabled="true"
           clientAuth="false"
           sslProtocol="TLS"
           keyAlias="server"
           keystoreFile="/home/user_name/your_site_name.jks"
           keystorePass="your_keystore_password" />
```
- Trong đó:
	- keystoreFile: đường dẫn đầy đủ tới keystore.
	- keystorePass: mật khẩu đã đặt khi tạo keystore.
	- keyAlias: tên alias đã dùng khi tạo CSR (ví dụ: "server").
	Ghi chú: Nếu sử dụng Tomcat phiên bản cũ hơn Tomcat 7, cần thay keystorePass bằng keypass.
- Lưu lại tệp server.xml.
- Khởi động lại dịch vụ Tomcat.
```
sudo systemctl restart tomcat
```

### 6.2 Trên các Web hosting control panel 
#### CPanel
- CPanel hỗ trợ cài đặt và gia hạn chứng chỉ SSL tự động cho các tên miền trên máy chủ thông qua giao diện Manage AutoSSL trong WHM (WHM » Home » SSL/TLS » Manage AutoSSL). Theo mặc định, hệ thống sử dụng nhà cung cấp Let’s Encrypt™. Gói bản quyền cPanel đã bao gồm dịch vụ miễn phí này.
- ![images](./images/autossl_8.png)
- Sinh CSR sử dụng CPanel 
	- Đăng nhập vào tài khoản cPanel.
	- Trong mục Security, chọn SSL/TLS Manager.
	- ![images](./images/cpanel_csr_1.png)
	- Trong phần Certificate Signing Requests (CSR), nhấp vào Generate, view, or delete SSL certificate signing requests.
	- ![images](./images/cpanel_csr_2.png)
	- Trên màn hình tiếp theo, điền các thông tin chứng chỉ như sau:
		- Để nguyên tùy chọn “Generate a New 2048 bit key” trong trường Key*.
		- Trong trường Domains*, nhập tên miền (hoặc tên miền con) sẽ sử dụng chứng chỉ.
			- Lưu ý: Phải sử dụng tên miền đầy đủ (FQDN).
			- Lưu ý: Nếu sử dụng chứng chỉ Wildcard, khai báo tên miền có dấu hoa thị ở đầu, ví dụ: *.testcert.us. Chứng chỉ dạng này sẽ áp dụng cho testcert.us và tất cả các tên miền con.
		- Nhập thông tin vị trí tổ chức tại các trường City*, State* và Country*.
		- Nhập tên công ty vào trường Company*. Nếu không có tổ chức chính thức, có thể nhập “NA”.
		- Trường Company Division là không bắt buộc, có thể để trống hoặc nhập “NA”.
		- Trong trường Email, nhập bất kỳ địa chỉ email hợp lệ nào.
			- Lưu ý: Trường này không được dùng để xác thực quyền sở hữu miền hoặc nhận chứng chỉ.
		- Để trống các trường Passphrase và Description.
		- ![images](./images/cpanel_csr_3.png)
	- Sau khi điền đầy đủ thông tin, nhấp Generate. CSR đã được tạo thành công.
	- ![images](./images/cpanel_csr_4.png)
- Sử dụng CSR đã tạo xin CA cấp chứng chỉ, xác minh. 
- Cài đặt chứng chỉ SSL 
	- Đăng nhập vào tài khoản cPanel >> mục Security >> menu SSL/TLS Manager.
	- ![images](./images/cpanel_csr_1 (1).png)
	- Tại phần Install and Manage SSL for your site (HTTPS), nhấn vào Manage SSL Sites.
	- ![images](./images/cpanel_inst.png)
		- Lưu ý: Nếu không thấy tùy chọn này, có thể tài khoản không có đủ quyền quản trị để cài đặt SSL. Cần liên hệ nhà cung cấp dịch vụ lưu trữ để được hỗ trợ.
		- Mở tệp chứng chỉ bằng trình soạn thảo văn bản như Notepad.
		- Sao chép toàn bộ nội dung bao gồm cả phần đầu và phần cuối:
		```
		-----BEGIN CERTIFICATE-----
		...
		-----END CERTIFICATE-----
		```
		- Dán nội dung này vào ô Certificate: (CRT) trong giao diện cPanel.
		- Nhấn vào "Autofill by Certificate" để hệ thống tự động tìm và điền khóa riêng tương ứng (Private Key).
		- Khóa riêng này phải được lưu trên cùng máy chủ nơi đã tạo CSR.
		- Nếu CSR và Private Key không được tạo trên cùng máy chủ đang dùng để cài đặt chứng chỉ SSL, cần xuất Private Key từ máy chủ đã tạo, rồi dán thủ công vào ô Private Key: (KEY).
	- Cài đặt tệp CA-Bundle do Tổ chức phát hành chứng chỉ (CA) gửi kèm với chứng chỉ SSL chính.
		- Tệp CA-Bundle chứa chứng chỉ gốc và chứng chỉ trung gian, cần thiết để hoàn chỉnh chuỗi xác thực SSL.
		- Dù là tùy chọn, vẫn nên cài đặt CA-Bundle để tránh cảnh báo bảo mật trên thiết bị di động và trình duyệt cũ.
		- Tất cả chứng chỉ (gốc và trung gian) trong CA-Bundle cần được dán vào ô Certificate Authority Bundle: (CABUNDLE) trong quá trình cài đặt SSL qua cPanel.
	- ![images](./images/cpanel_inst_2.png)
	- Nhấn "Install Certificate" để hoàn tất
	- ![images](./images/cpanel_inst_3.png)

#### Plesk
- Let's Encrypt dùng để tạo chứng chỉ SSL miễn phí thường được kích hoạt tự động theo mặc định. Tuy nhiên, nếu chưa được bật, có thể thực hiện kích hoạt thủ công từ giao diện Plesk.
	- Bước 1: Đăng nhập vào Plesk và nhấp vào mục Let's Encrypt.
	- ![images](./images/LetsEncrypt.png)
	- Bước 2: Nhấn Install (trong trường hợp đã cài Let's Encrypt, nút này sẽ là Renew nếu muốn gia hạn chứng chỉ).
	- ![images](./images/InstallLetsEncrypt.png)
- Sinh CSR
	- Đăng nhập vào Plesk Panel.
	- ![images](./images/ples_k_1.png)
	- Tìm đến tên miền cần cài đặt chứng chỉ SSL trong tab Websites & Domains. Mở trình đơn thả xuống bên dưới tên website.
	- ![images](./images/ples_k_2.png)
	- Tại tab Dashboard, truy cập mục Security và nhấp vào SSL/TLS Certificates.
		- Nhấp vào "Advanced Settings" ở bên phải màn hình để mở bảng thiết lập SSL mới.
		- ![images](./images/ples_k_3.png)
		- Chọn tùy chọn Add SSL/TLS Certificate để thêm một mục chứng chỉ mới.
		- ![images](./images/ples_k_4.png)
		- Trong trang mới:
			- Nhập Certificate Name để đặt tên cho chứng chỉ SSL mới, giúp dễ phân biệt với các chứng chỉ khác trên máy chủ.
			- Điền các thông tin yêu cầu để tạo mã CSR:
			- Country: chọn quốc gia từ danh sách.
			- State or province: nhập bang hoặc tỉnh.
			- Location (city): nhập thành phố hoặc khu vực.
			- Organization name (company): nhập tên công ty. Nếu dùng chứng chỉ loại Organization hoặc EV SSL, nhà cung cấp chứng chỉ sẽ xác minh thông tin này. Nếu là Domain Validation (DV) SSL và không có công ty, có thể nhập “N/A”.
			- Organization department or division name: nhập tên bộ phận hoặc phòng ban, có thể nhập “N/A” nếu không có.
			- Domain name: nhập tên miền cần bảo vệ.
				- Lưu ý: Nếu dùng chứng chỉ Wildcard, khai báo tên miền với dấu hoa thị, ví dụ: *.example.com.
			- Email: nhập địa chỉ email hợp lệ.
	- Sau khi điền đầy đủ thông tin, nhấp Request.
	- ![images](./images/ples_k_5.png)
		- Kết quả:
			- Mã CSR sẽ được tạo và hệ thống chuyển về trang danh sách chứng chỉ SSL hiện có trên tên miền.
			- Cùng với mã CSR, khóa riêng (RSA Private Key) cũng được tạo. Khóa này sẽ cần sử dụng trong quá trình cài đặt chứng chỉ.
			- Để xem cả hai mã, nhấp vào mục chứng chỉ trong danh sách. CSR và Private Key sẽ hiển thị ở cuối trang.
		- ![images](./images/ples_k_7.png)
- Sử dụng CSR để thực hiện xin cấp chứng chỉ, xác minh.
- Cài đặt SSL
	- Đăng nhập vào Plesk Panel.
	- ![images](./images/ples_k_1.png)
	- Tìm đến tên miền cần cài đặt chứng chỉ SSL trong tab Websites & Domains. Mở trình đơn thả xuống bên dưới tên website.
	- ![images](./images/ples_k_2.png)
	- Tại tab Dashboard, truy cập mục Security và nhấp vào SSL/TLS Certificates.
		- Nhấp vào "Advanced Settings" ở bên phải màn hình để mở bảng thiết lập SSL mới.
		- ![images](./images/ples_k_3.png)
	- Chọn mục chứng chỉ SSL đã tạo khi tạo mã CSR để kích hoạt SSL.
	- ![images](./images/ples_k_8.png)
		- Tải các tệp chứng chỉ lên tại trang này.
		- Đầu tiên, tải lên chứng chỉ chính (end-entity certificate) được cấp cho tên miền tại phần Certificate ở đầu trang. Nhấp Choose File để tìm và chọn tệp trên máy tính.
		- Tiếp theo, nhấp Choose File bên cạnh mục CA Certificate để chọn chuỗi chứng chỉ trung gian (CA Bundle) dùng để xác thực chứng chỉ tên miền.
		- Sau khi chọn cả hai tệp, nhấn Upload Certificate.
		- ![images](./images/ples_k_9.png)
	- Quay lại menu Websites & Domains, nhấp vào Hosting Settings dưới tên miền cần áp dụng chứng chỉ.
	- ![images](./images/ples_k_10.png)
	- Tại trang tiếp theo, đến mục Security, chọn chứng chỉ muốn sử dụng từ danh sách thả xuống, sau đó nhấp Apply ở cuối trang.
	- Đảm bảo ô SSL Support được chọn.
	- ![images](./images/ples_k_11.png)
	- Hoàn tất: Chứng chỉ đã được cài đặt và áp dụng cho tên miền. 
	- ![images](./images/ples_k_19.png)
#### DirectAdmin
- DA hỗ trợ free SSL với Let's Encrypt 
	- Enable Let’s Encrypt trên DirecAdmin: yêu cầu version DirectAdmin phải trên 1.5 và version Custombuild phải trên 2.0
		- Thực hiện các lệnh để kiểm tra:
		```
		cd /usr/local/directadmin/custombuild
		./build version
		```
		- Bật tính năng Let’s Encrypt và SNI trên DirectAdmin, thực hiện các lệnh sau:
		```
		echo “letsencrypt=1” >> /usr/local/directadmin/conf/directadmin.conf
		echo “enable_ssl_sni=1” >> /usr/local/directadmin/conf/directadmin.conf
		```
		- Khởi động lại dịch vụ DirectAdmin:
		```
		/etc/init.d/directadmin restart
		```
		- Update license Let’s Encrypt:
		```
		wget -O /usr/local/directadmin/scripts/letsencrypt.sh http://files.directadmin.com/services/all/letsencrypt.sh
		```
		- Update web-server configs trên DirectAdmin bằng các lệnh sau:
		```
		cd /usr/local/directadmin/custombuild
		./build update
		./build letsencrypt
		./build rewrite_confs
		```
	- Cấu hình SSL 
		- Truy cập vào webpanel của DA theo địa chỉ: http://[ip-address]:2222 (với port mặc định của DA là 2222)
		- Login vào user quản lí domain cần add ssl, tại mức user level  chọn phần SSL Certificates.
		- ![images](./images/image-1633409085361.png)
		- Chọn Free & automatic certificate from Let’s Encrypt và nhấn Save để tiến hành add Let’s encrypt
		- ![images](./images/image-1633409702249.png)
		- Chờ server cài đặt ssl và chuyển hướng báo add key ssl thành công.

- Sinh CSR 
	- Truy cập vào webpanel của DA theo địa chỉ: http://[ip-address]:2222 (với port mặc định của DA là 2222)
	- Login vào user quản lí domain cần add ssl, tại mức user level  chọn phần SSL Certificates.
	- ![images](./images/image-1633409085361.png)
	- Nhấn vào nút  "Create A Certificate Request" và điền các thông tin cần thiết. Những thông tin này sẽ được đưa vào mã CSR gửi cho Tổ chức cấp chứng chỉ (Certificate Authority).
		- Mã quốc gia gồm hai chữ cái;
		- Bang/Tỉnh;
		- Thành phố;
		- Tên công ty;
		- Bộ phận công ty;
		- Tên miền phổ biến (Common Name) – là tên miền đầy đủ mà bạn muốn bảo mật bằng chứng chỉ SSL;
		- Email;
		- Kích thước khóa (bit), kích thước hiện đại tối thiểu là 2048 bit;
		- Loại chứng chỉ – thuật toán băm được sử dụng trong mã CSR.
	- ![images](./images/direct_3.jpg)
	- Sau khi hoàn tất, DirectAdmin sẽ hiển thị mã CSR cùng với khóa riêng tư. Mã CSR được sử dụng để kích hoạt chứng chỉ SSL. Cần sao chép mã này bao gồm cả phần đầu và phần cuối —–BEGIN CERTIFICATE REQUEST—– và —–END CERTIFICATE REQUEST—–.
	- ![images](./images/direct_4.jpg)
- Sử dụng CSR xin CA cấp chứng chỉ, xác minh 
- Cài đặt chứng chỉ SSl 
	- Truy cập vào webpanel của DA theo địa chỉ: http://[ip-address]:2222 (với port mặc định của DA là 2222)
	- Login vào user quản lí domain cần add ssl, tại mức user level  chọn phần SSL Certificates.
	- ![images](./images/image-1633409085361.png)
	- Copy nội dung file Private key và Certificate vào phần Paste a pre-generated Certificate and key >> Save
	- ![images](./images/file-1642143033096_1642143033050.jpg)
	- Trở lại `SSL Certificates` và chọn `Click Here to paste a CA Root Certificate`
	- ![images](./images/file-1642143036113_1642143036064.jpg)
	- ![images](./images/file-1642143043114_1642143039155.jpg)
	- Truy cập Domain Setup
	- ![images](./images/file-1642143052797_1642143052744.jpg)
	- Click Domain cần cài đặt
	- ![images](./images/file-1642143056316_1642143056254.jpg)
	- Click Use a symbolic link from private_html to public_html - allows for same data in http and https -> Save
	- ![images](./images/file-1642143059193_1642143059138.jpg)
### 6.3 SSL cho tên miền chính và subdomain
- Có hai phương án phổ biến để cấp chứng chỉ SSL cho cả tên miền chính và các subdomain:
- Sử dụng Wildcard SSL
	- Wildcard SSL cho phép bảo mật không giới hạn các subdomain dưới một tên miền chính (ví dụ: *.example.com).
	- Chỉ cần một chứng chỉ duy nhất để áp dụng cho www.example.com, mail.example.com, api.example.com, v.v.
	- Phù hợp khi tất cả subdomain thuộc cùng một cấp.
- Sử dụng Multi-Domain SSL (SAN/UCC)
	- Cho phép bảo mật nhiều tên miền và subdomain khác nhau trong cùng một chứng chỉ.
	- Ví dụ: example.com, www.example.com, sub1.example.net, mail.example.org.
	- Phù hợp khi cần bảo mật nhiều tên miền không cùng gốc.

### 6.4 Tự động gia hạn (Auto-renewal) với Let's Encrypt (Certbot, ACME,...)
#### ACME 
- Automated Certificate Management Environment - Giao thức Môi trường quản lý chứng chỉ tự động (ACME) là một cách chuẩn hóa để tự động hóa quy trình lấy và gia hạn SSL/TLS chứng chỉ. Nó cho phép máy chủ web chứng minh quyền sở hữu tên miền và nhận chứng chỉ mà không cần can thiệp thủ công. ACME tự động cấp và gia hạn chứng chỉ, cải thiện bảo mật trang web, giảm lỗi của con người trong quản lý chứng chỉ và được hỗ trợ rộng rãi bởi các cơ quan cấp chứng chỉ và máy chủ web.
- Giao thức ACME là một tiêu chuẩn mở được thiết kế để tự động hóa quá trình cấp phát và gia hạn chứng chỉ số, giúp đơn giản hóa đáng kể công tác quản lý chứng chỉ. Được phát triển nhằm tinh gọn toàn bộ quy trình, ACME đã được nhiều Tổ chức cấp chứng chỉ (CA) áp dụng rộng rãi và trở thành một tiêu chuẩn Internet (RFC 8555).
- Trước khi có ACME, việc đăng ký và quản lý chứng chỉ SSL/TLS thường yêu cầu thao tác thủ công và tốn thời gian. Quản trị viên hệ thống phải:
	- Tạo yêu cầu ký chứng chỉ (CSR)
	- Chứng minh quyền sở hữu tên miền qua nhiều phương thức khác nhau
	- Gửi CSR đến Tổ chức cấp chứng chỉ
	- Chờ phê duyệt và cấp chứng chỉ
	- Cài đặt chứng chỉ thủ công trên máy chủ web
	- Theo dõi và gia hạn chứng chỉ trước khi hết hạn
- Quy trình này dễ dẫn đến lỗi do con người và có thể khiến chứng chỉ hết hạn, gây cảnh báo bảo mật cho người truy cập.
- ACME tự động hóa toàn bộ quy trình thông qua một giao thức tiêu chuẩn cho phép máy chủ web giao tiếp trực tiếp với Tổ chức cấp chứng chỉ. Máy chủ web (ACME client) gửi yêu cầu cấp chứng chỉ cho tên miền cụ thể. Tổ chức cấp chứng chỉ (ACME server) đưa ra thử thách để xác minh quyền sở hữu tên miền, thường bằng cách yêu cầu đặt một tệp xác thực trên máy chủ. Khi quá trình xác minh hoàn tất, chứng chỉ được phát hành và cài đặt tự động. Toàn bộ quy trình có thể được thực hiện hoàn toàn tự động, bao gồm cả cài đặt ban đầu và các lần gia hạn định kỳ.
- Giao thức ACME mang lại nhiều lợi ích cho chủ sở hữu và quản trị viên website:
	- Tự động hóa: Giảm đáng kể sự can thiệp thủ công trong quá trình quản lý chứng chỉ.
	- Tăng cường bảo mật: Gia hạn định kỳ và tự động giúp chứng chỉ luôn được cập nhật.
	- Tiết kiệm chi phí: Nhiều CA hỗ trợ ACME cung cấp chứng chỉ miễn phí hoặc chi phí thấp.
	- Giảm thiểu lỗi: Tự động hóa giúp hạn chế rủi ro sai sót do con người.
	- Khả năng mở rộng: Cho phép quản lý chứng chỉ dễ dàng cho nhiều tên miền hoặc subdomain.
	- Chuẩn hóa: Là một tiêu chuẩn mở, ACME thúc đẩy khả năng tương thích giữa các hệ thống khác nhau.
#### Certbot Auto Renew 
- Certbot cài đặt mặc định thường đã bao gồm tác vụ tự động gia hạn. Có thể kiểm tra bằng lệnh 
```
systemctl list-timers | grep certbot
```
- Lệnh renew 	
	```
	sudo certbot renew 
	```
	- Có thể kiểm tra mô phỏng việc renew bằng option `--dry-run`
- Cấu hình auto renew certbot bằng crontab 
	```
	sudo crontab -e
	```
	- Thêm lệnh certbot vào lịch chạy hàng ngày. Trong ví dụ này, lệnh được thiết lập để chạy vào 12:00 trưa mỗi ngày. Lệnh sẽ kiểm tra chứng chỉ hiện có trên máy chủ có hết hạn trong vòng 30 ngày hay không và sẽ tự động gia hạn nếu cần. Tham số --quiet được sử dụng để hạn chế việc tạo đầu ra.
	```
	0 12 * * * /usr/bin/certbot renew --quiet
	```
	- Lưu và đóng tệp cấu hình. Tất cả chứng chỉ đã cài đặt sẽ được tự động gia hạn.

## 7. Cấu hình & kiểm tra SSL
### 7.1 Cấu hình HTTPS redirect (301)
- Cấu hình chuyển hướng HTTPS với mã trạng thái 301 là một bước quan trọng trong việc đảm bảo tính bảo mật và chuyên nghiệp cho website. Khi người dùng truy cập vào phiên bản HTTP (không an toàn), máy chủ sẽ tự động chuyển họ sang phiên bản HTTPS (có mã hóa SSL) với mã phản hồi 301 — nghĩa là chuyển hướng vĩnh viễn.
- Cách cấu hình với một số WebServer 
	- Apache: 
		- Sử dụng .htaccess
			- Thêm đoạn sau vào tệp .htaccess trong thư mục gốc của website:
			```
			<IfModule mod_rewrite.c>
			  RewriteEngine On
			  RewriteCond %{HTTPS} !=on
			  RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]
			</IfModule>
			```
			- Yêu cầu: Apache phải bật mod_rewrite.
		- Chỉnh sửa trong file `VirtualHost` thêm dòng sau vào phần cấu hình của `VirtualHost` trên port 80:
			`Redirect permanent / https://yourdomain.com/` 
			```
			## port 80
			<VirtualHost *:80>
			ServerName yourdomain.com
			Redirect permanent / https://yourdomain.com/
			</VirtualHost>
			## port 443
			<VirtualHost _default_:443>
			ServerName yourdomain.com
			DocumentRoot /usr/local/apache2/htdocs
			SSLEngine On
			...
			</VirtualHost>

			```
		- Sau khi chỉnh sửa, cần reload Apache:
		```
		sudo systemctl restart apache2
		```
	- Nginx: 
		- Chỉnh sửa trong khối cấu hình server lắng nghe cổng 80 (HTTP), thêm:
		```
		server {
			listen 80;
			server_name yourdomain.com www.yourdomain.com;
			return 301 https://$host$request_uri;
		}
		```
		- Sau khi chỉnh sửa, cần reload Nginx:
		```
		sudo systemctl reload nginx
		```

	- Tomcat
		- Trong tệp server.xml, chỉnh cấu hình cổng 80 như sau:
		```
		<Connector port="80" redirectPort="443" />
		```
		- Và đảm bảo cổng 443 đã được cấu hình với SSL.

	- IIS (Windows Server)
		- Sử dụng URL Rewrite 
			- Cài đặt module URL Rewrite.
			- Mở IIS Manager → chọn website → mở URL Rewrite.
			- Thêm quy tắc mới (Inbound Rule) với điều kiện {HTTPS} = OFF và hành động Redirect đến https://{HTTP_HOST}/{R:1}.
		- Sử dụng HTTP redirect
			- Tại panel quản lý website: Chọn ô Redirect và nhập URL đích sử dụng giao thức HTTPS. Thiết lập trạng thái chuyển hướng là chuyển hướng vĩnh viễn (301).
- Cấu hình với các Web hosting control panel
	- cPanel 
		- Vào Domains.
		- Bật tùy chọn Force HTTPS Redirect cho tên miền cần chuyển hướng.
		- ![images](./images/s-9.png)

	- DirecAdmin
		- Vào User Level → Domain Setup → chọn tên miền.
		- Bật tùy chọn: Force SSL with https redirect.
		- ![images](./images/s-7.png)
	- Plesk
		- Đăng nhập Plesk.
		- Vào Websites & Domains → chọn tên miền → Hosting Settings.
		- Tích chọn: Permanent SEO-safe 301 redirect from HTTP to HTTPS.
		- ![images](./images/s-8.png)

### 7.2 Cấu hình HSTS, OCSP Stapling, HTTP/2
#### 7.2.1 HSTS 
- HTTP Strict Transport Security (HSTS) là một cơ chế chính sách bảo mật web giúp bảo vệ website khỏi các cuộc tấn công hạ cấp giao thức (protocol downgrade) và chiếm đoạt cookie. Cơ chế này cho phép máy chủ web khai báo rằng trình duyệt (hoặc các tác nhân người dùng tương thích khác) chỉ được phép giao tiếp thông qua kết nối HTTPS bảo mật và tuyệt đối không sử dụng giao thức HTTP không an toàn.
- HSTS (HTTP Strict Transport Security) được phát triển nhằm giải quyết một số lỗ hổng bảo mật khi website chỉ dựa vào HTTPS mà không có biện pháp bổ sung:
	- Tấn công SSL Stripping: Kẻ tấn công có thể chặn yêu cầu HTTP ban đầu và chuyển hướng người dùng đến phiên bản không bảo mật của trang web.
	- Nội dung hỗn hợp (Mixed Content): Một số tài nguyên trên trang vẫn có thể được tải qua HTTP, gây rủi ro bảo mật.
	- Hành vi người dùng: Người dùng có thể nhập “http://” hoặc bỏ qua giao thức khi gõ URL, vô tình sử dụng kết nối không bảo mật.
	- HSTS khắc phục các vấn đề này bằng cách buộc mọi kết nối phải sử dụng HTTPS, kể cả khi người dùng truy cập qua HTTP.
- Cơ chế hoạt động của HSTS
	- Khi máy chủ web gửi tiêu đề HSTS trong phản hồi, trình duyệt sẽ được hướng dẫn:
	- Tự động chuyển mọi liên kết HTTP sang HTTPS.
	- Ngăn người dùng bỏ qua cảnh báo chứng chỉ.
	- Ghi nhớ chính sách này trong khoảng thời gian xác định (qua tham số max-age).
- Cấu trúc tiêu đề HSTS
	- max-age: Thời gian (tính bằng giây) mà trình duyệt ghi nhớ việc ép buộc HTTPS.
	- includeSubDomains (tùy chọn): Áp dụng chính sách HSTS cho toàn bộ subdomain.
	- preload (tùy chọn): Cho biết chủ sở hữu đồng ý đưa tên miền vào danh sách tải sẵn HSTS của trình duyệt.
- Lợi ích khi triển khai HSTS
	- Tăng cường bảo mật: Ngăn chặn tấn công dạng man-in-the-middle, SSL stripping và chiếm quyền cookie.
	- Cải thiện trải nghiệm người dùng: Tự động chuyển hướng sang HTTPS giúp giảm độ trễ.
	- Tối ưu hóa SEO: Các công cụ tìm kiếm ưu tiên website bảo mật hơn, có thể cải thiện thứ hạng.
	- Hỗ trợ tuân thủ: Đáp ứng yêu cầu bảo vệ dữ liệu và quyền riêng tư trong các quy định pháp lý.
- Cấu hình HSTS trên các WebServer 
	- Trước khi triển khai HSTS, cần đảm bảo website hoạt động đầy đủ qua HTTPS:
		- Cấp phát chứng chỉ SSL/TLS từ Tổ chức cấp chứng chỉ (CA) đáng tin cậy, chẳng hạn như SSL.com.
		- Cài đặt chứng chỉ lên máy chủ web.
		- Cấu hình máy chủ web để sử dụng kết nối HTTPS.
		- Cập nhật tất cả liên kết nội bộ sang giao thức HTTPS.
		- Đảm bảo toàn bộ tài nguyên bên ngoài (script, hình ảnh, v.v.) được tải qua HTTPS.
	- Bắt đầu bằng cách thêm tiêu đề HSTS với giá trị max-age ngắn để kiểm tra cấu hình. Ví dụ: sử dụng max-age=300 (tương đương 5 phút).
	- Apache2 
		- Để sử dụng header HSTS cần enable module headers trong `/etc/apache2/httpd.conf` thêm dòng:
		```
		LoadModule headers_module modules/mod_headers.so
		```
		- Bổ sung header HSTS vào VirtualHost cần cấu hình `/etc/apache2/sites-enabled/`: Cấu hình mẫu  
			```
			<VirtualHost *:443>
			...
			Header always set Strict-Transport-Security "max-age=300; includeSubDomains; preload"
			...
			</VirtualHost>
			```
			- Chú ý chỉ cấu hình trên VirtualHost ssl trên port 443 
			- Hoặc có thể cấu hình thêm header trên trong file `.htaccess` tại thư mục gốc của web 
	- Nginx 
		- Thêm header HSTS tại các file VirtualHost cần cấu hình 
		`add_header Strict-Transport-Security "max-age=300; includeSubDomains; preload" always;`
		- Cấu hình mẫu 
		```
		server {
			listen 80 default_server;
			listen [::]:80 default_server;
			server_name _;
			# Discourage deep links by using a permanent redirect to home page of HTTPS site
			return 301 https://$host;
			# Alternatively, redirect all HTTP links to the matching HTTPS page 
			# return 301 https://$host$request_uri;
		}
		server {
			listen 443 ssl;
			server_name www.example.com;

			add_header Strict-Transport-Security "max-age=300; includeSubDomains" always;
		}
		```
	- IIS 
		- Có thể thực hiện thêm header trong file `web.config` của source code 
		```
		<system.webServer>
		  <httpProtocol>
			<customHeaders>
			  <add name="Strict-Transport-Security" value="max-age=300; includeSubDomains; preload"/>
			</customHeaders>
		  </httpProtocol>
		</system.webServer>
		```
		- Hoặc sử dụng giao diện cấu hình `HTTP Respones Headers`
			- Mở Internet Information Services (IIS) Manager tại Start → Administrative Tools → IIS Manager. 
			- Chọn website cần cấu hình -> `HTTP Response Headers` tại panel `Actions` chọn `Add.`
			- ![images](./images/s-10.png)
			- ![images](./images/s-11.png)
			- Nhập các giá trị sau vào hộp thoại "Add Custom HTTP Response Headers":
				- Tên (Name): Strict-Transport-Security
				- Giá trị (Value): max-age=300
	- Apache Tomcat 
		- Tomcat cung cấp bộ lọc có tên HttpHeaderSecurityFilter, cho phép thêm các tiêu đề HTTP bảo mật như Strict-Transport-Security, X-Frame-Options và X-Content-Type-Options vào phản hồi.
		- Bộ lọc này có thể được thêm và cấu hình như các bộ lọc khác thông qua tệp web.xml. Ví dụ cấu hình trong tệp conf/web.xml.
		```
		<filter>
		  <filter-name>httpHeaderSecurity</filter-name>
		  <filter-class>org.apache.catalina.filters.HttpHeaderSecurityFilter</filter-class>
		  <async-supported>true</async-supported>
		  <init-param>
			<param-name>hstsEnabled</param-name>
			<param-value>true</param-value>
		  </init-param>
		  <init-param>
			<param-name>hstsMaxAgeSeconds</param-name>
			<param-value>300</param-value>
		  </init-param>
		  <init-param>
			<param-name>hstsIncludeSubDomains</param-name>
			<param-value>true</param-value>
		  </init-param>
		</filter>
		 
		<!-- The mapping for the HTTP header security Filter -->
		<filter-mapping>
		  <filter-name>httpHeaderSecurity</filter-name>
		  <url-pattern>/*</url-pattern>
		  <dispatcher>REQUEST</dispatcher>
		</filter-mapping>
		```
#### 7.2.2 OCSP Stapling
- OCSP (Online Certificate Status Protocol) là một giao thức Internet dùng để kiểm tra trạng thái thu hồi của chứng chỉ số X.509, thay thế cho phương pháp sử dụng danh sách thu hồi chứng chỉ (CRL). OCSP cho phép các ứng dụng (như trình duyệt web) kiểm tra trực tuyến xem một chứng chỉ có còn hiệu lực hay đã bị thu hồi hay không.
- OCSP stapling là một kỹ thuật được sử dụng để cải thiện hiệu suất và bảo mật của giao thức SSL/TLS bằng cách cho phép máy chủ web cung cấp trực tiếp phản hồi OCSP (Online Certificate Status Protocol) đã được ký và đóng dấu thời gian cho trình duyệt, thay vì trình duyệt phải tự truy vấn cơ quan cấp chứng chỉ (CA). Điều này giúp tăng tốc quá trình thiết lập kết nối và giảm tải cho các CA. 
- Hoạt động của OCSP stapling 
1. Máy chủ web định kỳ yêu cầu phản hồi OCSP: Máy chủ web định kỳ gửi yêu cầu đến OCSP responder (thường là CA hoặc nhà cung cấp dịch vụ khác) để xác thực chứng chỉ SSL/TLS của nó.
2. Phản hồi được đóng dấu thời gian và ký số: OCSP responder sẽ trả về một phản hồi đã được ký số và đóng dấu thời gian, xác nhận trạng thái của chứng chỉ (ví dụ: còn hiệu lực, bị thu hồi).
3. Máy chủ web "ghim" (staple) phản hồi: Máy chủ web lưu trữ phản hồi này và gửi nó cùng với chứng chỉ cho trình duyệt trong quá trình bắt tay SSL/TLS.
4. Trình duyệt xác thực chứng chỉ: Trình duyệt nhận phản hồi đã được ghim và xác thực chứng chỉ mà không cần phải thực hiện truy vấn riêng đến OCSP responder. 
- Ưu điểm của OCSP stapling:
	- Cải thiện hiệu suất: Giảm thời gian thiết lập kết nối SSL/TLS vì trình duyệt không cần thực hiện thêm một bước truy vấn OCSP, giúp cải thiện tốc độ tải trang web. 
	- Tăng cường bảo mật: Giảm tải cho các CA, giảm nguy cơ bị tấn công từ chối dịch vụ (DoS) hoặc các cuộc tấn công khác nhắm vào OCSP responder. 
	- Cải thiện quyền riêng tư: Tránh việc lộ thông tin duyệt web của người dùng cho các bên thứ ba, vì trình duyệt không còn phải trực tiếp truy vấn OCSP responder. 
	- Độ tin cậy cao: Đảm bảo rằng trình duyệt luôn nhận được phản hồi OCSP mới nhất và hợp lệ, giúp tăng cường độ tin cậy của quá trình xác thực chứng chỉ. 
- Nhược điểm 
	- Không phải tất cả trình duyệt hoặc máy chủ web đều hỗ trợ OCSP Stapling.
	- Nếu OCSP Stapling không được kích hoạt hoặc trên trình duyệt hoặc máy chủ web, nó không được sử dụng và tra cứu trạng thái hợp lệ sẽ được tự động hoàn nguyên về OCSP kiểm tra trực tiếp với Certificate Authority
- OCSP stapling là một kỹ thuật hiệu quả để cải thiện hiệu suất và bảo mật của SSL/TLS bằng cách cho phép máy chủ web tự xác thực chứng chỉ và cung cấp phản hồi cho trình duyệt, thay vì để trình duyệt tự thực hiện việc này. 
- Cấu hình OCSP Stapling với các web server 
- Apache 
	- OCSP stapling được hỗ trợ kể từ phiên bản Apache 2.3.3 trở đi. Kiểm tra bằng lệnh 
	```
	apache2 -v
	```
	- Tải về gói chứng chỉ CA (CA bundle): Tiến hành lấy các chứng chỉ Root CA và Intermediate CA ở định dạng PEM, sau đó lưu tất cả vào cùng một tệp. Gói chứng chỉ này được sử dụng để xây dựng chuỗi xác thực đầy đủ trên máy chủ.
	- File CA bundle bao gồm cả chứng chỉ CA intermediate và CA root.
	- Chỉnh sửa thêm các cấu hình trong VirtualHost
		- Thông số cache: Cấu hình nơi lưu cache, đặt bên ngoài cặp `<VirtualHost> </VirtualHost>`
		```
		SSLStaplingCache shmcb:/tmp/stapling_cache(128000)
		```
		- Các thông số enable tính năng và trỏ tới trust chain certificate đặt trong cặp `<VirtualHost> </VirtualHost>`
		```
		SSLCACertificateFile /etc/ssl/ca-certs.pem
		SSLUseStapling on
		```
	- Cấu hình mẫu 
	```
	<IfModule mod_ssl.c>
		SSLStaplingCache shmcb:/tmp/stapling_cache(128000)
		<VirtualHost *:443>

				ServerAdmin webmaster@localhost
				ServerName example.com
				DocumentRoot /var/www

				SSLEngine on

				SSLCertificateFile /etc/apache2/ssl/example.com/apache.crt
				SSLCertificateKeyFile /etc/apache2/ssl/example.com/apache.key

				SSLCACertificateFile /etc/ssl/ca-certs.pem
				SSLUseStapling on
		</VirtualHost>
	</IfModule>
	```
	- Test
	```
	apachectl -t
	```
	- Reload để apply 
	```
	service apache2 reload
	```
- Nginx	
	- OCSP stapling được hỗ trợ kể từ phiên bản Nginx 1.3.7+. trở đi. Kiểm tra bằng lệnh 
	```
	nginx -v
	```
	- Chỉnh sửa cấu hình tại các file virtualhost : Thêm các thống số sau 
	```
	ssl_stapling on;
	ssl_stapling_verify on;
	ssl_trusted_certificate /etc/ssl/private/ca-certs.pem;
	```
	- Cấu hình mẫu 
	```
	server {

			listen   443;
			server_name example.org;

			root /usr/share/nginx/www;
			index index.html index.htm;

			ssl on;
			ssl_certificate /etc/nginx/ssl/example.org/server.crt;
			ssl_certificate_key /etc/nginx/ssl/example.org/server.key;

			ssl_stapling on;
			ssl_stapling_verify on;
			ssl_trusted_certificate /etc/ssl/private/ca-certs.pem;
	}
	```
	- Test
	```
	service nginx configtest
	```
	- Reload để Apply
	```
	service nginx reload
	```
- IIS
	- Mặc định IIS hỗ trợ OCSP stapling từ Windows Server 2008 
	- Tuy nhiên đối với Host sử dụng tính năng Server Name Indication hoặc Use Centralized Certificate Store cần cấu hình enable:
	- Tại đường dẫn registry `[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL]`
	- Thêm subkey `"EnableOcspStaplingForSni"=dword:00000001`
- Tomcat 
	- Để kích hoạt OCSP Stapling trong Tomcat, cần đảm bảo cấu hình Tomcat sử dụng chứng chỉ có hỗ trợ OCSP và trình kết nối Tomcat Native được cấu hình để sử dụng OpenSSL. Ngoài ra, cần cấu hình OCSP responder và đảm bảo chứng chỉ chứa thông tin OCSP cần thiết. Khi được thiết lập đúng, Tomcat sẽ tự động xử lý quá trình stapling khi có yêu cầu từ phía client.
	- Kích hoạt APR Connector:
		- Trong tệp server.xml, đảm bảo APR connector được bật với các thuộc tính như sau:
	```
	SSLEnabled="true"
	protocol="org.apache.coyote.http11.Http11AprProtocol"
	```
	- Cấu hình SSL: Nếu sử dụng keystore, cần đảm bảo keystore được cấu hình chính xác trong APR connector.
	- Java 9 trở lên: Có thể bật OCSP Stapling bằng cách thiết lập thuộc tính hệ thống:	`jdk.tls.server.enableStatusRequestExtension`
	```
	System.setProperty(“jdk.tls.server.enableStatusRequestExtension”, “true”);
	```

#### 7.2.3 HTTP/2
- HTTP/2 là phiên bản lớn thứ hai của HTTP – giao thức mạng cấp ứng dụng quy định cách nội dung được truyền tải qua internet.
- Ra mắt vào năm 2015, HTTP/2 thay thế HTTP/1.1 với mục tiêu chính là tăng tốc độ phân phối nội dung.
- Tính năng chính giúp HTTP/2 tăng tốc là Stream Multiplexing: tạo một kết nối duy nhất cho mọi loại dữ liệu và truyền dữ liệu song song.
- Ngoài ra, HTTP/2 còn tăng tốc hơn nữa nhờ:
	- Nén tiêu đề (Header Compression).
	- Ưu tiên luồng (Stream Prioritization).
	- Sử dụng tính năng Server Push.
- Khác với HTTP/1.1, HTTP/2 là giao thức nhị phân, điều này cũng giúp nó hiệu quả hơn.
- Cấu hình với các Web server 
- Apache2
	- Disable mpm_prefork và Enable MPM_EVENT trong Apache2
	```
	sudo a2dismod mpm_prefork
	sudo a2enmod mpm_event
	sudo systemctl restart apache2
	```
	- Enable Module HTTP2
	```
	sudo a2enmod http2
	```
	- Sửa cấu hình virtual host thêm thông số và ngay dưới phần thẻ <VirtualHost *:443>
	```
	Protocols h2 http/1.1
	H2Direct on
	  <VirtualHost _default_:443>
		Protocols h2 h2c http/1.1
		H2Direct on
	  </VirtualHost>
	```
	- Reload Apache để apply
	```
	sudo systemctl restart apache2
	```
- Nginx:
	- Để bật HTTP/2 trong Nginx, chúng ta cần thêm tham số http2 vào chỉ thị listen trong cấu hình virtual host: Ví dụ file cấu hình mẫu:
	```
	listen 443 ssl http2;
	server {
	  listen 443 ssl http2;
	  listen [::]:443 ssl http2;
	  server_name example.com;
	  root /path/to/public;
	  ssl_certificate /path/to/certificate.crt;
	  ssl_certificate_key /path/to/private.key;
	  ssl_protocols TLSv1.2;
	}
	```
	- Reload Nginx để apply
	```
	sudo systemctl reload nginx.service
	```
- IIS: Mặc định HTTP/2 sẽ được enable khi enable HTTPS và cấu hình chứng chỉ SSL cho website
- Tomcat 
	- Đăng nhập vào máy chủ Tomcat và truy cập thư mục cài đặt
		- Truy cập thư mục conf
		- Chỉnh sửa tệp server.xml bằng vi hoặc trình soạn thảo yêu thích
		- Thêm dòng sau vào phần cấu hình SSL Connector:
		```
		<UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" />
		```
		- Cấu hình tổng thể sẽ có dạng như sau:
		```
		<Connector port="443" protocol="org.apache.coyote.http11.Http11AprProtocol"
				   maxThreads="150" SSLEnabled="true" >
			<UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" />
			<SSLHostConfig>
				<Certificate certificateKeyFile="conf/key.pem"
							 certificateFile="conf/cert.pem"
							 certificateChainFile="conf/chain.pem"
							 type="RSA" />
			</SSLHostConfig>
		</Connector>
		```
	- Khởi động lại Tomcat bằng cách chuyển đến thư mục bin và thực thi các lệnh sau:
	```
	./shutdown.sh
	./startup.sh
	```

### 7.3 Công cụ kiểm tra SSL:
#### 7.3.1 SSL Labs
- SSL Labs, cụ thể là SSL Labs của Qualys, là một công cụ trực tuyến miễn phí được sử dụng để kiểm tra cấu hình bảo mật của các máy chủ web, tập trung chủ yếu vào việc kiểm tra chứng chỉ SSL/TLS và giao thức liên quan. Nó đánh giá các khía cạnh như độ mạnh của thuật toán mã hóa, cấu hình giao thức, và khả năng chống lại các tấn công tiềm ẩn, từ đó cung cấp thông tin chi tiết và điểm đánh giá về mức độ bảo mật của website. 
- SSL Lab cung cấp 
	- Kiểm tra chứng chỉ SSL/TLS: SSL Labs phân tích chứng chỉ SSL/TLS của một máy chủ, kiểm tra thời hạn, nhà phát hành, thuật toán ký, và các thông tin liên quan khác. 
	- Đánh giá giao thức và thuật toán: Công cụ này kiểm tra các giao thức và thuật toán mã hóa được hỗ trợ bởi máy chủ, bao gồm cả TLS và các bộ mã hóa, để xác định xem chúng có đủ mạnh và an toàn hay không. 
	- Phân tích cấu hình: SSL Labs đánh giá cấu hình của máy chủ, bao gồm cả việc hỗ trợ các giao thức lỗi thời hoặc các bộ mã hóa yếu, và cung cấp thông tin chi tiết về các vấn đề cấu hình có thể xảy ra. 
	- Điểm đánh giá: Dựa trên các phân tích, SSL Labs sẽ đưa ra một điểm đánh giá tổng quan về mức độ bảo mật của máy chủ, giúp người dùng dễ dàng hiểu được tình trạng bảo mật của website. 
	- Công cụ kiểm tra trực tuyến: SSL Labs là một công cụ trực tuyến miễn phí, người dùng có thể truy cập và sử dụng để kiểm tra bất kỳ website nào. 
- ![images](./images/s-12.png)

#### 7.3.2 SSL Checker
### 7.4 Đánh giá bảo mật (SSL Rating)

## 8. Lỗi thường gặp
•Mixed content
•ERR_CERT_COMMON_NAME_INVALID
•SSL handshake failure
•Expired certificate
•Không tin cậy do thiếu intermediate cert

🔐 9. Giao thức & chuẩn liên quan
•HTTPS (SSL over HTTP)
•SMTPS, IMAPS, POP3S (ứng dụng SSL trong email)
•TLS versions và security policy (ví dụ tắt TLS 1.0/1.1)

🧰 10. Xu hướng trong tương lai
•  Phát triển của TLS 1.3 và các cải tiến bảo mật. 
•  Tích hợp SSL với các công nghệ mới (HTTP/3, QUIC). 
•  Tự động hóa chứng chỉ SSL
📚 11. SSL và luật pháp – Quy định
•Quy định về bảo mật thông tin (PCI-DSS, GDPR, HIPAA,...)
•Vai trò SSL trong các tiêu chuẩn bảo mật doanh nghiệp